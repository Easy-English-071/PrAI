<!DOCTYPE html>
<html lang="vi" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrAI - Luyện Phát Âm với AI</title>
    <!-- Favicon and fonts -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23007CF0;'/%3E%3Cstop offset='100%25' style='stop-color:%2300DFD8;'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3Ctext x='50' y='55' font-family='Exo 2, sans-serif' font-size='40' font-weight='700' fill='white' text-anchor='middle' dominant-baseline='middle'%3EPrAI%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans:wght@400;700&family=Exo+2:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- GLOBAL & THEME STYLES --- */
        :root {
            --bg-color: #f8fafc;
            --bg-blob-1: #0ea5e9;
            --bg-blob-2: #14b8a6;
            --glass-bg: rgba(248, 250, 252, 0.6);
            --glass-border: rgba(255, 255, 255, 0.7);
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --accent-primary: #007CF0;
            --accent-danger: #ef4444;
            --accent-success: #22c55e;
            --accent-warning: #f59e0b;
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0056b3;
            --btn-secondary-bg: rgba(241, 245, 249, 0.7);
            --btn-secondary-hover-bg: rgba(226, 232, 240, 0.9);
            --input-bg: rgba(255, 255, 255, 0.4);
            --input-focus-bg: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(100, 116, 139, 0.2);
            --highlight-correct: rgba(34, 197, 94, 0.1);
            --highlight-approximate: rgba(245, 158, 11, 0.1);
            --highlight-incorrect: rgba(239, 68, 68, 0.1);
            --radius-sm: 0.75rem;
            --radius-md: 1rem;
            --radius-lg: 1.5rem;
            --msg-color-info: #0369a1;
            --msg-color-success: #166534;
            --msg-color-warning: #92400e;
            --msg-color-error: #991b1b;
        }

        [data-theme="dark"] {
            --bg-color: #020617;
            --bg-blob-1: #0369a1;
            --bg-blob-2: #0d9488;
            --glass-bg: rgba(30, 41, 59, 0.5);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0095ff;
            --btn-secondary-bg: rgba(51, 65, 85, 0.5);
            --btn-secondary-hover-bg: rgba(51, 65, 85, 0.8);
            --input-bg: rgba(15, 23, 42, 0.5);
            --input-focus-bg: rgba(15, 23, 42, 0.7);
            --shadow-color: rgba(0, 0, 0, 0.35);
            --highlight-correct: rgba(74, 222, 128, 0.15);
            --highlight-approximate: rgba(250, 204, 21, 0.15);
            --highlight-incorrect: rgba(248, 113, 113, 0.15);
            --msg-color-info: #7dd3fc;
            --msg-color-success: #86efac;
            --msg-color-warning: #fde047;
            --msg-color-error: #fca5a5;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
        }

        .background-container {
            width: 100%; height: 100%; position: fixed;
            top: 0; left: 0; z-index: -1; overflow: hidden;
        }
        .blob { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.4; }
        .blob-1 { width: 450px; height: 450px; background: var(--bg-blob-1); animation: move 20s infinite alternate; }
        .blob-2 { width: 350px; height: 350px; background: var(--bg-blob-2); animation: move 25s infinite alternate-reverse; animation-delay: -5s; }

        @keyframes move {
            from { transform: translate(-15vw, -15vh) scale(1) rotate(0deg); }
            to { transform: translate(65vw, 75vh) scale(1.2) rotate(180deg); }
        }

        .font-logo { font-family: 'Exo 2', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text, .phoneme, .ipa-text { font-family: 'Noto Sans', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text { word-break: break-word; }

        .glass-card {
            background-color: var(--glass-bg);
            backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
            box-shadow: 0 8px 32px 0 var(--shadow-color), inset 0 1px 0 0 var(--glass-border);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease-in-out;
        }

        .main-card { padding: clamp(1rem, 5vw, 2.5rem); }
        .card-layer { padding: 1.5rem; border-radius: var(--radius-md); }
        .card-layer-inset {
            background-color: var(--input-bg); padding: 1rem; border-radius: var(--radius-md);
            border: 1px solid var(--glass-border); box-shadow: inset 0 2px 4px var(--shadow-color);
        }

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: var(--radius-sm); font-weight: 600;
            border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px var(--shadow-color);
        }
        .btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px var(--shadow-color); }
        .btn:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 10px var(--shadow-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--btn-primary-bg); color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .btn-primary:hover:not(:disabled) { background-color: var(--btn-primary-hover-bg); }

        .btn-secondary {
            background-color: var(--btn-secondary-bg); color: var(--text-secondary);
            border: 1px solid var(--glass-border); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        .btn-secondary:hover:not(:disabled) { background-color: var(--btn-secondary-hover-bg); color: var(--text-primary); }

        .btn-icon {
            width: 2.75rem; height: 2.75rem; border-radius: 50%;
            padding: 0; flex-shrink: 0; position: relative;
            display: inline-flex; align-items: center; justify-content: center;
        }
        .btn-icon > .icon { margin: auto; }
        
        .btn-record {
            width: 7rem; height: 7rem; border-radius: 50%;
            background: radial-gradient(circle, #ff5f5f 0%, #ef4444 100%);
            color: #ffffff; font-weight: 600; cursor: pointer;
            box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
            border: 3px solid rgba(255, 255, 255, 0.4);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .btn-record:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 15px 30px color-mix(in srgb, var(--accent-danger) 40%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2); }
        .btn-record.is-recording { animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 70%, transparent); }
            70% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 15px color-mix(in srgb, var(--accent-danger) 0%, transparent); }
            100% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 0%, transparent); }
        }
        
        .input-field {
            width: 100%; background-color: var(--input-bg); border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm); padding: 0.75rem 1rem; color: var(--text-primary);
            transition: all 0.2s ease-in-out; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .input-field:focus {
            outline: none; border-color: var(--accent-primary); background-color: var(--input-focus-bg);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }
        textarea.input-field { resize: vertical; min-height: 80px; }

        .phoneme {
            padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 1.125rem;
            position: relative; transition: all 0.2s ease-in-out; color: var(--text-secondary);
        }
        .phoneme.status-correct { background-color: var(--highlight-correct); color: var(--accent-success); }
        .phoneme.status-approximate { background-color: var(--highlight-approximate); color: var(--accent-warning); }
        .phoneme.status-incorrect { background-color: var(--highlight-incorrect); color: var(--accent-danger); }

        .tooltip {
            visibility: hidden; opacity: 0; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translate(-50%, 10px); background-color: var(--bg-color); color: var(--text-primary);
            border: 1px solid var(--glass-border); z-index: 20;
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 0.5rem;
            width: 256px;
            border-radius: 0.75rem;
            padding: 0.75rem;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .has-tooltip:hover .tooltip { 
             visibility: visible; 
             opacity: 1; 
        }
        
        .score-container {
            width: 140px; height: 140px; margin: 1rem auto; display: flex; align-items: center; justify-content: center;
            transition: all 0.5s ease-out; border-radius: 50%; border: 4px solid transparent;
            background: radial-gradient(circle, color-mix(in srgb, var(--accent-primary) 10%, transparent) 0%, rgba(74, 128, 240, 0) 70%);
        }
        .score-container.score-high { border-color: var(--accent-success); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-success) 50%, transparent); }
        .score-container.score-medium { border-color: var(--accent-warning); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-warning) 50%, transparent); }
        .score-container.score-low { border-color: var(--accent-danger); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-danger) 50%, transparent); }
        
        #overall-score { font-size: 3.5rem; font-weight: 700; color: var(--text-primary); transition: color 0.5s ease-out; }
        .score-high #overall-score { color: var(--accent-success); }
        .score-medium #overall-score { color: var(--accent-warning); }
        .score-low #overall-score { color: var(--accent-danger); }

        #detailed-ipa-text { color: var(--accent-primary); }
        
        .thought-group {
            padding: 0.25rem 0.75rem; border-radius: 0.5rem; margin: 0.1rem;
            display: inline-block; transition: background-color 0.3s;
        }
        [data-theme="dark"] .thought-group-0 { background-color: rgba(96, 165, 250, 0.2); color: #bfdbfe; }
        [data-theme="dark"] .thought-group-1 { background-color: rgba(52, 211, 153, 0.2); color: #a7f3d0; }
        [data-theme="dark"] .thought-group-2 { background-color: rgba(250, 204, 21, 0.2); color: #fef08a; }
        [data-theme="dark"] .thought-group-3 { background-color: rgba(192, 132, 252, 0.2); color: #e9d5ff; }
        [data-theme="light"] .thought-group-0 { background-color: rgba(59, 130, 246, 0.15); color: #1e40af; }
        [data-theme="light"] .thought-group-1 { background-color: rgba(16, 185, 129, 0.15); color: #065f46; }
        [data-theme="light"] .thought-group-2 { background-color: rgba(245, 158, 11, 0.15); color: #92400e; }
        [data-theme="light"] .thought-group-3 { background-color: rgba(168, 85, 247, 0.15); color: #6b21a8; }
        
        .btn-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .fade-in { animation: fadeIn 0.6s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.is-visible {
            opacity: 1; visibility: visible;
        }
        .modal-container {
            width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .modal-overlay.is-visible .modal-container {
            transform: scale(1);
        }
        .history-item { cursor: pointer; transition: background-color 0.2s; }
        .history-item:hover { background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); }
        .history-item-text { color: var(--text-primary); }

        /* --- NEW ANALYSIS UI STYLES --- */
        .analysis-box-detailed {
            background-color: color-mix(in srgb, var(--input-bg) 60%, transparent);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1.25rem;
            box-shadow: inset 0 2px 4px color-mix(in srgb, var(--shadow-color) 50%, transparent);
        }

        .analysis-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .intonation-chart-container {
            width: 100%;
            height: 180px;
            background-color: var(--input-bg);
            border-radius: var(--radius-sm);
            padding: 0.5rem;
            border: 1px solid var(--glass-border);
            margin-bottom: 1rem;
        }
        
        .syllable-chart-container {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            padding: 1rem 0;
            flex-wrap: wrap;
        }
        .syllable {
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius-sm);
            font-size: 1.125rem;
            font-weight: 500;
            border: 2px solid var(--glass-border);
            background-color: var(--input-bg);
            color: var(--text-secondary);
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        .syllable.stressed {
            font-weight: 700;
            border-color: var(--accent-primary);
            background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            color: var(--accent-primary);
            transform: scale(1.1);
            box-shadow: 0 0 15px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }
        
        .connected-speech-item {
            padding: 1rem;
            border-radius: var(--radius-sm);
            border-left: 4px solid;
            position: relative;
            overflow: hidden;
        }

        .connected-speech-item.type-catenation, .connected-speech-item.type-linking { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.1); }
        .connected-speech-item.type-assimilation { border-color: #a855f7; background-color: rgba(168, 85, 247, 0.1); }
        .connected-speech-item.type-elision { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.1); }
        .connected-speech-item.type-intrusion { border-color: #14b8a6; background-color: rgba(20, 184, 166, 0.1); }
        .connected-speech-item.type-weak-form, .connected-speech-item.type-reduction { border-color: #f59e0b; background-color: rgba(245, 158, 11, 0.1); }
        .connected-speech-item.type-elision-and-weak-forms { border-color: #c026d3; background-color: rgba(192, 38, 211, 0.1);}
        
        [data-theme="dark"] .connected-speech-item.type-catenation, 
        [data-theme="dark"] .connected-speech-item.type-linking { background-color: rgba(59, 130, 246, 0.2); }
        [data-theme="dark"] .connected-speech-item.type-assimilation { background-color: rgba(168, 85, 247, 0.2); }
        [data-theme="dark"] .connected-speech-item.type-elision { background-color: rgba(239, 68, 68, 0.2); }
        [data-theme="dark"] .connected-speech-item.type-intrusion { background-color: rgba(20, 184, 166, 0.2); }
        [data-theme="dark"] .connected-speech-item.type-weak-form, 
        [data-theme="dark"] .connected-speech-item.type-reduction { background-color: rgba(245, 158, 11, 0.2); }
        [data-theme="dark"] .connected-speech-item.type-elision-and-weak-forms { background-color: rgba(192, 38, 211, 0.2); }


        .cs-title { font-weight: 600; color: var(--text-primary); }
        .cs-location { font-family: 'Noto Sans', sans-serif; background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.9em; }
        .cs-details { font-size: 0.875rem; color: var(--text-secondary); }
        .cs-feedback { margin-top: 0.5rem; font-style: italic; }

        #mismatch-notification-bar {
            padding: 1rem;
            border-radius: var(--radius-md);
            border-left: 5px solid var(--accent-warning);
            background-color: var(--highlight-approximate);
            color: var(--msg-color-warning);
            margin-bottom: 1.5rem;
        }
    </style>
</head>
<body class="antialiased">
    <div class="background-container">
        <div class="blob blob-1"></div>
        <div class="blob blob-2"></div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-container glass-card p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h3 class="font-bold text-text-primary text-xl">Lịch sử Luyện tập</h3>
                <button id="close-history-btn" class="btn btn-secondary btn-icon !w-8 !h-8">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="history-list" class="space-y-2"></div>
            <button id="clear-history-btn" class="btn btn-secondary w-full">Xóa tất cả lịch sử</button>
        </div>
    </div>

    <div class="w-full max-w-3xl mx-auto p-4 relative z-10">
        <header class="text-center mb-8 fade-in relative flex justify-between items-center">
            <button id="history-btn" class="btn btn-secondary btn-icon" aria-label="Xem lịch sử">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            <div class="absolute left-1/2 -translate-x-1/2">
                <h1 class="text-5xl md:text-6xl font-bold font-logo" style="color: var(--accent-primary);">PrAI</h1>
                <p class="text-text-secondary text-sm md:text-base">Trợ lý luyện phát âm AI của bạn</p>
            </div>
            <button id="theme-toggle" class="btn btn-secondary btn-icon" aria-label="Toggle theme">
                <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
            </button>
        </header>

        <main class="main-card glass-card space-y-8">
            <section class="input-section card-layer glass-card space-y-4">
                <div>
                    <label for="text-input" class="block text-lg font-semibold text-text-primary mb-3">Nhập văn bản cần luyện tập:</label>
                    <textarea id="text-input" rows="3" maxlength="150" class="input-field" placeholder="Ví dụ: What are you doing?"></textarea>
                    <div id="char-counter" class="text-right text-sm text-text-secondary mt-1">0 / 150</div>
                    <div class="mt-4 flex flex-col sm:flex-row items-center gap-4">
                        <div class="flex-grow w-full">
                            <label for="accent-select" class="block text-sm font-medium text-text-secondary mb-1">Chọn giọng:</label>
                            <select id="accent-select" class="input-field">
                                <option value="British English" selected>Anh - Anh (BrE)</option>
                                <option value="American English">Anh - Mỹ (AmE)</option>
                            </select>
                        </div>
                        <div class="flex-shrink-0 flex gap-3 self-end">
                            <button id="random-practice-btn" class="btn btn-secondary">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 8"/><path d="M21 22v-6h-6"/><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"/></svg>
                                <span class="text hidden sm:inline">Ngẫu nhiên</span>
                            </button>
                             <button id="transcribe-btn" class="btn btn-primary relative">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                                 <span class="text">Phiên âm</span>
                                 <div class="btn-spinner hidden absolute inset-0 m-auto h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                             </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="controls-section" class="hidden space-y-6">
                 <div class="card-layer glass-card space-y-4">
                     <!-- Section for Simple IPA and Clear Voice -->
                     <div id="ipa-container" class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                         <div class="min-w-0 flex-grow">
                             <h3 class="font-semibold text-text-secondary text-md mb-1">Phiên âm (Rõ ràng)</h3>
                             <p id="simple-ipa-text" class="text-xl text-text-primary tracking-wider"></p>
                         </div>
                         <div class="flex-shrink-0">
                             <div class="relative w-11 h-11" id="listen-clear-container">
                                 <button id="listen-clear-btn" class="btn-icon btn-secondary absolute inset-0">
                                     <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>
                                 </button>
                                 <div id="listen-clear-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                     <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                                 </div>
                             </div>
                         </div>
                     </div>
                     <!-- Section for Detailed IPA, Thought Groups, and Natural Voice -->
                     <div id="detailed-ipa-container" class="space-y-4 hidden pt-4 border-t border-[color:var(--glass-border)]">
                         <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
                             <div class="min-w-0 flex-grow">
                                 <div class="flex items-center gap-2 mb-1">
                                     <h3 class="font-semibold text-text-secondary text-md">Phiên âm & Cụm tư duy (Tự nhiên)</h3>
                                     <div id="thought-group-info" class="has-tooltip relative hidden">
                                         <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-text-secondary cursor-pointer"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                                         <div id="thought-group-tooltip" class="tooltip"></div>
                                     </div>
                                 </div>
                                 <p id="detailed-ipa-text" class="text-xl tracking-wider"></p>
                                 <div id="thought-group-display" class="text-lg tracking-wide leading-relaxed font-medium mt-2"></div>
                             </div>
                             <div class="flex-shrink-0">
                                 <div class="relative w-11 h-11" id="natural-voice-container">
                                     <button id="listen-natural-btn" class="btn-icon btn-secondary absolute inset-0">
                                         <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                                     </button>
                                     <div id="listen-natural-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                         <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                                     </div>
                                 </div>
                             </div>
                         </div>
                     </div>
                 </div>

                <div class="flex flex-col items-center justify-center gap-4 pt-4">
                    <div id="record-controls" class="flex items-center justify-center gap-6 w-full h-28">
                        <button id="upload-btn" class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        </button>
                        <div class="flex flex-col items-center justify-center">
                            <button id="record-btn" class="btn-record flex items-center justify-center">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                                <span class="text hidden text-lg font-semibold">Dừng</span>
                            </button>
                        </div>
                        <button id="listen-again-btn" disabled class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
                        </button>
                    </div>
                    <div id="waveform-container" class="hidden h-20 w-full card-layer-inset flex items-center justify-center p-2">
                        <canvas id="waveform" class="w-full h-full"></canvas>
                    </div>
                </div>
            </section>

            <div id="loader" class="text-center hidden py-4 flex flex-col items-center justify-center">
                <div class="w-full max-w-xs h-2 rounded-full overflow-hidden bg-[color:var(--input-bg)]">
                    <div id="progress-bar-inner" class="h-full rounded-full bg-gradient-to-r from-sky-400 to-teal-400 transition-all duration-500"></div>
                </div>
                <p id="progress-text" class="text-text-secondary mt-4">PrAI đang lắng nghe và phân tích...</p>
                <p id="fun-fact" class="text-sm text-text-secondary/70 mt-6 italic hidden"></p>
            </div>

            <!-- UPDATED ANALYSIS RESULTS SECTION -->
            <section id="analysis-results" class="hidden space-y-6">
                <div class="card-layer glass-card space-y-6 p-6">
                    <div id="mismatch-notification-bar" class="hidden"></div>
                    <h3 class="font-bold text-text-primary text-2xl text-center">Kết quả Phân tích</h3>
                
                    <!-- Overall Score -->
                    <div class="score-container">
                        <p><span id="overall-score"></span><span class="text-xl text-text-secondary">/100</span></p>
                    </div>
                
                    <!-- Phoneme Analysis -->
                    <div class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Âm vị</h4>
                        <div id="phoneme-analysis" class="flex flex-wrap gap-2 justify-center"></div>
                        <p class="text-xs text-text-secondary mt-3 text-center">Chạm hoặc di chuột qua các âm vị để xem hướng dẫn.</p>
                    </div>
                
                    <!-- Intonation / Syllable Analysis -->
                    <div id="prosody-analysis-container" class="analysis-box-detailed">
                        <h4 id="prosody-analysis-title" class="analysis-title"></h4>
                        <!-- Container for Sentence Intonation Chart -->
                        <div id="intonation-analysis-content" class="hidden">
                            <div class="intonation-chart-container">
                                <svg id="intonation-chart" width="100%" height="100%"></svg>
                            </div>
                            <div id="intonation-analysis-feedback" class="text-sm text-text-secondary"></div>
                        </div>
                        <!-- Container for Single Word Syllable Chart -->
                        <div id="syllable-analysis-content" class="hidden">
                            <div id="syllable-chart-container" class="syllable-chart-container"></div>
                            <div id="syllable-analysis-feedback" class="text-sm text-text-secondary text-center"></div>
                        </div>
                    </div>
                
                    <!-- Connected Speech Analysis -->
                    <div id="connected-speech-container" class="analysis-box-detailed hidden">
                        <h4 class="analysis-title">Phân tích Nối âm & Cụm tư duy</h4>
                        <div id="connected-speech-analysis" class="space-y-3"></div>
                    </div>
                </div>
            
                <!-- Practice Suggestions Section -->
                <div id="practice-suggestions" class="hidden card-layer glass-card">
                     <h3 class="font-bold text-text-primary text-xl mb-4">Xem ví dụ thực tế</h3>
                     <div id="suggestion-links" class="flex flex-col sm:flex-row gap-3 mt-2"></div>
                </div>
            </section>
        </main>

        <div id="message-box" class="fixed top-5 right-5 hidden p-4 rounded-xl text-sm z-50 shadow-lg glass-card"></div>
        <audio id="replay-audio" class="hidden"></audio>
        <input type="file" id="audio-upload-input" class="hidden" accept="audio/*">

        <footer class="text-center mt-8 text-text-secondary text-sm">
            <p>© 2025 PrAI. Được tạo ra với niềm đam mê ngôn ngữ bởi Mr Bảo.</p>
        </footer>
    </div>

    <script type="module">
        // --- THEME SWITCHER LOGIC ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const docElement = document.documentElement;

        function applyTheme(theme) {
            docElement.setAttribute('data-theme', theme);
            if (theme === 'light') {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
            localStorage.setItem('prai-theme', theme);
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = docElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        });

        const savedTheme = localStorage.getItem('prai-theme') || 'light';
        applyTheme(savedTheme);


        // --- APP LOGIC ---
        const textInput = document.getElementById('text-input');
        const accentSelect = document.getElementById('accent-select');
        const transcribeBtn = document.getElementById('transcribe-btn');
        const listenNaturalBtn = document.getElementById('listen-natural-btn');
        const listenClearBtn = document.getElementById('listen-clear-btn');
        const listenClearLoader = document.getElementById('listen-clear-loader');
        const listenNaturalLoader = document.getElementById('listen-natural-loader');
        const recordControls = document.getElementById('record-controls');
        const uploadBtn = document.getElementById('upload-btn');
        const recordBtn = document.getElementById('record-btn');
        const listenAgainBtn = document.getElementById('listen-again-btn');
        const randomPracticeBtn = document.getElementById('random-practice-btn');
        const controlsSection = document.getElementById('controls-section');
        const loader = document.getElementById('loader');
        const simpleIpaText = document.getElementById('simple-ipa-text');
        const detailedIpaText = document.getElementById('detailed-ipa-text');
        const analysisResults = document.getElementById('analysis-results');
        const overallScore = document.getElementById('overall-score');
        const phonemeAnalysis = document.getElementById('phoneme-analysis');
        const practiceSuggestions = document.getElementById('practice-suggestions');
        const suggestionLinks = document.getElementById('suggestion-links');
        const messageBox = document.getElementById('message-box');
        const waveformContainer = document.getElementById('waveform-container');
        const waveformEl = document.getElementById('waveform');
        const replayAudio = document.getElementById('replay-audio');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const funFactEl = document.getElementById('fun-fact');
        const connectedSpeechAnalysis = document.getElementById('connected-speech-analysis');
        const progressText = document.getElementById('progress-text');
        const progressBarInner = document.getElementById('progress-bar-inner');
        const charCounter = document.getElementById('char-counter');
        const thoughtGroupDisplay = document.getElementById('thought-group-display');
        const thoughtGroupInfo = document.getElementById('thought-group-info');
        const thoughtGroupTooltip = document.getElementById('thought-group-tooltip');
        const detailedIpaContainer = document.getElementById('detailed-ipa-container');
        const mismatchNotificationBar = document.getElementById('mismatch-notification-bar');
        
        // NEW ANALYSIS SECTION ELEMENTS
        const prosodyAnalysisContainer = document.getElementById('prosody-analysis-container');
        const prosodyAnalysisTitle = document.getElementById('prosody-analysis-title');
        const intonationAnalysisContent = document.getElementById('intonation-analysis-content');
        const syllableAnalysisContent = document.getElementById('syllable-analysis-content');
        const syllableChartContainer = document.getElementById('syllable-chart-container');
        const syllableAnalysisFeedback = document.getElementById('syllable-analysis-feedback');
        const intonationAnalysisFeedback = document.getElementById('intonation-analysis-feedback');
        const intonationChart = document.getElementById('intonation-chart');
        const connectedSpeechContainer = document.getElementById('connected-speech-container');

        const historyBtn = document.getElementById('history-btn');
        const historyModal = document.getElementById('history-modal');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const historyList = document.getElementById('history-list');
        const clearHistoryBtn = document.getElementById('clear-history-btn');

        // --- STATE MANAGEMENT ---
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let standardIPA = '';
        let audioContext;
        let analyser;
        let waveformAnimationId;
        let lastRecordingBlob = null;
        let soundDetected = false;
        let ipaLoadingInterval;
        let fetchIpaRequestID = 0;
        let analysisRequestID = 0;
        let progressInterval;
        let progressTextTimeoutIds = [];
        let currentIpaData = {};
        
        let isSingleWordMode = false;

        // --- CACHING ---
        const ipaCache = {
            get(key) { try { const i = localStorage.getItem(key); return i ? JSON.parse(i) : null; } catch (e) { return null; } },
            set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error("Cache write error:", e); } }
        };
        let modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
        let clearPronunciationAudio = null;


        const funFacts = [
            "'Ough' có thể được phát âm theo 10 cách khác nhau.",
            "Âm câm (silent letters) là di tích lịch sử từ các ngôn ngữ khác.",
            "'Pronunciation' (phát âm) trớ trêu lại là từ bị phát âm sai nhiều nhất.",
            "'Strengths' là từ dài nhất chỉ có một nguyên âm.",
            "'Rhythms' là từ dài nhất không có nguyên âm (a, e, i, o, u).",
            "'Bookkeeper' là từ duy nhất có ba cặp chữ cái lặp lại liên tiếp.",
            "Crutch Words (Từ đệm): Những từ như 'like', 'actually', 'basically', 'literally' thường được dùng làm từ đệm trong giao tiếp hàng ngày mà không thêm nhiều ý nghĩa.",
            "Câu 'Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.' là một câu đúng ngữ pháp, sử dụng ba nghĩa của từ 'buffalo' (trâu, thành phố Buffalo, và động từ 'doạ nạt').",
            "Âm 'gh' khó đoán: 'gh' có thể được phát âm là /f/ như trong 'enough', /g/ như trong 'ghost', hoặc câm như trong 'though'.",
            "Từ 'set' giữ kỷ lục: Từ 'set' có nhiều định nghĩa nhất trong tiếng Anh, với hơn 430 nghĩa khác nhau trong Từ điển Oxford.",
            "'Queueing' là từ duy nhất có năm nguyên âm đi liền nhau.",
            "'I am' là câu hoàn chỉnh ngắn nhất trong tiếng Anh.",
            "Câu 'The quick brown fox jumps over the lazy dog' chứa tất cả 26 chữ cái trong bảng chữ cái.",
            "Không có từ nào trong tiếng Anh vần với 'month', 'orange', 'silver' hay 'purple'.",
            "'Uncopyrightable' là từ dài nhất không lặp lại bất kỳ chữ cái nào.",
            "Từ dài nhất trong từ điển là 'pneumonoultramicroscopicsilicovolcanoconiosis' (một loại bệnh phổi).",
            "Shakespeare đã sáng tạo ra hơn 1,700 từ cho tiếng Anh, ví dụ như 'eyeball', 'swagger', 'bedazzled'.",
            "Từ 'lol' (laughing out loud) đã được thêm vào từ điển Oxford vào năm 2011.",
            "'SWIMS' khi lộn ngược lại vẫn là 'SWIMS'.",
            "'Stewardesses' là từ dài nhất có thể gõ chỉ bằng tay trái trên bàn phím QWERTY.",
            "Từ 'dreamt' là từ duy nhất kết thúc bằng '-mt'.",
            "Chữ cái được sử dụng nhiều nhất là 'e', và chữ cái bắt đầu nhiều từ nhất là 's'.",
        ];

        const practiceSentences = [
            "What are you doing?", "It's a piece of cake.", "I'll call you back later.",
            "How's it going?", "Can I have a bottle of water, please?", "It's a beautiful day, isn't it?",
            "I'm looking forward to it.", "Could you please repeat that?", "Where is the nearest station?",
            "comfortable", "clothes", "Wednesday", "recipe", "stomach", "vehicle", "island", "dessert", "help", "vegetable", "library", "choir", "leave", "live", "seat", "sit", "sheep", "ship", "food", "foot", "bed", "bad", "think", "this", "mother", "weather", "economic", "recommend", "chocolate", "wife", "wine", "life", "like", "fine", "five", "file", "women", "pizza", "purpose", "colleague",
        ];

        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        const TEXT_API_URL = `/api/proxy`;
        const TTS_API_URL = `/api/proxy`;

        function showMessage(message, type = 'info') {
            const typeBorders = {
                'info': 'border-accent-primary/30',
                'success': 'border-accent-success/30',
                'warning': 'border-accent-warning/30',
                'error': 'border-accent-danger/30'
            };
            messageBox.className = `fixed top-5 right-5 p-4 rounded-xl text-sm z-50 shadow-lg glass-card fade-in ${typeBorders[type]}`;
            messageBox.style.color = `var(--msg-color-${type})`;
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            setTimeout(() => {
                messageBox.classList.add('hidden');
                messageBox.style.color = ''; // Reset style after hiding
            }, 5000);
        }

        function handleApiError(error) {
            console.error("API Error:", error);
            if (error.message && (error.message.includes('429') || error.message.toLowerCase().includes('quota'))) {
                showMessage('Hệ thống đang bận. Bạn vui lòng thử lại sau nhé.', 'error');
            } else {
                showMessage(`Đã xảy ra lỗi kết nối: ${error.message}`, 'error');
            }
        }

        function setButtonLoading(button, loader, isLoading) {
            button.disabled = isLoading;
            if (loader) {
                if(isLoading) {
                    button.classList.add('hidden');
                    loader.classList.remove('hidden');
                    loader.classList.add('flex');
                } else {
                    button.classList.remove('hidden');
                    loader.classList.add('hidden');
                    loader.classList.remove('flex');
                }
            } else {
                const textEl = button.querySelector('.text');
                const iconEl = button.querySelector('.icon');
                const spinnerEl = button.querySelector('.btn-spinner');
                if (isLoading) {
                    if (textEl) textEl.style.visibility = 'hidden';
                    if (iconEl) iconEl.style.visibility = 'hidden';
                    if (spinnerEl) spinnerEl.classList.remove('hidden');
                } else {
                    if (textEl) textEl.style.visibility = 'visible';
                    if (iconEl) iconEl.style.visibility = 'visible';
                    if (spinnerEl) spinnerEl.classList.add('hidden');
                }
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1, bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithBackoff(url, options, maxRetries = 4) {
             let delay = 1000;
             for (let i = 0; i < maxRetries; i++) {
                 try {
                     const response = await fetch(url, options);
                     if (response.status === 429 || response.status >= 500) {
                         if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after multiple retries.`);
                         await new Promise(resolve => setTimeout(resolve, delay));
                         delay *= 2; 
                         continue; 
                     }
                     if (!response.ok) {
                         const errorBody = await response.json().catch(() => ({}));
                         throw new Error(`API Error: ${response.status}. ${errorBody.error?.message || 'An unknown error occurred.'}`);
                     }
                     return await response.json();
                 } catch (error) {
                     if (i === maxRetries - 1) throw error;
                     await new Promise(resolve => setTimeout(resolve, delay));
                     delay *= 2;
                 }
             }
         }

        function startIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
            const symbols = ['ə', 'ʃ', 't', 'k', 'æ', 'iː', 'θ', 'ð', 'ŋ'];
            let i = 0;
            ipaLoadingInterval = setInterval(() => {
                const seq = Array(5).fill(0).map((_, j) => symbols[(i + j) % symbols.length]).join(' ');
                simpleIpaText.textContent = `/ ${seq} /`;
                if (!isSingleWordMode) {
                    detailedIpaText.textContent = `[ ${seq} ]`;
                    thoughtGroupDisplay.textContent = `...`;
                }
                i = (i + 1) % symbols.length;
            }, 100);
        }

        function stopIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
        }

        function displayIpaData(data) {
            currentIpaData = data;
            standardIPA = data.detailed || data.simple; // Use a fallback
            simpleIpaText.textContent = data.simple;

            isSingleWordMode = !textInput.value.trim().includes(' ');
            
            // Toggle UI based on analysis mode
            if (isSingleWordMode) {
                detailedIpaContainer.classList.add('hidden');
                syllableAnalysisContent.classList.remove('hidden');
                intonationAnalysisContent.classList.add('hidden');
                connectedSpeechContainer.classList.add('hidden');
            } else {
                detailedIpaContainer.classList.remove('hidden');
                syllableAnalysisContent.classList.add('hidden');
                intonationAnalysisContent.classList.remove('hidden');
                connectedSpeechContainer.classList.remove('hidden');
            }

            if (!isSingleWordMode) {
                detailedIpaText.textContent = data.detailed;
                displayThoughtGroups(data.thought_groups?.groups, data.thought_groups?.explanation);
            }
            controlsSection.classList.remove('hidden');
        }
        
        async function prefetchModelPronunciation(text, accent) {
            if (modelPronunciationData.text === text && modelPronunciationData.accent === accent && modelPronunciationData.audio) return;
            modelPronunciationData = { text, accent, audio: null, pitchContour: [], stressedWords: [] }; // Reset
        
            try {
                const textWithPauses = currentIpaData.thought_groups?.groups.join(" | ") || text;
                const promptTTS = `As a native ${accent} speaker, read the following text naturally, as you would in a conversation. The pipe symbol "|" indicates a very brief pause, like a comma. Maintain a smooth and connected flow. Text: ${textWithPauses}`;
                
                const [ttsData, analysisData] = await Promise.all([
                    fetchWithBackoff(TTS_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: promptTTS }] }],
                            generationConfig: { responseModalities: ["AUDIO"] },
                            model: TTS_MODEL
                        })
                    }),
                    fetchWithBackoff(TEXT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: `Analyze the sentence "${text}". Provide a JSON object with 'pitch_contour' (an array of 40-50 normalized pitch points from 0.0 to 1.0, representing the melody of the sentence) and 'stressed_words' (an array of objects with 'word' and 'time_stamp_normalized' from 0.0 to 1.0 indicating when the stress occurs).` }] }],
                            generationConfig: { responseMimeType: "application/json" }
                        })
                    })
                ]);
        
                const audioPart = ttsData?.candidates?.[0]?.content?.parts?.[0];
                if (!audioPart?.inlineData) throw new Error("TTS audio data not received.");
                modelPronunciationData.audio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
        
                const analysisJson = JSON.parse(analysisData.candidates[0].content.parts[0].text);
                modelPronunciationData.pitchContour = analysisJson.pitch_contour || [];
                modelPronunciationData.stressedWords = analysisJson.stressed_words || [];
        
                console.log("Model pronunciation data prefetched successfully.");
        
            } catch (error) {
                console.error("Model pronunciation prefetch failed:", error);
                modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
            }
        }

        async function fetchAndDisplayIPA() {
            fetchIpaRequestID++;
            const currentRequestID = fetchIpaRequestID;

            const text = textInput.value.trim();
            if (!text) {
                resetAll();
                return false;
            }
            
            isSingleWordMode = !text.includes(' ');
            
            const accent = accentSelect.value;
            const cacheKey = `ipa_${text}_${accent}`;
            const cachedData = ipaCache.get(cacheKey);

            if (cachedData) {
                displayIpaData(cachedData);
                setButtonLoading(listenNaturalBtn, listenNaturalLoader, true);
                setButtonLoading(listenClearBtn, listenClearLoader, true);
                const prefetchTask = isSingleWordMode 
                    ? prefetchClearPronunciation(text, accent) 
                    : prefetchModelPronunciation(text, accent);
                prefetchTask.finally(() => {
                    if (currentRequestID === fetchIpaRequestID) {
                        setButtonLoading(listenNaturalBtn, listenNaturalLoader, false);
                        setButtonLoading(listenClearBtn, listenClearLoader, false);
                    }
                });
                return true;
            }
            
            let prompt;
            if (isSingleWordMode) {
                prompt = `Provide a JSON object for the word "${text}" in ${accent}. The JSON must contain:
                1. 'simple': The standard IPA transcription.
                2. 'syllable_structure': An object with 'syllables' (an array of strings representing each syllable) and 'stressed_syllable_index' (the 0-based index of the stressed syllable).
                Respond with ONLY the JSON object.`;
            } else {
                prompt = `For the phrase "${text}" in ${accent}, provide a single JSON object with:
                1. 'simple': A standard, citation-form IPA transcription.
                2. 'detailed': A natural, connected speech transcription. Use the liaison symbol (‿) correctly ONLY where linking occurs within a thought group.
                3. 'thought_groups': An object with 'groups' (an array of strings for natural thought groups) and 'explanation' (a clear Vietnamese explanation for the grouping).
                Respond with ONLY the JSON object.`;
            }
            
            setButtonLoading(transcribeBtn, null, true);
            controlsSection.classList.add('hidden');
            startIpaLoadingAnimation();
            
            try {
                const payload = { 
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };

                const response = await fetchWithBackoff(TEXT_API_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, 
                    body: JSON.stringify(payload) 
                });

                if (currentRequestID !== fetchIpaRequestID) return false;

                let resultJson = JSON.parse(response.candidates[0].content.parts[0].text);
                ipaCache.set(cacheKey, resultJson);
                displayIpaData(resultJson);
                
                setButtonLoading(listenNaturalBtn, listenNaturalLoader, true);
                setButtonLoading(listenClearBtn, listenClearLoader, true);
                const prefetchTask = isSingleWordMode 
                    ? prefetchClearPronunciation(text, accent) 
                    : prefetchModelPronunciation(text, accent);
                prefetchTask.finally(() => {
                    if (currentRequestID === fetchIpaRequestID) {
                        setButtonLoading(listenNaturalBtn, listenNaturalLoader, false);
                        setButtonLoading(listenClearBtn, listenClearLoader, false);
                    }
                });
                
                return true;
            } catch (error) {
                if (currentRequestID === fetchIpaRequestID) {
                    handleApiError(error);
                    resetAll();
                }
                return false;
            } finally {
                if (currentRequestID === fetchIpaRequestID) {
                    stopIpaLoadingAnimation();
                    setButtonLoading(transcribeBtn, null, false);
                }
            }
        }

        function displayThoughtGroups(groups, explanation) {
            thoughtGroupDisplay.innerHTML = '';
            thoughtGroupTooltip.textContent = explanation || '';
            
            if (groups && groups.length > 0 && explanation) {
                thoughtGroupInfo.classList.remove('hidden');
                groups.forEach((group, index) => {
                    const groupSpan = document.createElement('span');
                    groupSpan.textContent = group;
                    groupSpan.className = `thought-group thought-group-${index % 4}`;
                    thoughtGroupDisplay.appendChild(groupSpan);
                });
            } else {
                thoughtGroupInfo.classList.add('hidden');
            }
        }

        async function prefetchClearPronunciation(text, accent) {
            if (clearPronunciationAudio) return;
            try {
                const prompt = `Say very clearly in ${accent}: ${text}`;
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseModalities: ["AUDIO"] },
                    model: TTS_MODEL
                };
                const data = await fetchWithBackoff(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                    body: JSON.stringify(payload)
                });
                const audioPart = data?.candidates?.[0]?.content?.parts?.[0];
                if (audioPart?.inlineData) {
                    clearPronunciationAudio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
                    console.log("Clear pronunciation audio prefetched.");
                } else {
                    throw new Error("Invalid audio data for clear voice.");
                }
            } catch (error) {
                console.error("Failed to prefetch clear pronunciation:", error);
            }
        }

        async function handleListen(type) {
            const text = textInput.value.trim();
            const accent = accentSelect.value;
            if (!text) return;

            const button = type === 'natural' ? listenNaturalBtn : listenClearBtn;
            const loader = type === 'natural' ? listenNaturalLoader : listenClearLoader;
            
            if (button.disabled) {
                showMessage('Giọng mẫu đang được tải, bạn vui lòng chờ một lát nhé.', 'info');
                return;
            }
            
            setButtonLoading(button, loader, true);

            try {
                if (type === 'natural' && !isSingleWordMode) {
                    await prefetchModelPronunciation(text, accent);
                    if (modelPronunciationData.audio) {
                        modelPronunciationData.audio.currentTime = 0;
                        await modelPronunciationData.audio.play();
                    } else {
                        showMessage("Không thể tạo giọng đọc mẫu, vui lòng thử lại.", 'error');
                    }
                } else {
                    await prefetchClearPronunciation(text, accent);
                    if(clearPronunciationAudio) {
                        clearPronunciationAudio.currentTime = 0;
                        await clearPronunciationAudio.play();
                    } else {
                        showMessage("Không thể tạo giọng đọc mẫu, vui lòng thử lại.", 'error');
                    }
                }
            } catch (error) {
                handleApiError(error);
            } finally {
                setButtonLoading(button, loader, false);
            }
        }
        
        async function createAudioFromBase64(base64Data, mimeType) {
            const sampleRate = mimeType.match(/rate=(\d+)/) ? parseInt(mimeType.match(/rate=(\d+)/)[1], 10) : 24000;
            const pcmData = base64ToArrayBuffer(base64Data);
            const pcm16 = new Int16Array(pcmData);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            return new Audio(audioUrl);
        }

        function startProgressSimulation() {
            let width = 0;
            progressBarInner.style.width = '0%';
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                width = Math.min(width + Math.random() * 2, 95);
                progressBarInner.style.width = width + '%';
            }, 100);
        }

        function stopProgressSimulation() {
            clearInterval(progressInterval);
            progressBarInner.style.width = '100%';
        }

        function startProgressTextAnimation() {
            const steps = [
                { text: "Okie, PrAI đã nhận được bản ghi âm của bạn...", duration: 1500 },
                { text: "Đang phiên âm giọng nói của bạn!", duration: 2500 },
                { text: "So sánh từng âm một với giọng chuẩn...", duration: 3000 },
                { text: "Xong rồi! Cùng xem kết quả tuyệt vời của bạn nhé!", duration: 1000 }
            ];
            let cumulativeDelay = 0;
            stopProgressTextAnimation();
            steps.forEach(step => {
                const id = setTimeout(() => { progressText.textContent = step.text; }, cumulativeDelay);
                progressTextTimeoutIds.push(id);
                cumulativeDelay += step.duration;
            });
        }
        
        function stopProgressTextAnimation() {
            progressTextTimeoutIds.forEach(clearTimeout);
            progressTextTimeoutIds = [];
        }


        async function analyzeAudio(audioBlob) {
            analysisRequestID++;
            const currentAnalysisID = analysisRequestID;

            if (!audioBlob) return;
            lastRecordingBlob = audioBlob;
            listenAgainBtn.disabled = false;

            if (!standardIPA) {
                showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                return;
            }
            
            if (!isSingleWordMode) {
                if (modelPronunciationData.text !== textInput.value.trim() || !modelPronunciationData.pitchContour?.length) {
                    await prefetchModelPronunciation(textInput.value.trim(), accentSelect.value);
                    if (!modelPronunciationData.pitchContour?.length) {
                       showMessage('Chưa có dữ liệu ngữ điệu mẫu, vui lòng thử lại.', 'error');
                       return;
                    }
                }
            }

            loader.classList.remove('hidden');
            startProgressTextAnimation();
            startProgressSimulation();
            funFactEl.textContent = `💡 ${funFacts[Math.floor(Math.random() * funFacts.length)]}`;
            funFactEl.classList.remove('hidden');
            
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = async () => {
                if (currentAnalysisID !== analysisRequestID) return;

                const base64Audio = reader.result.split(',')[1];
                
// RUBRIC MỚI CHO TỪ ĐƠN (KHẮT KHE & CHI TIẾT)
const promptForSingleWord = {
    "role": "Bạn là một chuyên gia ngữ âm học (phonetician) tỉ mỉ và khách quan. Nhiệm vụ của bạn là phân tích phát âm của một từ đơn một cách chính xác tuyệt đối dựa trên rubric khoa học được cung cấp.",
    "rubric": {
        "scoring_model": "Điểm tổng 100 được phân bổ như sau:",
        "vowels": "40 điểm - Nguyên âm phải đúng về chất (quality), độ dài (length) và độ căng (tension). Sai nguyên âm chính là lỗi nghiêm trọng nhất.",
        "consonants": "40 điểm - Phụ âm phải rõ ràng, đúng vị trí cấu âm. Đặc biệt chú trọng vào các âm cuối (final sounds) và các cụm phụ âm (consonant clusters) mà người Việt hay bỏ sót.",
        "stress": "20 điểm - Trọng âm phải được đặt ĐÚNG âm tiết. Nếu sai trọng âm, điểm tối đa cho mục này là 0.",
        "common_vietnamese_errors": "Hãy đặc biệt chú ý đến các lỗi thường gặp của người Việt: không bật âm cuối (/t/, /d/, /k/, /g/, /s/, /z/), nhầm lẫn giữa /ɪ/ và /iː/, /æ/ và /e/, /θ/ và /s/, /ð/ và /z/, /ʃ/ và /s/."
    },
    "context": {
        "text_to_pronounce": textInput.value.trim(),
        "target_accent": accentSelect.value === 'American English' ? 'AmE' : 'BrE',
        "standard_ipa": standardIPA,
        "standard_syllable_structure": currentIpaData.syllable_structure
    },
    "output_format_instruction": {
        "format": "JSON",
        "schema": {
            "word_match": "boolean",
            "transcribed_word": "string",
            "overall_score": "number (tính toán nghiêm ngặt dựa trên rubric)",
            "user_ipa": "string",
            "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string (Vietnamese, ngắn gọn, đi thẳng vào vấn đề kỹ thuật)\" } ]",
            "syllable_analysis": "{ \"feedback\": \"string (Nhận xét về trọng âm, ví dụ: 'Bạn đã nhấn đúng trọng âm vào âm tiết thứ hai. Rất tốt!')\" }"
        }
    }
};

// RUBRIC MỚI CHO CÂU (TINH TẾ & TỔNG THỂ)
const promptForSentence = {
    "role": "Bạn là PrAI, một huấn luyện viên phát âm AI tận tâm và thấu hiểu. Mục tiêu của bạn là giúp người dùng nói tiếng Anh tự nhiên và dễ hiểu hơn, không chỉ là đúng từng âm một.",
    "matching_leniency_rule": "QUAN TRỌNG: Khi xác định `sentence_match`, hãy linh hoạt. Miễn là người dùng nói đúng các từ khóa chính (key content words) theo đúng thứ tự, hãy xem là `true`. Bỏ qua các từ chức năng nhỏ bị lướt qua hoặc các ngập ngừng nhỏ. Mục tiêu là phân tích phát âm câu đã nói, không phải là một bài kiểm tra phiên âm hoàn hảo.",
    "rubric": {
        "scoring_model": "Chấm điểm tổng thể dựa trên sự dễ hiểu và tự nhiên (overall intelligibility and naturalness).",
        "phonetic_accuracy": "40 điểm - Độ chính xác của các âm vị quan trọng (key sounds) ảnh hưởng đến nghĩa của câu.",
        "prosody": "60 điểm - Bao gồm các yếu tố sau:",
        "intonation_and_rhythm": "30 điểm - Ngữ điệu có lên xuống phù hợp với loại câu (hỏi, kể) và nhịp điệu có tự nhiên không?",
        "sentence_stress": "20 điểm - Có nhấn mạnh vào đúng các từ chứa nội dung (content words) không?",
        "connected_speech": "10 điểm - Có các hiện tượng nối âm, lướt âm tự nhiên không?",
        "error_consolidation_rule": "QUAN TRỌN: Nếu người dùng mắc CÙNG MỘT LOẠI LỖI PHÁT ÂM (ví dụ: luôn bỏ âm /s/ cuối) nhiều lần trong câu, chỉ trừ điểm nặng ở lần đầu tiên. Các lần sau vẫn ghi nhận là 'incorrect' trong `phoneme_analysis` nhưng chỉ trừ điểm rất nhẹ hoặc không trừ thêm vào điểm tổng, thay vào đó, hãy đưa ra một nhận xét tổng quan trong phần feedback của `intonation_analysis` (ví dụ: 'PrAI nhận thấy bạn có xu hướng bỏ qua âm /s/ ở cuối các từ, hãy chú ý hơn nhé!')."
    },
    "context": {
        "text_to_pronounce": textInput.value.trim(),
        "target_accent": accentSelect.value === 'American English' ? 'AmE' : 'BrE',
        "standard_ipa": standardIPA,
        "model_pitch_contour": modelPronunciationData.pitchContour,
    },
    "output_format_instruction": {
        "format": "JSON",
        // Schema giữ nguyên như cũ để không làm hỏng cấu trúc hiển thị
        "schema": {
            "sentence_match": "boolean",
            "overall_score": "number | null",
            "user_ipa": "string | null",
            "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string (Vietnamese, friendly, constructive, using 'bạn')\" } ]",
            "intonation_analysis": {
                "feedback": "string (Nhận xét tổng quan về ngữ điệu, nhịp điệu VÀ nhắc lại các lỗi lặp lại theo `error_consolidation_rule`)",
                "user_pitch_contour": "[number]"
            },
            "connected_speech_analysis": "[{ \"type\": \"string\", \"rule\": \"string\", \"location\": \"string\", \"expected_pronunciation\": \"string\", \"user_pronunciation\": \"string\", \"feedback\": \"string (Vietnamese, friendly, constructive, using 'bạn')\" }] | null",
            "practice_suggestions": "{ \"youglish_us\": \"string\", \"youglish_uk\": \"string\" } | null"
        }
    }
};

                const payload = {
                    contents: [ { role: "user", parts: [ { text: JSON.stringify(prompt) }, { inlineData: { mimeType: "audio/webm", data: base64Audio } } ] } ],
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const data = await fetchWithBackoff(TEXT_API_URL, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, 
                        body: JSON.stringify(payload) 
                    });
                    
                    if (currentAnalysisID !== analysisRequestID) return;
                    const resultJson = JSON.parse(data.candidates[0].content.parts[0].text);
                    displayResults(resultJson);
                } catch (error) {
                    if (currentAnalysisID === analysisRequestID) handleApiError(error);
                } finally {
                    if (currentAnalysisID === analysisRequestID) {
                        stopProgressSimulation();
                        stopProgressTextAnimation();
                        setTimeout(() => {
                            loader.classList.add('hidden');
                            funFactEl.classList.add('hidden');
                        }, 500);
                    }
                }
            };
        }
        
        function displayResults(data) {
            mismatchNotificationBar.classList.add('hidden'); // Reset notification bar
            if (data.overall_score === null || data.overall_score === undefined) {
                showMessage("PrAI không nhận diện được giọng nói. Vui lòng thử lại và nói to, rõ hơn.", "error");
                return;
            }
        
            saveToHistory(textInput.value.trim(), data.overall_score);
            analysisResults.classList.remove('hidden');
        
            const scoreContainer = document.querySelector('.score-container');
            animateValue(overallScore, 0, data.overall_score, 1000);
            scoreContainer.className = 'score-container';
            if (data.overall_score > 85) scoreContainer.classList.add('score-high');
            else if (data.overall_score > 70) scoreContainer.classList.add('score-medium');
            else scoreContainer.classList.add('score-low');
        
            phonemeAnalysis.innerHTML = '';
            data.phoneme_analysis?.forEach(p => {
                const phonemeEl = document.createElement('div');
                phonemeEl.textContent = p.phoneme;
                phonemeEl.className = `phoneme has-tooltip status-${p.status}`;
                if (p.feedback) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = p.feedback;
                    phonemeEl.appendChild(tooltip);
                }
                phonemeAnalysis.appendChild(phonemeEl);
            });

            // Display message if no match found for clarity
            if ((isSingleWordMode && data.word_match === false) || (!isSingleWordMode && data.sentence_match === false)) {
                let mismatchMessage = isSingleWordMode 
                    ? `Hmm, hình như bạn đã phát âm từ "${data.transcribed_word}" thay vì "${textInput.value.trim()}". Dưới đây là kết quả phân tích dựa trên phát âm của bạn nhé.`
                    : `Câu bạn nói có vẻ chưa khớp với câu mẫu. Dưới đây là kết quả phân tích dựa trên những gì PrAI nghe được.`;
                mismatchNotificationBar.textContent = mismatchMessage;
                mismatchNotificationBar.classList.remove('hidden');
            }
        
            if (isSingleWordMode) {
                prosodyAnalysisTitle.textContent = 'Phân tích Âm tiết & Trọng âm';
                renderSyllableChart(currentIpaData.syllable_structure);
                syllableAnalysisFeedback.textContent = data.syllable_analysis?.feedback || '';
            } else {
                prosodyAnalysisTitle.textContent = 'Phân tích Ngữ điệu';
                intonationAnalysisFeedback.textContent = data.intonation_analysis?.feedback || '';
                
                if (modelPronunciationData.pitchContour?.length > 0 && data.intonation_analysis?.user_pitch_contour?.length > 0) {
                    intonationAnalysisContent.classList.remove('hidden');
                    renderIntonationChart(
                        intonationChart,
                        modelPronunciationData.pitchContour,
                        data.intonation_analysis.user_pitch_contour,
                        modelPronunciationData.stressedWords
                    );
                } else {
                     intonationAnalysisContent.classList.add('hidden');
                     // Add a message if the chart cannot be drawn
                     if (data.intonation_analysis?.feedback) {
                        intonationAnalysisFeedback.textContent += "\n(Không đủ dữ liệu để vẽ biểu đồ ngữ điệu.)";
                     } else {
                        intonationAnalysisFeedback.textContent = "Không đủ dữ liệu để phân tích và vẽ biểu đồ ngữ điệu của bạn.";
                     }
                }
                
                connectedSpeechAnalysis.innerHTML = '';
                if (data.connected_speech_analysis?.length > 0) {
                    connectedSpeechContainer.classList.remove('hidden');
                    data.connected_speech_analysis.forEach(item => {
                        const itemEl = document.createElement('div');
                        
                        const typeStr = item.type.toLowerCase();
                        let typeClass = `type-${typeStr.replace(/\s*&\s*|\s+/g, '-')}`;

                        itemEl.className = `connected-speech-item ${typeClass}`;
                        itemEl.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div><p class="cs-title">${item.rule}</p><p class="cs-details mt-1">Vị trí: <span class="cs-location">${item.location}</span></p></div>
                                <span class="text-xs font-semibold uppercase px-2 py-1 rounded-full opacity-70">${item.type}</span>
                            </div>
                            <div class="cs-details mt-2">
                                <p>Phát âm mong đợi: <span class="ipa-text text-accent-success">${item.expected_pronunciation}</span></p>
                                <p>Phát âm của bạn: <span class="ipa-text text-accent-warning">${item.user_pronunciation}</span></p>
                            </div>
                            <p class="cs-feedback text-sm">${item.feedback}</p>`;
                        connectedSpeechAnalysis.appendChild(itemEl);
                    });
                } else {
                    connectedSpeechContainer.classList.add('hidden');
                }
            }
        
            if (data.practice_suggestions) {
                suggestionLinks.innerHTML = `<a href="${data.practice_suggestions.youglish_us}" target="_blank" class="btn btn-primary flex-1">Giọng Mỹ (YouGlish)</a><a href="${data.practice_suggestions.youglish_uk}" target="_blank" class="btn btn-primary flex-1">Giọng Anh (YouGlish)</a>`;
                practiceSuggestions.classList.remove('hidden');
            } else {
                practiceSuggestions.classList.add('hidden');
            }
        }
        
        function renderSyllableChart(structure) {
            syllableChartContainer.innerHTML = '';
            if (!structure || !structure.syllables) return;
            
            structure.syllables.forEach((syllable, index) => {
                const syllableEl = document.createElement('div');
                syllableEl.className = 'syllable';
                syllableEl.textContent = syllable;
                if (index === structure.stressed_syllable_index) {
                    syllableEl.classList.add('stressed');
                }
                syllableChartContainer.appendChild(syllableEl);
            });
        }

        function resetAnalysisOnly() {
            analysisResults.classList.add('hidden');
            practiceSuggestions.classList.add('hidden');
            mismatchNotificationBar.classList.add('hidden');
        }

        function resetAll() {
            standardIPA = '';
            controlsSection.classList.add('hidden');
            resetAnalysisOnly();
            
            const text = textInput.value.trim();
            const accent = accentSelect.value;
            if (modelPronunciationData.text !== text || modelPronunciationData.accent !== accent) {
                 modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
            }
            clearPronunciationAudio = null;
            currentIpaData = {};
            displayThoughtGroups([], '');
        }

        async function handleRecord() {
            if (isRecording) {
                mediaRecorder.stop();
                return;
            }
            
            analysisRequestID++;

            if (!textInput.value.trim()) {
                showMessage('Vui lòng nhập từ để ghi âm và phân tích.', 'warning');
                return;
            }
            
            resetAnalysisOnly(); 
            listenAgainBtn.disabled = true;
            lastRecordingBlob = null;
            
            try {
                if (!standardIPA) {
                    const ipaReady = await fetchAndDisplayIPA();
                    if (!ipaReady) {
                        showMessage('Chưa có phiên âm chuẩn, không thể bắt đầu ghi âm.', 'warning');
                        return;
                    }
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true;
                soundDetected = false;
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = () => {
                    isRecording = false;
                    stopWaveform();
                    stream.getTracks().forEach(track => track.stop());
                    
                    const recordBtnText = recordBtn.querySelector('.text');
                    recordBtnText.textContent = '';
                    recordBtnText.classList.add('hidden');
                    recordBtn.querySelector('.icon').classList.remove('hidden');
                    recordBtn.classList.remove('is-recording');

                    if (soundDetected) {
                        analyzeAudio(new Blob(audioChunks, { type: 'audio/webm' }));
                    } else {
                        showMessage("PrAI không phát hiện thấy âm thanh. Vui lòng thử ghi âm lại nhé.", "error");
                    }
                };
                mediaRecorder.start();
                startWaveform(stream);
                const recordBtnText = recordBtn.querySelector('.text');
                recordBtnText.textContent = 'Dừng';
                recordBtnText.classList.remove('hidden');
                recordBtn.querySelector('.icon').classList.add('hidden');
                recordBtn.classList.add('is-recording');
            } catch (error) {
                console.error("Error accessing microphone:", error);
                showMessage('Không thể truy cập micro. Vui lòng cấp quyền và thử lại.', 'error');
            }
        }

        function handleListenAgain() {
            if (lastRecordingBlob) {
                const audioUrl = URL.createObjectURL(lastRecordingBlob);
                replayAudio.src = audioUrl;
                replayAudio.play();
            }
        }

        function startWaveform(stream) {
            uploadBtn.style.display = 'none';
            listenAgainBtn.style.display = 'none';
            waveformContainer.classList.remove('hidden');
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const computedStyle = getComputedStyle(document.documentElement);
            const accentPrimaryColor = computedStyle.getPropertyValue('--accent-primary').trim();
            const accentSuccessColor = computedStyle.getPropertyValue('--accent-success').trim();

            const canvas = waveformEl;
            const canvasCtx = canvas.getContext('2d');

            function draw() {
                waveformAnimationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                const averageVolume = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                if (averageVolume > 15) soundDetected = true;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 1.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2.5;
                    const gradient = canvasCtx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                    gradient.addColorStop(0, accentPrimaryColor);
                    gradient.addColorStop(1, accentSuccessColor);
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function stopWaveform() {
            if (waveformAnimationId) cancelAnimationFrame(waveformAnimationId);
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            uploadBtn.style.display = 'inline-flex';
            listenAgainBtn.style.display = 'inline-flex';
            waveformContainer.classList.add('hidden');
        }

        function getHistory() { return JSON.parse(localStorage.getItem('prai-history') || '[]'); }

        function saveToHistory(text, score) {
            if (!text) return;
            let history = getHistory();
            const newEntry = { text, score, date: new Date().toISOString() };
            history = history.filter(item => item.text !== text);
            history.unshift(newEntry);
            if (history.length > 20) history = history.slice(0, 20);
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }

        function loadHistory() {
            const history = getHistory();
            historyList.innerHTML = '';
            if (history.length === 0) {
                historyList.innerHTML = `<p class="text-text-secondary text-center italic">Chưa có lịch sử luyện tập.</p>`;
                clearHistoryBtn.classList.add('hidden');
                return;
            }
            clearHistoryBtn.classList.remove('hidden');
            history.forEach(item => {
                const scoreColor = item.score > 85 ? 'bg-green-500/20 text-green-600 dark:text-green-400' : item.score > 70 ? 'bg-yellow-500/20 text-yellow-600 dark:text-yellow-400' : 'bg-red-500/20 text-red-600 dark:text-red-400';
                const itemEl = document.createElement('div');
                itemEl.className = 'history-item flex justify-between items-center p-2 rounded-md';
                itemEl.innerHTML = `
                    <div class="flex-grow truncate pr-4" data-action="select"><p class="truncate history-item-text">${item.text}</p></div>
                    <div class="flex items-center gap-3 flex-shrink-0">
                        <div class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-xl ${scoreColor}">${item.score}</div>
                        <button class="btn btn-secondary btn-icon !w-8 !h-8 text-accent-danger/70 hover:!bg-accent-danger/20" data-action="delete"><svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                    </div>`;
                itemEl.dataset.text = item.text;
                historyList.appendChild(itemEl);
            });
        }
        
        function deleteHistoryItem(text) {
            let history = getHistory().filter(item => item.text !== text);
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }

        function clearHistory() {
            localStorage.removeItem('prai-history');
            loadHistory();
        }
        
        function handleHistoryClick(event) {
            const target = event.target.closest('[data-action]');
            if (!target) return;
            const action = target.dataset.action;
            const text = target.closest('.history-item').dataset.text;
            if (action === 'select') {
                textInput.value = text;
                charCounter.textContent = `${text.length} / 150`;
                historyModal.classList.remove('is-visible');
                resetAll();
                fetchAndDisplayIPA();
            } else if (action === 'delete') {
                deleteHistoryItem(text);
            }
        }
        
        function animateValue(obj, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerHTML = Math.floor(progress * (end - start) + start);
                if (progress < 1) window.requestAnimationFrame(step);
            };
            window.requestAnimationFrame(step);
        }
        
        

        function initApp() {
            textInput.addEventListener('input', () => {
                charCounter.textContent = `${textInput.value.length} / 150`;
                resetAll();
            });
            accentSelect.addEventListener('change', () => {
                if (textInput.value.trim()) {
                    resetAll();
                    fetchAndDisplayIPA();
                }
            });
            transcribeBtn.addEventListener('click', fetchAndDisplayIPA);
            listenNaturalBtn.addEventListener('click', () => handleListen('natural'));
            listenClearBtn.addEventListener('click', () => handleListen('clear'));
            recordBtn.addEventListener('click', handleRecord);
            listenAgainBtn.addEventListener('click', handleListenAgain);
            randomPracticeBtn.addEventListener('click', () => {
                const sentence = practiceSentences[Math.floor(Math.random() * practiceSentences.length)];
                textInput.value = sentence;
                charCounter.textContent = `${sentence.length} / 150`;
                resetAll();
                fetchAndDisplayIPA();
            });
            uploadBtn.addEventListener('click', () => audioUploadInput.click());
            historyBtn.addEventListener('click', () => { loadHistory(); historyModal.classList.add('is-visible'); });
            closeHistoryBtn.addEventListener('click', () => historyModal.classList.remove('is-visible'));
            historyModal.addEventListener('click', e => { if (e.target === historyModal) historyModal.classList.remove('is-visible'); });
            clearHistoryBtn.addEventListener('click', clearHistory);
            historyList.addEventListener('click', handleHistoryClick);

            audioUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file?.type.startsWith('audio/')) {
                    const checkAndAnalyze = async () => {
                        if (!textInput.value.trim()) {
                            showMessage('Vui lòng nhập văn bản tương ứng với file âm thanh.', 'warning');
                            return;
                        }
                        resetAnalysisOnly(); 
                        if (!standardIPA) await fetchAndDisplayIPA();
                        if (!standardIPA) {
                            showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                            return;
                        }
                        analyzeAudio(file);
                    };
                    checkAndAnalyze();
                } else if (file) {
                    showMessage('Vui lòng chọn một tệp âm thanh hợp lệ.', 'warning');
                }
                event.target.value = null;
            });

            textInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); fetchAndDisplayIPA(); } });
        }

        initApp();
    

/* === Intonation Chart v4 (Robust) =========================================
   - Uses ResizeObserver for robust rendering in dynamic containers.
   - Interpolates data to ensure smooth, comparable curves.
   - Safe against null, NaN, or empty data arrays.
   - Automatically redraws on resize or visibility changes.
   API: renderIntonationChart(svg, modelData, userData, stressedWords?)
=============================================================================*/
(function () {
  const roMap = new WeakMap();
  const lastArgs = new WeakMap();

  window.renderIntonationChart = function (svg, modelData, userData, stressedWords = []) {
    if (!svg) return;
    lastArgs.set(svg, { modelData, userData, stressedWords });

    if (!roMap.get(svg)) {
      const ro = new ResizeObserver(() => {
        const args = lastArgs.get(svg);
        if (args) requestAnimationFrame(() => draw(svg, args.modelData, args.userData, args.stressedWords));
      });
      ro.observe(svg);
      roMap.set(svg, ro);

      document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
          const args = lastArgs.get(svg);
          if (args) requestAnimationFrame(() => draw(svg, args.modelData, args.userData, args.stressedWords));
        }
      }, { passive: true });
    }

    requestAnimationFrame(() => draw(svg, modelData, userData, stressedWords));
  };

  function sanitize(arr) {
    if (!Array.isArray(arr)) return [];
    return arr.map(v => Number(v)).filter(v => Number.isFinite(v));
  }

  function resample(arr, N) {
    const src = sanitize(arr);
    if (src.length === 0) return [];
    if (src.length === 1) return Array(N).fill(src[0]);
    if (N <= 1) return [src[0]];
    
    const out = [];
    for (let i = 0; i < N; i++) {
      const t = (i * (src.length - 1)) / (N - 1);
      const i0 = Math.floor(t);
      const i1 = Math.min(src.length - 1, i0 + 1);
      const r = t - i0;
      out.push(src[i0] * (1 - r) + src[i1] * r);
    }
    return out;
  }

  function getDims(svg) {
    let w = svg.clientWidth || svg.getBoundingClientRect().width || parseFloat(svg.getAttribute('width')) || 0;
    let h = svg.clientHeight || svg.getBoundingClientRect().height || parseFloat(svg.getAttribute('height')) || 0;
    if (w < 10) w = 360; // Fallback width
    if (h < 10) h = 180; // Fallback height
    svg.setAttribute('width', w);
    svg.setAttribute('height', h);
    return { w, h };
  }

  function clamp01(x) { return Math.max(0, Math.min(1, Number(x) || 0)); }

  function draw(svg, modelData, userData, stressedWords = []) {
    const mRaw = sanitize(modelData);
    const uRaw = sanitize(userData);
    if (!mRaw.length || !uRaw.length) { svg.innerHTML = ''; return; }

    const N = Math.max(32, Math.min(256, Math.max(mRaw.length, uRaw.length)));
    const m = resample(mRaw, N);
    const u = resample(uRaw, N);

    const { w, h } = getDims(svg);
    if (w <= 0 || h <= 0) return; // Don't draw if invisible

    const padding = { top: 30, right: 10, bottom: 22, left: 10 };
    const innerW = Math.max(1, w - padding.left - padding.right);
    const innerH = Math.max(1, h - padding.top - padding.bottom);

    const all = m.concat(u);
    let yMin = Math.min(...all), yMax = Math.max(...all);
    if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) { svg.innerHTML = ''; return; }
    if (Math.abs(yMax - yMin) < 1e-6) { yMin -= 1; yMax += 1; }

    const sx = (i) => padding.left + (N > 1 ? (i / (N - 1)) * innerW : innerW / 2);
    const sy = (v) => padding.top + innerH - ((v - yMin) / (yMax - yMin)) * innerH;

    svg.innerHTML = ''; // Clear previous drawings

    const makeLine = (pts, { dashed = false, cssVar = '--accent-primary', width = 2 }) => {
      const el = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
      el.setAttribute('points', pts);
      el.setAttribute('fill', 'none');
      el.setAttribute('stroke', `var(${cssVar})`);
      el.setAttribute('stroke-width', String(width));
      el.setAttribute('stroke-linecap', 'round');
      el.setAttribute('stroke-linejoin', 'round');
      if (dashed) el.setAttribute('stroke-dasharray', '4 4');
      return el;
    };

    const gridY = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    for (let k = 0; k <= 4; k++) {
      const y = padding.top + (k / 4) * innerH;
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      g.setAttribute('x1', String(padding.left));
      g.setAttribute('x2', String(padding.left + innerW));
      g.setAttribute('y1', String(y));
      g.setAttribute('y2', String(y));
      g.setAttribute('stroke', 'var(--glass-border)');
      g.setAttribute('stroke-width', '1');
      g.setAttribute('opacity', '0.6');
      gridY.appendChild(g);
    }
    svg.appendChild(gridY);

    const mPts = m.map((v, i) => `${sx(i)},${sy(v)}`).join(' ');
    const uPts = u.map((v, i) => `${sx(i)},${sy(v)}`).join(' ');

    svg.appendChild(makeLine(mPts, { cssVar: '--accent-primary', width: 2 }));
    svg.appendChild(makeLine(uPts, { cssVar: '--accent-warning', dashed: true, width: 2.5 }));

    (stressedWords || []).forEach(item => {
      const t = clamp01(item?.time_stamp_normalized);
      const baseIdx = Math.round(t * (N - 1));
      const radius = 2;
      let peakIdx = baseIdx, peakVal = -Infinity;
      for (let di = -radius; di <= radius; di++) {
        const idx = Math.max(0, Math.min(N - 1, baseIdx + di));
        if (m[idx] > peakVal) { peakVal = m[idx]; peakIdx = idx; }
      }
      const x = sx(peakIdx), y = sy(peakVal) - 10;

      const bg = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      bg.setAttribute('x', x); bg.setAttribute('y', y);
      bg.setAttribute('text-anchor', 'middle');
      bg.setAttribute('font-size', '13');
      bg.setAttribute('font-weight', '600');
      bg.setAttribute('stroke', 'var(--glass-border)');
      bg.setAttribute('stroke-width', '5');
      bg.setAttribute('paint-order', 'stroke');
      bg.setAttribute('fill', 'transparent');
      bg.textContent = item?.word ?? '';
      svg.appendChild(bg);

      const fg = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      fg.setAttribute('x', x); fg.setAttribute('y', y);
      fg.setAttribute('text-anchor', 'middle');
      fg.setAttribute('font-size', '13');
      fg.setAttribute('font-weight', '600');
      fg.setAttribute('fill', 'var(--text-primary)');
      fg.textContent = item?.word ?? '';
      svg.appendChild(fg);
    });

    const legend = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const yLegend = h - 12;
    legend.innerHTML = `
      <rect x="${padding.left}" y="${yLegend - 3}" width="12" height="2" fill="var(--accent-primary)"></rect>
      <text x="${padding.left + 16}" y="${yLegend}" font-size="10" fill="var(--text-secondary)">Giọng mẫu</text>
      <rect x="${padding.left + 110}" y="${yLegend - 3}" width="12" height="2" stroke="var(--accent-warning)" fill="none" stroke-dasharray="4 4"></rect>
      <text x="${padding.left + 126}" y="${yLegend}" font-size="10" fill="var(--text-secondary)">Giọng của bạn</text>`;
    svg.appendChild(legend);
  }
})();

</script>
</body>
</html
