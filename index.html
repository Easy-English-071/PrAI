<!DOCTYPE html>
<html lang="vi" data-theme="light"> <!-- Default to light theme -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrAI - Luyện Phát Âm với AI</title>
    <!-- NEW FAVICON -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23007CF0;'/%3E%3Cstop offset='100%25' style='stop-color:%2300DFD8;'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3Ctext x='50' y='55' font-family='Exo 2, sans-serif' font-size='40' font-weight='700' fill='white' text-anchor='middle' dominant-baseline='middle'%3EPrAI%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans:wght@400;700&family=Exo+2:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- GLASSMORPHISM THEME V10 --- */
        :root {
            /* Default: Light Theme */
            --bg-color: #f8fafc; /* slate-50 */
            --bg-blob-1: #0ea5e9; /* sky-500 */
            --bg-blob-2: #14b8a6; /* teal-500 */
            --glass-bg: rgba(248, 250, 252, 0.6); /* slate-50 @ 60% */
            --glass-border: rgba(255, 255, 255, 0.7); /* Brighter border for glass edge effect */
            --text-primary: #0f172a; /* slate-900 */
            --text-secondary: #475569; /* slate-600 */
            --accent-primary: #007CF0;
            --accent-danger: #ef4444; /* red-500 */
            --accent-success: #22c55e; /* green-500 */
            --accent-warning: #f59e0b; /* amber-500 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0056b3;
            --btn-secondary-bg: rgba(241, 245, 249, 0.7); /* slate-100 @ 70% */
            --btn-secondary-hover-bg: rgba(226, 232, 240, 0.9); /* slate-200 @ 90% */
            --input-bg: rgba(255, 255, 255, 0.4);
            --input-focus-bg: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(100, 116, 139, 0.2); /* slate-400 */
            --highlight-correct: rgba(34, 197, 94, 0.1);
            --highlight-approximate: rgba(245, 158, 11, 0.1);
            --highlight-incorrect: rgba(239, 68, 68, 0.1);
            --radius-sm: 0.75rem;
            --radius-md: 1rem;
            --radius-lg: 1.5rem;
        }

        [data-theme="dark"] {
            --bg-color: #020617; /* slate-950 */
            --bg-blob-1: #0369a1; /* cyan-700 */
            --bg-blob-2: #0d9488; /* teal-600 */
            --glass-bg: rgba(30, 41, 59, 0.5); /* slate-800 @ 50% */
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #f1f5f9; /* slate-100 */
            --text-secondary: #94a3b8; /* slate-400 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0095ff;
            --btn-secondary-bg: rgba(51, 65, 85, 0.5); /* slate-700 @ 50% */
            --btn-secondary-hover-bg: rgba(51, 65, 85, 0.8);
            --input-bg: rgba(15, 23, 42, 0.5); /* slate-900 @ 50% */
            --input-focus-bg: rgba(15, 23, 42, 0.7);
            --shadow-color: rgba(0, 0, 0, 0.35);
            --highlight-correct: rgba(74, 222, 128, 0.15);
            --highlight-approximate: rgba(250, 204, 21, 0.15);
            --highlight-incorrect: rgba(248, 113, 113, 0.15);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
        }
        
        .background-container {
            width: 100%; height: 100%; position: fixed;
            top: 0; left: 0; z-index: -1; overflow: hidden;
        }
        .blob { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.4; }
        .blob-1 { width: 450px; height: 450px; background: var(--bg-blob-1); animation: move 20s infinite alternate; }
        .blob-2 { width: 350px; height: 350px; background: var(--bg-blob-2); animation: move 25s infinite alternate-reverse; animation-delay: -5s; }

        @keyframes move {
            from { transform: translate(-15vw, -15vh) scale(1) rotate(0deg); }
            to { transform: translate(65vw, 75vh) scale(1.2) rotate(180deg); }
        }

        .font-logo { font-family: 'Exo 2', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text, .phoneme, .ipa-text { font-family: 'Noto Sans', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text { word-break: break-word; }

        .glass-card {
            background-color: var(--glass-bg);
            backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
            box-shadow: 0 8px 32px 0 var(--shadow-color), inset 0 1px 0 0 var(--glass-border);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease-in-out;
        }

        .main-card { padding: clamp(1rem, 5vw, 2.5rem); }
        .card-layer { padding: 1.5rem; border-radius: var(--radius-md); }
        .card-layer-inset {
            background-color: var(--input-bg); padding: 1rem; border-radius: var(--radius-md);
            border: 1px solid var(--glass-border); box-shadow: inset 0 2px 4px var(--shadow-color);
        }

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: var(--radius-sm); font-weight: 600;
            border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px var(--shadow-color);
        }
        .btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px var(--shadow-color); }
        .btn:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 10px var(--shadow-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--btn-primary-bg); color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .btn-primary:hover:not(:disabled) { background-color: var(--btn-primary-hover-bg); }

        .btn-secondary {
            background-color: var(--btn-secondary-bg); color: var(--text-secondary);
            border: 1px solid var(--glass-border); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        .btn-secondary:hover:not(:disabled) { background-color: var(--btn-secondary-hover-bg); color: var(--text-primary); }

        .btn-icon {
            width: 2.75rem; height: 2.75rem; border-radius: 50%;
            padding: 0; flex-shrink: 0; position: relative;
            display: inline-flex; align-items: center; justify-content: center;
        }
        .btn-icon > .icon { margin: auto; }
        
        .btn-record {
            width: 7rem; height: 7rem; border-radius: 50%;
            background: radial-gradient(circle, #ff5f5f 0%, #ef4444 100%);
            color: #ffffff; font-weight: 600; cursor: pointer;
            box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
            border: 3px solid rgba(255, 255, 255, 0.4);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .btn-record:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 15px 30px color-mix(in srgb, var(--accent-danger) 40%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2); }
        .btn-record.is-recording { animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 70%, transparent); }
            70% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 15px color-mix(in srgb, var(--accent-danger) 0%, transparent); }
            100% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 0%, transparent); }
        }
        
        .input-field {
            width: 100%; background-color: var(--input-bg); border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm); padding: 0.75rem 1rem; color: var(--text-primary);
            transition: all 0.2s ease-in-out; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .input-field:focus {
            outline: none; border-color: var(--accent-primary); background-color: var(--input-focus-bg);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }
        textarea.input-field { resize: vertical; min-height: 80px; }

        .phoneme {
            padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 1.125rem;
            position: relative; transition: all 0.2s ease-in-out; color: var(--text-secondary);
        }
        .phoneme.status-correct { background-color: var(--highlight-correct); color: var(--accent-success); }
        .phoneme.status-approximate { background-color: var(--highlight-approximate); color: var(--accent-warning); }
        .phoneme.status-incorrect { background-color: var(--highlight-incorrect); color: var(--accent-danger); }

        .tooltip {
            visibility: hidden; opacity: 0; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translate(-50%, 10px); background-color: var(--bg-color); color: var(--text-primary);
            border: 1px solid var(--glass-border); z-index: 20;
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 0.5rem;
            width: 256px;
            border-radius: 0.75rem;
            padding: 0.75rem;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .has-tooltip:hover .tooltip { 
             visibility: visible; 
             opacity: 1; 
        }
        
        .score-container {
            width: 140px; height: 140px; margin: 1rem auto; display: flex; align-items: center; justify-content: center;
            transition: all 0.5s ease-out; border-radius: 50%; border: 4px solid transparent;
            background: radial-gradient(circle, color-mix(in srgb, var(--accent-primary) 10%, transparent) 0%, rgba(74, 128, 240, 0) 70%);
        }
        .score-container.score-high { border-color: var(--accent-success); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-success) 50%, transparent); }
        .score-container.score-medium { border-color: var(--accent-warning); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-warning) 50%, transparent); }
        .score-container.score-low { border-color: var(--accent-danger); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-danger) 50%, transparent); }
        
        #overall-score { font-size: 3.5rem; font-weight: 700; color: var(--text-primary); transition: color 0.5s ease-out; }
        .score-high #overall-score { color: var(--accent-success); }
        .score-medium #overall-score { color: var(--accent-warning); }
        .score-low #overall-score { color: var(--accent-danger); }

        #detailed-ipa-text { color: var(--accent-primary); }
        
        .thought-group {
            padding: 0.25rem 0.75rem; border-radius: 0.5rem; margin: 0.1rem;
            display: inline-block; transition: background-color 0.3s;
        }
        [data-theme="dark"] .thought-group-0 { background-color: rgba(96, 165, 250, 0.2); color: #bfdbfe; } /* blue */
        [data-theme="dark"] .thought-group-1 { background-color: rgba(52, 211, 153, 0.2); color: #a7f3d0; } /* emerald */
        [data-theme="dark"] .thought-group-2 { background-color: rgba(250, 204, 21, 0.2); color: #fef08a; } /* yellow */
        [data-theme="dark"] .thought-group-3 { background-color: rgba(192, 132, 252, 0.2); color: #e9d5ff; } /* purple */
        [data-theme="light"] .thought-group-0 { background-color: rgba(59, 130, 246, 0.15); color: #1e40af; }
        [data-theme="light"] .thought-group-1 { background-color: rgba(16, 185, 129, 0.15); color: #065f46; }
        [data-theme="light"] .thought-group-2 { background-color: rgba(245, 158, 11, 0.15); color: #92400e; }
        [data-theme="light"] .thought-group-3 { background-color: rgba(168, 85, 247, 0.15); color: #6b21a8; }
        
        .btn-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .fade-in { animation: fadeIn 0.6s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.is-visible {
            opacity: 1; visibility: visible;
        }
        .modal-container {
            width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .modal-overlay.is-visible .modal-container {
            transform: scale(1);
        }
        .history-item { cursor: pointer; transition: background-color 0.2s; }
        .history-item:hover { background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); }
        .history-item-text { color: var(--text-primary); }

        /* --- NEW ANALYSIS UI STYLES --- */
        .analysis-box-detailed {
            background-color: color-mix(in srgb, var(--input-bg) 60%, transparent);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1.25rem;
            box-shadow: inset 0 2px 4px color-mix(in srgb, var(--shadow-color) 50%, transparent);
        }

        .analysis-title {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .rhythm-score-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-top: -0.5rem;
            margin-bottom: 1rem;
        }

        #rhythm-score-value {
            font-size: 1.875rem; /* text-3xl */
            font-weight: 700;
            color: var(--accent-primary);
        }

        #rhythm-score-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        #prosody-tooltip-icon {
            cursor: pointer;
        }

        .intonation-chart-container {
            width: 100%;
            height: 150px;
            background-color: var(--input-bg);
            border-radius: var(--radius-sm);
            padding: 0.5rem;
            border: 1px solid var(--glass-border);
            margin-bottom: 1rem;
        }

        .connected-speech-item {
            padding: 1rem;
            border-radius: var(--radius-sm);
            border-left: 4px solid;
            position: relative;
            overflow: hidden;
        }

        .connected-speech-item.type-catenation { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.1); }
        .connected-speech-item.type-assimilation { border-color: #a855f7; background-color: rgba(168, 85, 247, 0.1); }
        .connected-speech-item.type-elision { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.1); }
        .connected-speech-item.type-intrusion { border-color: #14b8a6; background-color: rgba(20, 184, 166, 0.1); }
        .connected-speech-item.type-weak-form { border-color: #f59e0b; background-color: rgba(245, 158, 11, 0.1); }

        .cs-title { font-weight: 600; color: var(--text-primary); }
        .cs-location { font-family: 'Noto Sans', sans-serif; background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.9em; }
        .cs-details { font-size: 0.875rem; color: var(--text-secondary); }
        .cs-feedback { margin-top: 0.5rem; font-style: italic; }
    </style>
</head>
<body class="antialiased">
    <div class="background-container">
        <div class="blob blob-1"></div>
        <div class="blob blob-2"></div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-container glass-card p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h3 class="font-bold text-text-primary text-xl">Lịch sử Luyện tập</h3>
                <button id="close-history-btn" class="btn btn-secondary btn-icon !w-8 !h-8">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="history-list" class="space-y-2"></div>
            <button id="clear-history-btn" class="btn btn-secondary w-full">Xóa tất cả lịch sử</button>
        </div>
    </div>

    <div class="w-full max-w-3xl mx-auto p-4 relative z-10">
        <header class="text-center mb-8 fade-in relative flex justify-between items-center">
            <button id="history-btn" class="btn btn-secondary btn-icon" aria-label="Xem lịch sử">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            <div class="absolute left-1/2 -translate-x-1/2">
                <h1 class="text-5xl md:text-6xl font-bold font-logo" style="color: var(--accent-primary);">PrAI</h1>
                <p class="text-text-secondary text-sm md:text-base">Trợ lý luyện phát âm AI của bạn</p>
            </div>
            <button id="theme-toggle" class="btn btn-secondary btn-icon" aria-label="Toggle theme">
                <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
            </button>
        </header>

        <main class="main-card glass-card space-y-8">
            <section class="input-section card-layer glass-card space-y-4">
                <div>
                    <label for="text-input" class="block text-lg font-semibold text-text-primary mb-3">Nhập văn bản cần luyện tập:</label>
                    <textarea id="text-input" rows="3" maxlength="150" class="input-field" placeholder="Ví dụ: What are you doing?"></textarea>
                    <div id="char-counter" class="text-right text-sm text-text-secondary mt-1">0 / 150</div>
                    <div class="mt-4 flex flex-col sm:flex-row items-center gap-4">
                        <div class="flex-grow w-full">
                            <label for="accent-select" class="block text-sm font-medium text-text-secondary mb-1">Chọn giọng:</label>
                            <select id="accent-select" class="input-field">
                                <option value="British English" selected>Anh - Anh (BrE)</option>
                                <option value="American English">Anh - Mỹ (AmE)</option>
                            </select>
                        </div>
                        <div class="flex-shrink-0 flex gap-3 self-end">
                            <button id="random-practice-btn" class="btn btn-secondary">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 8"/><path d="M21 22v-6h-6"/><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"/></svg>
                                <span class="text hidden sm:inline">Ngẫu nhiên</span>
                            </button>
                             <button id="transcribe-btn" class="btn btn-primary relative">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                                 <span class="text">Phiên âm</span>
                                 <div class="btn-spinner hidden absolute inset-0 m-auto h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                             </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="controls-section" class="hidden space-y-6">
                 <div class="card-layer glass-card space-y-4">
                     <div class="flex items-center justify-between">
                         <div class="min-w-0">
                             <h3 class="font-semibold text-text-secondary text-md">Phiên âm cơ bản</h3>
                             <p id="simple-ipa-text" class="text-lg text-text-primary tracking-wider"></p>
                         </div>
                         <div class="relative w-11 h-11">
                             <button id="listen-clear-btn" class="btn-icon btn-secondary absolute inset-0">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>
                             </button>
                             <div id="listen-clear-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                 <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                             </div>
                         </div>
                     </div>
                     <div class="flex items-center justify-between">
                         <div class="min-w-0">
                             <div class="flex items-center gap-2 mb-1">
                                 <h3 class="font-semibold text-text-secondary text-md">Phiên âm & Cụm tư duy</h3>
                                 <div id="thought-group-info" class="has-tooltip relative hidden">
                                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-text-secondary cursor-pointer"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                                     <div id="thought-group-tooltip" class="tooltip absolute bottom-full left-1/2 mb-2 w-72 rounded-lg p-3 text-xs shadow-lg"></div>
                                 </div>
                             </div>
                             <div class="space-y-2">
                                 <p id="detailed-ipa-text" class="text-xl text-accent-primary tracking-wider"></p>
                                 <div id="thought-group-display" class="text-lg tracking-wide leading-relaxed font-medium"></div>
                             </div>
                         </div>
                         <div class="relative w-11 h-11">
                             <button id="listen-natural-btn" class="btn-icon btn-secondary absolute inset-0">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                             </button>
                             <div id="listen-natural-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                 <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                             </div>
                         </div>
                     </div>
                 </div>

                <div class="flex flex-col items-center justify-center gap-4 pt-4">
                    <div id="record-controls" class="flex items-center justify-center gap-6 w-full h-28">
                        <button id="upload-btn" class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        </button>
                        <div class="flex flex-col items-center justify-center">
                            <button id="record-btn" class="btn-record flex items-center justify-center">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                                <span class="text hidden text-lg font-semibold">Dừng</span>
                            </button>
                        </div>
                        <button id="listen-again-btn" disabled class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
                        </button>
                    </div>
                    <div id="waveform-container" class="hidden h-20 w-full card-layer-inset flex items-center justify-center p-2">
                        <canvas id="waveform" class="w-full h-full"></canvas>
                    </div>
                </div>
            </section>

            <div id="loader" class="text-center hidden py-4 flex flex-col items-center justify-center">
                <div class="w-full max-w-xs h-2 rounded-full overflow-hidden bg-[color:var(--input-bg)]">
                    <div id="progress-bar-inner" class="h-full rounded-full bg-gradient-to-r from-sky-400 to-teal-400 transition-all duration-500"></div>
                </div>
                <p id="progress-text" class="text-text-secondary mt-4">PrAI đang lắng nghe và phân tích...</p>
                <p id="fun-fact" class="text-sm text-text-secondary/70 mt-6 italic hidden"></p>
            </div>

            <!-- UPDATED ANALYSIS RESULTS SECTION -->
            <section id="analysis-results" class="hidden space-y-6">
                <div class="card-layer glass-card space-y-6 p-6">
                    <h3 class="font-bold text-text-primary text-2xl text-center">Kết quả Phân tích</h3>
            
                    <!-- Overall Score -->
                    <div class="score-container">
                        <p><span id="overall-score"></span><span class="text-xl text-text-secondary">/100</span></p>
                    </div>
            
                    <!-- Rhythm Score -->
                    <div class="rhythm-score-container">
                        <span id="rhythm-score-label">Điểm nhịp điệu:</span>
                        <span id="rhythm-score-value"></span>
                        <div id="prosody-tooltip" class="has-tooltip relative">
                            <svg id="prosody-tooltip-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-text-secondary"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                            <div id="prosody-tooltip-text" class="tooltip w-72"></div>
                        </div>
                    </div>
            
                    <!-- Phoneme Analysis -->
                    <div class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Âm vị</h4>
                        <div id="phoneme-analysis" class="flex flex-wrap gap-2"></div>
                        <p class="text-xs text-text-secondary mt-3">Chạm hoặc di chuột qua các âm vị để xem hướng dẫn.</p>
                    </div>
            
                    <!-- Intonation Analysis -->
                    <div class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Ngữ điệu</h4>
                        <div class="intonation-chart-container">
                            <svg id="intonation-chart" width="100%" height="100%"></svg>
                        </div>
                        <div id="intonation-analysis-feedback" class="text-sm text-text-secondary"></div>
                    </div>
            
                    <!-- Connected Speech Analysis -->
                    <div class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Nối âm & Cụm tư duy</h4>
                        <div id="connected-speech-analysis" class="space-y-3"></div>
                    </div>
            
                </div>
            
                <!-- Practice Suggestions Section -->
                <div id="practice-suggestions" class="hidden card-layer glass-card">
                     <h3 class="font-bold text-text-primary text-xl mb-4">Xem ví dụ thực tế</h3>
                     <div id="suggestion-links" class="flex flex-col sm:flex-row gap-3 mt-2"></div>
                </div>
            </section>
        </main>

        <div id="message-box" class="fixed bottom-5 right-5 hidden p-4 rounded-xl text-sm z-50 shadow-lg glass-card"></div>
        <audio id="replay-audio" class="hidden"></audio>
        <input type="file" id="audio-upload-input" class="hidden" accept="audio/*">

        <footer class="text-center mt-8 text-text-secondary text-sm">
            <p>© 2025 PrAI. Được tạo ra với niềm đam mê ngôn ngữ bởi Mr Bảo.</p>
        </footer>
    </div>

    <script type="module">
        // --- THEME SWITCHER LOGIC ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const docElement = document.documentElement;

        function applyTheme(theme) {
            docElement.setAttribute('data-theme', theme);
            if (theme === 'light') {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
            localStorage.setItem('prai-theme', theme);
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = docElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        });

        const savedTheme = localStorage.getItem('prai-theme') || 'light';
        applyTheme(savedTheme);


        // --- APP LOGIC ---
        const textInput = document.getElementById('text-input');
        const accentSelect = document.getElementById('accent-select');
        const transcribeBtn = document.getElementById('transcribe-btn');
        const listenNaturalBtn = document.getElementById('listen-natural-btn');
        const listenClearBtn = document.getElementById('listen-clear-btn');
        const listenClearLoader = document.getElementById('listen-clear-loader');
        const listenNaturalLoader = document.getElementById('listen-natural-loader');
        const recordControls = document.getElementById('record-controls');
        const uploadBtn = document.getElementById('upload-btn');
        const recordBtn = document.getElementById('record-btn');
        const listenAgainBtn = document.getElementById('listen-again-btn');
        const randomPracticeBtn = document.getElementById('random-practice-btn');
        const controlsSection = document.getElementById('controls-section');
        const loader = document.getElementById('loader');
        const simpleIpaText = document.getElementById('simple-ipa-text');
        const detailedIpaText = document.getElementById('detailed-ipa-text');
        const analysisResults = document.getElementById('analysis-results');
        const overallScore = document.getElementById('overall-score');
        const phonemeAnalysis = document.getElementById('phoneme-analysis');
        const practiceSuggestions = document.getElementById('practice-suggestions');
        const suggestionLinks = document.getElementById('suggestion-links');
        const messageBox = document.getElementById('message-box');
        const waveformContainer = document.getElementById('waveform-container');
        const waveformEl = document.getElementById('waveform');
        const replayAudio = document.getElementById('replay-audio');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const funFactEl = document.getElementById('fun-fact');
        const connectedSpeechAnalysis = document.getElementById('connected-speech-analysis');
        const progressText = document.getElementById('progress-text');
        const progressBarInner = document.getElementById('progress-bar-inner');
        const charCounter = document.getElementById('char-counter');
        const thoughtGroupDisplay = document.getElementById('thought-group-display');
        const thoughtGroupInfo = document.getElementById('thought-group-info');
        const thoughtGroupTooltip = document.getElementById('thought-group-tooltip');
        
        const historyBtn = document.getElementById('history-btn');
        const historyModal = document.getElementById('history-modal');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const historyList = document.getElementById('history-list');
        const clearHistoryBtn = document.getElementById('clear-history-btn');

        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let standardIPA = '';
        let audioContext;
        let analyser;
        let waveformAnimationId;
        let lastRecordingBlob = null;
        let soundDetected = false;
        let ipaLoadingInterval;
        let lastTTSAudioNatural = null;
        let lastTTSTextNatural = '';
        let lastTTSAccentNatural = '';
        let lastTTSAudioClear = null;
        let lastTTSTextClear = '';
        let lastTTSAccentClear = '';
        let fetchIpaRequestID = 0;
        let analysisRequestID = 0;
        let progressInterval;
        let progressTextTimeoutIds = [];
        let currentThoughtGroups = [];
        let isPrefetching = false;

        // --- Caching Implementation ---
        const ipaCache = {
            get(key) {
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : null;
                } catch (e) {
                    console.error("Error reading from cache", e);
                    return null;
                }
            },
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                } catch (e) {
                    console.error("Error writing to cache", e);
                }
            }
        };


        const funFacts = [
            "'Ough' có thể được phát âm theo 10 cách khác nhau.",
            "Âm câm (silent letters) là di tích lịch sử từ các ngôn ngữ khác.",
            "'Pronunciation' (phát âm) trớ trêu lại là từ bị phát âm sai nhiều nhất.",
            "Tiếng Anh có tới 20 âm nguyên âm theo hệ thống IPA, nhiều hơn hầu hết các ngôn ngữ khác.",
            "'Strengths' là từ dài nhất chỉ có một nguyên âm.",
        ];

        const practiceSentences = [
            "What are you doing?", "It's a piece of cake.", "I'll call you back later.",
            "How's it going?", "Can I have a bottle of water, please?", "It's a beautiful day, isn't it?",
            "I'm looking forward to it.", "Could you please repeat that?", "Where is the nearest station?",
        ];

        // API KEY REMOVED FOR SECURITY
        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        // API URLS POINT TO THE PROXY FUNCTION
        const TEXT_API_URL = `/api/proxy`;
        const TTS_API_URL = `/api/proxy`;

        function showMessage(message, type = 'info') {
            const typeClasses = {
                'info': 'text-blue-300 border-accent-primary/30',
                'success': 'text-green-300 border-accent-success/30',
                'warning': 'text-yellow-300 border-accent-warning/30',
                'error': 'text-red-300 border-accent-danger/30'
            };
            messageBox.className = `fixed bottom-5 right-5 p-4 rounded-xl text-sm z-50 shadow-lg glass-card fade-in ${typeClasses[type]}`;
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('hidden'), 5000);
        }

        function handleApiError(error) {
            console.error("API Error:", error);
            if (error.message && (error.message.includes('429') || error.message.toLowerCase().includes('quota'))) {
                showMessage('Hệ thống đang bận. Bạn vui lòng thử lại sau nhé.', 'error');
            } else {
                showMessage(`Đã xảy ra lỗi kết nối: ${error.message}`, 'error');
            }
        }

        function setButtonLoading(button, loader, isLoading) {
            button.disabled = isLoading;
            if (loader) { // Logic for icon buttons with separate loaders
                if(isLoading) {
                    button.classList.add('hidden');
                    loader.classList.remove('hidden');
                    loader.classList.add('flex'); // Ensure flex display for centering
                } else {
                    button.classList.remove('hidden');
                    loader.classList.add('hidden');
                    loader.classList.remove('flex');
                }
            } else { // Logic for buttons with internal spinners
                const textEl = button.querySelector('.text');
                const iconEl = button.querySelector('.icon');
                const spinnerEl = button.querySelector('.btn-spinner');
                if (isLoading) {
                    if (textEl) textEl.style.visibility = 'hidden';
                    if (iconEl) iconEl.style.visibility = 'hidden';
                    if (spinnerEl) spinnerEl.classList.remove('hidden');
                } else {
                    if (textEl) textEl.style.visibility = 'visible';
                    if (iconEl) iconEl.style.visibility = 'visible';
                    if (spinnerEl) spinnerEl.classList.add('hidden');
                }
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1, bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithBackoff(url, options, maxRetries = 4) {
             let delay = 1000;
             for (let i = 0; i < maxRetries; i++) {
                 try {
                     const response = await fetch(url, options);
                     if (response.status === 429 || response.status >= 500) {
                         if (i === maxRetries - 1) {
                             const errorBody = await response.json().catch(() => ({}));
                             throw new Error(`API Error: ${response.status}. ${errorBody.error?.message || 'Server error after multiple retries.'}`);
                         }
                         await new Promise(resolve => setTimeout(resolve, delay));
                         delay *= 2; 
                         continue; 
                     }
                     if (!response.ok) {
                         const errorBody = await response.json().catch(() => ({}));
                         throw new Error(`API Error: ${response.status}. ${errorBody.error?.message || 'An unknown error occurred.'}`);
                     }
                     return await response.json();
                 } catch (error) {
                     if (i === maxRetries - 1) {
                         throw error;
                     }
                     await new Promise(resolve => setTimeout(resolve, delay));
                     delay *= 2;
                 }
             }
         }

        function startIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
            const ipaSymbols = ['ə', 'ʃ', 't', 'd', 'k', 'æ', 'iː', 'θ', 'ð', 'ŋ', 'w', 'j', 'r', 'l', 's', 'z'];
            let i = 0;
            ipaLoadingInterval = setInterval(() => {
                const symbolSequence = Array(5).fill(0).map((_, j) => ipaSymbols[(i + j) % ipaSymbols.length]).join(' ');
                simpleIpaText.textContent = `/ ${symbolSequence} /`;
                detailedIpaText.textContent = `[ ${symbolSequence} ]`;
                thoughtGroupDisplay.textContent = `...`;
                i = (i + 1) % ipaSymbols.length;
            }, 100);
        }

        function stopIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
        }

        function displayIpaData(data) {
            standardIPA = data.detailed;
            simpleIpaText.textContent = data.simple;
            detailedIpaText.textContent = data.detailed;

            if (data.thought_groups && textInput.value.trim().includes(' ')) {
                currentThoughtGroups = data.thought_groups.groups;
                displayThoughtGroups(data.thought_groups.groups, data.thought_groups.explanation);
            } else {
                currentThoughtGroups = [textInput.value.trim()];
                displayThoughtGroups([], '');
            }
            controlsSection.classList.remove('hidden');
            thoughtGroupInfo.style.display = textInput.value.trim().includes(' ') ? 'block' : 'none';
        }
        
        async function prefetchNaturalTTS(text, accent) {
            if (isPrefetching) return;
            if (lastTTSTextNatural === text && lastTTSAccentNatural === accent && lastTTSAudioNatural) return;
        
            isPrefetching = true;
            try {
                let prompt;
                if (!text.includes(' ') || currentThoughtGroups.length <= 1) {
                    prompt = `Read ONLY the following text in ${accent}. Pronounce it naturally and fluently. Text: ${text}`;
                } else {
                    const textWithPauses = currentThoughtGroups.join(" | ");
                    prompt = `Read ONLY the following text in ${accent}. Do not read any instructions. The pipe symbol "|" indicates a slight, natural hesitation between thought groups, not a full stop. The speech should flow smoothly and connectively within each group. Text: ${textWithPauses}`;
                }
        
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseModalities: ["AUDIO"] },
                    model: TTS_MODEL
                };
        
                const data = await fetchWithBackoff(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                    body: JSON.stringify(payload)
                });
        
                const audioPart = data?.candidates?.[0]?.content?.parts?.[0];
                if (audioPart && audioPart.inlineData) {
                    const audioData = audioPart.inlineData.data;
                    const mimeType = audioPart.inlineData.mimeType;
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    
                    [lastTTSAudioNatural, lastTTSTextNatural, lastTTSAccentNatural] = [audio, text, accent];
                    console.log("TTS audio prefetched successfully.");
                }
            } catch (error) {
                console.error("TTS prefetch failed:", error);
            } finally {
                isPrefetching = false;
            }
        }


        async function fetchAndDisplayIPA() {
            fetchIpaRequestID++;
            const currentRequestID = fetchIpaRequestID;

            const text = textInput.value.trim();
            if (!text) {
                resetAll();
                return false;
            }
            
            const accent = accentSelect.value;
            const cacheKey = `ipa_${text}_${accent}`;
            const cachedData = ipaCache.get(cacheKey);

            if (cachedData) {
                displayIpaData(cachedData);
                // Prefetch audio for cached results as well
                if (!text.includes(' ')) {
                   prefetchNaturalTTS(text, accent);
                }
                return true;
            }
            
            const isSingleWord = !text.includes(' ');
            let combinedPrompt;

            if (isSingleWord) {
                combinedPrompt = `Provide a single JSON object for the word "${text}" in ${accent}. The JSON must have one key: 'simple', containing the standard IPA transcription. Do not include any other analysis.`;
            } else {
                combinedPrompt = `For the phrase "${text}" in ${accent}, provide a single JSON object with the following keys:
                1. 'simple': A standard, citation-form IPA transcription.
                2. 'detailed': A natural, connected speech transcription reflecting the thought groups. IMPORTANT: Apply the liaison symbol (‿) **only where phonetically correct linking occurs** (e.g., a final consonant linking to an initial vowel) and strictly **within** each thought group. Do NOT place the symbol between every word. The boundary between thought groups acts as a hard stop for linking.
                3. 'thought_groups': An object with two keys:
                   a. 'groups': An array of strings representing the most natural, semantically-driven thought groups, based on grammatical units.
                   b. 'explanation': Provide an insightful and clear explanation in Vietnamese for the suggested grouping, referencing principles like separating grammatical units (e.g., prepositional phrases, clauses).
                Respond with ONLY the JSON object.`;
            }
            
            setButtonLoading(transcribeBtn, null, true);
            controlsSection.classList.remove('hidden');
            thoughtGroupDisplay.style.display = isSingleWord ? 'none' : 'block';
            thoughtGroupInfo.style.display = isSingleWord ? 'none' : 'block';
            
            startIpaLoadingAnimation();
            
            try {
                const payload = { 
                    contents: [{ parts: [{ text: combinedPrompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };

                const response = await fetchWithBackoff(TEXT_API_URL, { 
                    method: 'POST', 
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-Target-API': 'text'
                    }, 
                    body: JSON.stringify(payload) 
                });

                if (currentRequestID !== fetchIpaRequestID) return false;

                const resultText = response.candidates[0].content.parts[0].text;
                let resultJson = JSON.parse(resultText);

                if (isSingleWord) {
                    resultJson.detailed = resultJson.simple;
                }

                ipaCache.set(cacheKey, resultJson);
                displayIpaData(resultJson);
                
                if (!isSingleWord) {
                    prefetchNaturalTTS(text, accent);
                }
                
                return true;
            } catch (error) {
                if (currentRequestID === fetchIpaRequestID) {
                    handleApiError(error);
                    resetAll();
                }
                return false;
            } finally {
                if (currentRequestID === fetchIpaRequestID) {
                    stopIpaLoadingAnimation();
                    setButtonLoading(transcribeBtn, null, false);
                }
            }
        }

        function displayThoughtGroups(groups, explanation) {
            thoughtGroupDisplay.innerHTML = '';
            thoughtGroupTooltip.textContent = explanation || '';
            
            if (groups && groups.length > 0 && explanation) {
                thoughtGroupInfo.style.display = 'block';
                groups.forEach((group, index) => {
                    const groupSpan = document.createElement('span');
                    groupSpan.textContent = group;
                    groupSpan.className = `thought-group thought-group-${index % 4}`;
                    thoughtGroupDisplay.appendChild(groupSpan);
                });
            } else {
                thoughtGroupInfo.style.display = 'none';
            }
        }

        async function handleListen(type, button, loader) {
            const text = textInput.value.trim();
            const accent = accentSelect.value;
            if (!text) {
                showMessage('Vui lòng nhập từ hoặc câu để nghe.', 'warning');
                return;
            }
            
            const isNatural = type === 'natural';
            
            let cachedAudio, cachedText, cachedAccent;
            if (isNatural) {
                [cachedAudio, cachedText, cachedAccent] = [lastTTSAudioNatural, lastTTSTextNatural, lastTTSAccentNatural];
            } else {
                [cachedAudio, cachedText, cachedAccent] = [lastTTSAudioClear, lastTTSTextClear, lastTTSAccentClear];
            }

            if (cachedAudio && cachedText === text && cachedAccent === accent) {
                cachedAudio.play();
                return;
            }

            const ipaFetched = await fetchAndDisplayIPA();
            if (!ipaFetched) return;

            setButtonLoading(button, loader, true);
            try {
                let prompt;
                if (isNatural) {
                    if (!text.includes(' ') || currentThoughtGroups.length <= 1) {
                        prompt = `Read ONLY the following text in ${accent}. Pronounce it naturally and fluently. Text: ${text}`;
                    } else {
                        const textWithPauses = currentThoughtGroups.join(" | ");
                        prompt = `Read ONLY the following text in ${accent}. Do not read any instructions. The pipe symbol "|" indicates a slight, natural hesitation between thought groups, not a full stop. The speech should flow smoothly and connectively within each group. Text: ${textWithPauses}`;
                    }
                } else { // Clear
                    prompt = `Say very clearly, with only a slight pause between each word, in ${accent}: ${text}`;
                }

                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseModalities: ["AUDIO"] },
                    model: TTS_MODEL
                };

                const data = await fetchWithBackoff(TTS_API_URL, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-Target-API': 'tts'
                    },
                    body: JSON.stringify(payload)
                });

                const audioPart = data?.candidates?.[0]?.content?.parts?.[0];
                if (audioPart && audioPart.inlineData) {
                    const audioData = audioPart.inlineData.data;
                    const mimeType = audioPart.inlineData.mimeType;
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    const audio = new Audio(audioUrl);
                    audio.play();

                    if(isNatural) {
                        [lastTTSAudioNatural, lastTTSTextNatural, lastTTSAccentNatural] = [audio, text, accent];
                    } else {
                        [lastTTSAudioClear, lastTTSTextClear, lastTTSAccentClear] = [audio, text, accent];
                    }
                } else {
                    throw new Error("Không nhận được dữ liệu âm thanh hợp lệ.");
                }
            } catch (error) {
                handleApiError(error);
            } finally {
                setButtonLoading(button, loader, false);
            }
        }

        function startProgressSimulation() {
            if (!progressBarInner) return;
            
            let width = 0;
            progressBarInner.style.width = '0%';
            
            clearInterval(progressInterval);

            progressInterval = setInterval(() => {
                if (width < 95) {
                    width += Math.random() * 2;
                } else {
                    clearInterval(progressInterval);
                }
                progressBarInner.style.width = Math.min(width, 95) + '%';
            }, 100);
        }

        function stopProgressSimulation() {
            clearInterval(progressInterval);
            if (progressBarInner) {
                progressBarInner.style.width = '100%';
            }
        }

        function startProgressTextAnimation() {
            const steps = [
                { text: "Okie, PrAI đã nhận được bản ghi âm của bạn...", duration: 1500 },
                { text: "Đang phiên âm giọng nói của bạn!", duration: 2500 },
                { text: "So sánh từng âm một với giọng chuẩn...", duration: 3000 },
                { text: "Kiểm tra ngữ điệu và cả nhịp điệu...", duration: 2000 },
                { text: "Xong rồi! Cùng xem kết quả tuyệt vời của bạn nhé!", duration: 1000 }
            ];
            let cumulativeDelay = 0;
        
            stopProgressTextAnimation(); // Clear previous timeouts
        
            steps.forEach((step) => {
                const timeoutId = setTimeout(() => {
                    if (progressText) {
                       progressText.textContent = step.text;
                    }
                }, cumulativeDelay);
                progressTextTimeoutIds.push(timeoutId);
                cumulativeDelay += step.duration;
            });
        }
        
        function stopProgressTextAnimation() {
            progressTextTimeoutIds.forEach(clearTimeout);
            progressTextTimeoutIds = [];
        }


        async function analyzeAudio(audioBlob) {
            const currentAnalysisID = analysisRequestID;

            if (!audioBlob) return;
            lastRecordingBlob = audioBlob;
            listenAgainBtn.disabled = false;

            const ipaReady = !!standardIPA;
            if (!ipaReady) {
                showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                return;
            }
            
            loader.classList.remove('hidden');
            startProgressTextAnimation();
            startProgressSimulation();
            funFactEl.textContent = `💡 ${funFacts[Math.floor(Math.random() * funFacts.length)]}`;
            funFactEl.classList.remove('hidden');
            
            const reader = new FileReader();
            reader.readAsDataURL(lastRecordingBlob);
            reader.onloadend = async () => {
                if (currentAnalysisID !== analysisRequestID) {
                    console.log(`Analysis request ${currentAnalysisID} cancelled by new request ${analysisRequestID}.`);
                    loader.classList.add('hidden');
                    funFactEl.classList.add('hidden');
                    stopProgressSimulation();
                    stopProgressTextAnimation();
                    return; 
                }

                const base64Audio = reader.result.split(',')[1];
                
                // --- UPDATED GEMINI PROMPT ---
                const prompt = {
                    "role": "Bạn là PrAI, một chuyên gia ngữ âm AI được đào tạo chuyên sâu dựa trên các tài liệu học thuật về Cụm tư duy và Lời nói nối âm trong tiếng Anh. Nhiệm vụ của bạn là đưa ra phản hồi chính xác, mang tính xây dựng cao cho người học tiếng Anh là người Việt. Mục tiêu của bạn là vừa sửa lỗi một cách nghiêm khắc theo quy tắc, vừa là một người hướng dẫn động viên, khích lệ.",
                    "context": {
                        "learner_profile": "Người học là người Việt, thường gặp các vấn đề sau: bỏ âm cuối, nhầm lẫn các cặp nguyên âm ngắn/dài, không phân biệt âm vô thanh/hữu thanh, và nói ngắt nghỉ từng từ (word-by-word) thay vì theo cụm tư duy.",
                        "evaluation_philosophy": "Triết lý chấm điểm của bạn là phân biệt rõ ràng giữa 'Lỗi nghiêm trọng' (ảnh hưởng đến việc người nghe có hiểu hay không) và 'Điểm chưa hoàn hảo' (có thể cải thiện nhưng không gây hiểu nhầm). Hãy luôn dùng ngôn ngữ tích cực. Ví dụ, thay vì nói 'Sai rồi', hãy nói 'Bạn đã làm rất tốt phần đầu của âm này! Để hoàn thiện hơn, hãy thử...'",
                        "text_to_pronounce": textInput.value.trim(),
                        "target_accent": accentSelect.value === 'American English' ? 'AmE' : 'BrE',
                        "standard_ipa": standardIPA,
                        "thought_groups_base": currentThoughtGroups
                    },
                    "task": "Phân tích file âm thanh, so sánh với phiên âm và cụm tư duy chuẩn. Sau đó, tính điểm 'overall_score' và các điểm thành phần dựa trên hệ thống trọng số lỗi. Đặc biệt, phân tích sâu các hiện tượng Lời nói nối âm và Cụm tư duy. Cung cấp toàn bộ phản hồi bằng tiếng Việt.",
                    "scoring_system": {
                        "base_score": 100,
                        "error_weights": [
                            { "type": "Lỗi nghiêm trọng (Critical Error)", "deduction": "Trừ 10-15 điểm/lỗi", "examples": ["Bỏ âm cuối (vd: 'like' đọc thành /laɪ/)", "Sai hoàn toàn một nguyên âm chính (vd: 'ship' /ʃɪp/ đọc thành /ʃiːp/)", "Sai trọng âm của từ"] },
                            { "type": "Lỗi trung bình (Medium Error)", "deduction": "Trừ 5-8 điểm/lỗi", "examples": ["Thay thế các phụ âm khó nhưng vẫn có thể hiểu được (vd: /θ/ -> /s/)", "Nguyên âm hơi lệch nhưng không biến thành một nguyên âm khác hoàn toàn."] },
                            { "type": "Lỗi nhỏ (Minor Error)", "deduction": "Trừ 1-3 điểm/lỗi", "examples": ["Độ dài nguyên âm chưa hoàn hảo", "Âm cuối bật ra hơi yếu nhưng vẫn có", "Ngữ điệu chưa tự nhiên nhưng không sai."] }
                        ],
                        "instruction": "Hãy tính điểm cuối cùng bằng cách lấy 100 trừ đi tổng điểm của các lỗi đã được phân loại. Hãy công bằng và chính xác."
                    },
                    "output_format_instruction": {
                        "format": "JSON",
                        "schema": {
                            "speech_detected": "boolean",
                            "overall_score": "number | null",
                            "user_ipa": "string | null",
                            "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string | null\" } ] | null",
                            "rhythm_and_pacing_analysis": {
                                "rhythm_score": "number (0-100)",
                                "feedback": "string // Nhận xét chi tiết bằng tiếng Việt về nhịp điệu (stress-timed rhythm) và tốc độ nói (pacing). Ví dụ: 'Tốc độ của bạn hơi nhanh, dẫn đến một số âm tiết không được nhấn bị lướt qua. Hãy thử duy trì nhịp điệu đều đặn hơn giữa các từ được nhấn trọng âm.'"
                            },
                            "intonation_analysis": {
                                "feedback": "string // Nhận xét bằng tiếng Việt về đường nét ngữ điệu chung (ví dụ: lên giọng ở cuối câu hỏi Yes/No, xuống giọng ở cuối câu trần thuật).",
                                "model_pitch_contour": "[number] // Một mảng gồm 30-50 điểm dữ liệu cao độ của giọng mẫu, đã được chuẩn hóa trong khoảng 0-100.",
                                "user_pitch_contour": "[number] // Một mảng gồm 30-50 điểm dữ liệu cao độ của giọng người dùng, đã được chuẩn hóa trong khoảng 0-100."
                            },
                            "connected_speech_analysis": "[{ \"type\": \"string ('Catenation', 'Assimilation', 'Elision', 'Intrusion', 'Weak Form')\", \"rule\": \"string // Tên quy tắc, ví dụ: 'Nối phụ âm - nguyên âm' hoặc 'Đồng hóa /t/ + /j/ -> /tʃ/'\", \"location\": \"string // Cụm từ nơi hiện tượng xảy ra, vd: 'in an'\", \"expected_pronunciation\": \"string // IPA của cách phát âm mong đợi, vd: /ɪn‿ən/\", \"user_pronunciation\": \"string // IPA của cách người dùng phát âm, vd: /ɪn æn/\", \"feedback\": \"string // Nhận xét cụ thể bằng tiếng Việt, vd: 'Tuyệt vời! Bạn đã nối âm /n/ với nguyên âm /æ/ rất tự nhiên.' hoặc 'Ở đây, bạn đã ngắt giữa hai từ. Hãy thử nối phụ âm cuối /t/ của 'want' với nguyên âm đầu của 'it' để nghe mượt mà hơn.'\" }] | null",
                            "practice_suggestions": "{ \"youglish_us\": \"string\", \"youglish_uk\": \"string\" } | null"
                        }
                    }
                };

                const payload = {
                    contents: [ { role: "user", parts: [ { text: JSON.stringify(prompt) }, { inlineData: { mimeType: "audio/webm", data: base64Audio } } ] } ],
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const data = await fetchWithBackoff(TEXT_API_URL, { 
                        method: 'POST', 
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-Target-API': 'text'
                        }, 
                        body: JSON.stringify(payload) 
                    });
                    
                    if (currentAnalysisID !== analysisRequestID) {
                        console.log(`Analysis request ${currentAnalysisID} completed, but a newer request is active. Discarding results.`);
                        return;
                    }

                    const resultText = data.candidates[0].content.parts[0].text;
                    const resultJson = JSON.parse(resultText);
                    displayResults(resultJson);
                } catch (error) {
                    if (currentAnalysisID === analysisRequestID) {
                        handleApiError(error);
                    }
                } finally {
                    if (currentAnalysisID === analysisRequestID) {
                        stopProgressSimulation();
                        stopProgressTextAnimation();
                        setTimeout(() => {
                            loader.classList.add('hidden');
                            funFactEl.classList.add('hidden');
                        }, 500);
                    }
                }
            };
        }
        
        // --- NEW displayResults FUNCTION ---
        function displayResults(data) {
            if (!data.speech_detected || data.overall_score === null) {
                showMessage("PrAI không nhận diện được giọng nói trong bản ghi âm. Vui lòng thử lại và nói to, rõ hơn nhé.", 'warning');
                analysisResults.classList.add('hidden');
                return;
            }
        
            saveToHistory(textInput.value.trim(), data.overall_score);
        
            const scoreContainer = document.querySelector('.score-container');
            analysisResults.classList.remove('hidden');
        
            // --- Animate Score ---
            const endScore = data.overall_score;
            animateValue(document.getElementById('overall-score'), 0, endScore, 1000);
            scoreContainer.className = 'score-container'; // Reset classes
            if (endScore > 85) scoreContainer.classList.add('score-high');
            else if (endScore > 70) scoreContainer.classList.add('score-medium');
            else scoreContainer.classList.add('score-low');
        
            // --- Rhythm & Pacing ---
            const rhythmScoreValue = document.getElementById('rhythm-score-value');
            const prosodyTooltipText = document.getElementById('prosody-tooltip-text');
            if (data.rhythm_and_pacing_analysis) {
                animateValue(rhythmScoreValue, 0, data.rhythm_and_pacing_analysis.rhythm_score, 1000);
                prosodyTooltipText.textContent = data.rhythm_and_pacing_analysis.feedback;
                document.querySelector('.rhythm-score-container').style.display = 'flex';
            } else {
                document.querySelector('.rhythm-score-container').style.display = 'none';
            }
        
            // --- Phoneme Analysis ---
            phonemeAnalysis.innerHTML = '';
            if (data.phoneme_analysis) {
                data.phoneme_analysis.forEach(p => {
                    const phonemeEl = document.createElement('div');
                    phonemeEl.textContent = p.phoneme;
                    phonemeEl.className = `phoneme has-tooltip status-${p.status}`;
                    if (p.feedback) {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'tooltip';
                        tooltip.textContent = p.feedback;
                        phonemeEl.appendChild(tooltip);
                    }
                    phonemeAnalysis.appendChild(phonemeEl);
                });
            }
        
            // --- Intonation Analysis ---
            const intonationFeedbackEl = document.getElementById('intonation-analysis-feedback');
            const intonationChartEl = document.getElementById('intonation-chart');
            if (data.intonation_analysis) {
                intonationFeedbackEl.textContent = data.intonation_analysis.feedback;
                renderIntonationChart(
                    intonationChartEl,
                    data.intonation_analysis.model_pitch_contour,
                    data.intonation_analysis.user_pitch_contour
                );
            }
            
            // --- Connected Speech Analysis ---
            const connectedSpeechContainer = document.getElementById('connected-speech-analysis');
            connectedSpeechContainer.innerHTML = '';
            if (data.connected_speech_analysis && data.connected_speech_analysis.length > 0) {
                data.connected_speech_analysis.forEach(item => {
                    const itemEl = document.createElement('div');
                    const typeClass = `type-${item.type.split(' ')[0].toLowerCase().replace(/\s/g, '-')}`;
                    itemEl.className = `connected-speech-item ${typeClass}`;
                    
                    itemEl.innerHTML = `
                        <div class="flex justify-between items-start">
                            <div>
                                <p class="cs-title">${item.rule}</p>
                                <p class="cs-details mt-1">
                                    Vị trí: <span class="cs-location">${item.location}</span>
                                </p>
                            </div>
                            <span class="text-xs font-semibold uppercase px-2 py-1 rounded-full ${typeClass} opacity-70">${item.type}</span>
                        </div>
                        <div class="cs-details mt-2">
                            <p>Phát âm mong đợi: <span class="ipa-text text-accent-success">${item.expected_pronunciation}</span></p>
                            <p>Phát âm của bạn: <span class="ipa-text text-accent-warning">${item.user_pronunciation}</span></p>
                        </div>
                        <p class="cs-feedback text-sm">${item.feedback}</p>
                    `;
                    connectedSpeechContainer.appendChild(itemEl);
                });
            } else {
                connectedSpeechContainer.innerHTML = '<p class="text-text-secondary text-sm italic">Không có nhận xét nổi bật về nối âm trong câu này. Lời nói của bạn khá rõ ràng nhưng có thể chưa thể hiện được sự liên kết tự nhiên.</p>';
            }
        
            // --- Practice Suggestions ---
            if (data.practice_suggestions) {
                suggestionLinks.innerHTML = '';
                const { youglish_us, youglish_uk } = data.practice_suggestions;
                const usLink = document.createElement('a');
                usLink.href = youglish_us;
                usLink.target = '_blank';
                usLink.className = 'btn btn-primary flex-1';
                usLink.textContent = 'Giọng Mỹ (YouGlish)';
                const ukLink = document.createElement('a');
                ukLink.href = youglish_uk;
                ukLink.target = '_blank';
                ukLink.className = 'btn btn-primary flex-1';
                ukLink.textContent = 'Giọng Anh (YouGlish)';
                suggestionLinks.appendChild(usLink);
                suggestionLinks.appendChild(ukLink);
                practiceSuggestions.classList.remove('hidden');
            } else {
                practiceSuggestions.classList.add('hidden');
            }
        }

        function resetAnalysisOnly() {
            analysisResults.classList.add('hidden');
            practiceSuggestions.classList.add('hidden');
        }

        function resetAll() {
            standardIPA = '';
            controlsSection.classList.add('hidden');
            resetAnalysisOnly();
            lastTTSAudioNatural = null;
            lastTTSTextNatural = '';
            lastTTSAccentNatural = '';
            lastTTSAudioClear = null;
            lastTTSTextClear = '';
            lastTTSAccentClear = '';
            currentThoughtGroups = [];
            displayThoughtGroups([], '');
        }

        async function handleRecord() {
            if (isRecording) {
                mediaRecorder.stop();
                return;
            }
            
            analysisRequestID++;

            if (!textInput.value.trim()) {
                showMessage('Vui lòng nhập từ để ghi âm và phân tích.', 'warning');
                return;
            }
            
            resetAnalysisOnly(); 
            listenAgainBtn.disabled = true;
            lastRecordingBlob = null;
            
            try {
                if (!standardIPA) {
                    const ipaReady = await fetchAndDisplayIPA();
                    if (!ipaReady) {
                        showMessage('Chưa có phiên âm chuẩn, không thể bắt đầu ghi âm.', 'warning');
                        return;
                    }
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true;
                soundDetected = false;
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = () => {
                    isRecording = false;
                    stopWaveform();
                    stream.getTracks().forEach(track => track.stop());
                    
                    const recordBtnText = recordBtn.querySelector('.text');
                    recordBtnText.textContent = '';
                    recordBtnText.classList.add('hidden');
                    recordBtn.querySelector('.icon').classList.remove('hidden');
                    recordBtn.classList.remove('is-recording');

                    if (soundDetected) {
                        analyzeAudio(new Blob(audioChunks, { type: 'audio/webm' }));
                    } else {
                        showMessage("PrAI không phát hiện thấy âm thanh. Vui lòng thử ghi âm lại nhé.", "error");
                    }
                };
                mediaRecorder.start();
                startWaveform(stream);
                const recordBtnText = recordBtn.querySelector('.text');
                recordBtnText.textContent = 'Dừng';
                recordBtnText.classList.remove('hidden');
                recordBtn.querySelector('.icon').classList.add('hidden');
                recordBtn.classList.add('is-recording');
            } catch (error) {
                console.error("Error accessing microphone:", error);
                showMessage('Không thể truy cập micro. Vui lòng cấp quyền và thử lại.', 'error');
            }
        }

        function handleListenAgain() {
            if (lastRecordingBlob) {
                const audioUrl = URL.createObjectURL(lastRecordingBlob);
                replayAudio.src = audioUrl;
                replayAudio.play();
            }
        }

        function startWaveform(stream) {
            uploadBtn.style.display = 'none';
            listenAgainBtn.style.display = 'none';
            waveformContainer.classList.remove('hidden');
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const computedStyle = getComputedStyle(document.documentElement);
            const accentPrimaryColor = computedStyle.getPropertyValue('--accent-primary').trim();
            const accentSuccessColor = computedStyle.getPropertyValue('--accent-success').trim();

            const canvas = waveformEl;
            const canvasCtx = canvas.getContext('2d');

            function draw() {
                waveformAnimationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                const averageVolume = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                if (averageVolume > 15) {
                    soundDetected = true;
                }
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 1.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2.5;
                    const gradient = canvasCtx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                    gradient.addColorStop(0, accentPrimaryColor);
                    gradient.addColorStop(1, accentSuccessColor);
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function stopWaveform() {
            if (waveformAnimationId) cancelAnimationFrame(waveformAnimationId);
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            uploadBtn.style.display = 'inline-flex';
            listenAgainBtn.style.display = 'inline-flex';
            waveformContainer.classList.add('hidden');
        }

        function getHistory() {
            return JSON.parse(localStorage.getItem('prai-history') || '[]');
        }

        function saveToHistory(text, score) {
            if (!text) return;
            let history = getHistory();
            const now = new Date();
            const newEntry = { text, score, date: now.toISOString() };
            history = history.filter(item => item.text !== text);
            history.unshift(newEntry);
            if (history.length > 20) {
                history = history.slice(0, 20);
            }
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }

        function loadHistory() {
            const history = getHistory();
            historyList.innerHTML = '';
            if (history.length === 0) {
                historyList.innerHTML = `<p class="text-text-secondary text-center italic">Chưa có lịch sử luyện tập.</p>`;
                clearHistoryBtn.classList.add('hidden');
                return;
            }
            clearHistoryBtn.classList.remove('hidden');
            history.forEach(item => {
                const scoreColor = item.score > 85 ? 'bg-green-500/20 text-green-600 dark:text-green-400' : item.score > 70 ? 'bg-yellow-500/20 text-yellow-600 dark:text-yellow-400' : 'bg-red-500/20 text-red-600 dark:text-red-400';
                const itemEl = document.createElement('div');
                itemEl.className = 'history-item flex justify-between items-center p-2 rounded-md';
                itemEl.innerHTML = `
                    <div class="flex-grow truncate pr-4" data-action="select">
                        <p class="truncate history-item-text">${item.text}</p>
                    </div>
                    <div class="flex items-center gap-3 flex-shrink-0">
                        <div class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-xl ${scoreColor}">
                           ${item.score}
                        </div>
                        <button class="btn btn-secondary btn-icon !w-8 !h-8 text-accent-danger/70 hover:!bg-accent-danger/20" data-action="delete">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                        </button>
                    </div>
                `;
                itemEl.dataset.text = item.text;
                historyList.appendChild(itemEl);
            });
        }
        
        function deleteHistoryItem(textToDelete) {
            let history = getHistory();
            history = history.filter(item => item.text !== textToDelete);
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }

        function clearHistory() {
            localStorage.removeItem('prai-history');
            loadHistory();
        }
        
        function handleHistoryClick(event) {
            const target = event.target.closest('[data-action]');
            if (!target) return;
            
            const action = target.dataset.action;
            const parentItem = target.closest('.history-item');
            const text = parentItem.dataset.text;

            if (action === 'select') {
                textInput.value = text;
                charCounter.textContent = `${text.length} / 150`;
                historyModal.classList.remove('is-visible');
                resetAll();
                fetchAndDisplayIPA();
            } else if (action === 'delete') {
                deleteHistoryItem(text);
            }
        }
        
        // --- NEW HELPER FUNCTIONS ---
        function animateValue(obj, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerHTML = Math.floor(progress * (end - start) + start);
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        }
        
        function renderIntonationChart(svgElement, modelData, userData) {
            svgElement.innerHTML = ''; // Clear previous chart
            if (!modelData || !userData || modelData.length === 0 || userData.length === 0) return;
        
            const padding = { top: 10, right: 10, bottom: 20, left: 10 };
            const width = svgElement.clientWidth;
            const height = svgElement.clientHeight;
            const innerWidth = width - padding.left - padding.right;
            const innerHeight = height - padding.top - padding.bottom;
        
            const allData = [...modelData, ...userData];
            const yMin = Math.min(...allData);
            const yMax = Math.max(...allData) > yMin ? Math.max(...allData) : yMin + 1; // Avoid division by zero
            
            const scaleX = (index, dataLength) => padding.left + (index / (dataLength - 1)) * innerWidth;
            const scaleY = (value) => padding.top + innerHeight - ((value - yMin) / (yMax - yMin)) * innerHeight;
        
            const modelPoints = modelData.map((d, i) => `${scaleX(i, modelData.length)},${scaleY(d)}`).join(' ');
            const userPoints = userData.map((d, i) => `${scaleX(i, userData.length)},${scaleY(d)}`).join(' ');
        
            const modelLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            modelLine.setAttribute('points', modelPoints);
            modelLine.setAttribute('fill', 'none');
            modelLine.setAttribute('stroke', 'var(--accent-primary)');
            modelLine.setAttribute('stroke-width', '2');
            
            const userLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            userLine.setAttribute('points', userPoints);
            userLine.setAttribute('fill', 'none');
            userLine.setAttribute('stroke', 'var(--accent-warning)');
            userLine.setAttribute('stroke-width', '2.5');
            userLine.setAttribute('stroke-dasharray', '4 4');
        
            svgElement.appendChild(modelLine);
            svgElement.appendChild(userLine);
            
            // Add Legend
            const legend = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            legend.innerHTML = `
                <rect x="${innerWidth - 180}" y="${height - 15}" width="12" height="2" fill="var(--accent-primary)" />
                <text x="${innerWidth - 165}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng mẫu</text>
                <rect x="${innerWidth - 90}" y="${height - 15}" width="12" height="2" fill="var(--accent-warning)" stroke-dasharray="2 2" stroke="var(--accent-warning)" />
                <text x="${innerWidth - 75}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng của bạn</text>
            `;
            svgElement.appendChild(legend);
        }

        function initApp() {
            accentSelect.value = 'British English';

            textInput.addEventListener('input', () => {
                const currentLength = textInput.value.length;
                const maxLength = textInput.getAttribute('maxlength');
                charCounter.textContent = `${currentLength} / ${maxLength}`;
                resetAll();
            });
            accentSelect.addEventListener('change', () => {
                if (textInput.value.trim()) {
                    resetAll();
                    fetchAndDisplayIPA();
                }
            });
            transcribeBtn.addEventListener('click', () => fetchAndDisplayIPA());
            listenNaturalBtn.addEventListener('click', (e) => handleListen('natural', listenNaturalBtn, listenNaturalLoader));
            listenClearBtn.addEventListener('click', (e) => handleListen('clear', listenClearBtn, listenClearLoader));
            recordBtn.addEventListener('click', handleRecord);
            listenAgainBtn.addEventListener('click', handleListenAgain);
            randomPracticeBtn.addEventListener('click', () => {
                const randomSentence = practiceSentences[Math.floor(Math.random() * practiceSentences.length)];
                textInput.value = randomSentence;
                charCounter.textContent = `${randomSentence.length} / 150`;
                resetAll();
                fetchAndDisplayIPA();
            });
            uploadBtn.addEventListener('click', () => audioUploadInput.click());

            historyBtn.addEventListener('click', () => {
                loadHistory();
                historyModal.classList.add('is-visible');
            });
            closeHistoryBtn.addEventListener('click', () => historyModal.classList.remove('is-visible'));
            historyModal.addEventListener('click', (e) => {
                if (e.target === historyModal) {
                    historyModal.classList.remove('is-visible');
                }
            });
            clearHistoryBtn.addEventListener('click', clearHistory);
            historyList.addEventListener('click', handleHistoryClick);

            phonemeAnalysis.addEventListener('mouseover', (e) => {
                const phonemeEl = e.target.closest('.has-tooltip');
                if (!phonemeEl) return;
                const tooltip = phonemeEl.querySelector('.tooltip');
                if (!tooltip) return;

                const rect = phonemeEl.getBoundingClientRect();
                const viewportWidth = window.innerWidth;

                tooltip.style.left = '50%';
                tooltip.style.transform = 'translate(-50%, -5px)';

                if (rect.left < 120) { 
                    tooltip.style.left = '0';
                    tooltip.style.transform = 'translate(0, -5px)';
                } else if (rect.right > viewportWidth - 120) { 
                    tooltip.style.left = 'auto';
                    tooltip.style.right = '0';
                    tooltip.style.transform = 'translate(0, -5px)';
                }
            });


            audioUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('audio/')) {
                    const ipaReadyCheck = async () => {
                        if (!textInput.value.trim()) {
                            showMessage('Vui lòng nhập văn bản tương ứng với file âm thanh trước.', 'warning');
                            return;
                        }
                        resetAnalysisOnly(); 
                        let ipaReady = !!standardIPA;
                        if (!ipaReady) {
                            ipaReady = await fetchAndDisplayIPA();
                        }
                        if (!ipaReady) {
                            showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                            return;
                        }
                        analysisRequestID++;
                        analyzeAudio(file);
                    };
                    ipaReadyCheck();
                } else if (file) {
                    showMessage('Vui lòng chọn một tệp âm thanh hợp lệ.', 'warning');
                }
                event.target.value = null;
            });

            textInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    fetchAndDisplayIPA();
                }
            });
        }

        initApp();
    </script>
</body>
</html>
