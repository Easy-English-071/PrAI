<!DOCTYPE html>
<html lang="vi" data-theme="light"> <!-- Default to light theme -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrAI - Luyện Phát Âm với AI</title>
    <!-- NEW FAVICON -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23007CF0;'/%3E%3Cstop offset='100%25' style='stop-color:%2300DFD8;'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3Ctext x='50' y='55' font-family='Exo 2, sans-serif' font-size='40' font-weight='700' fill='white' text-anchor='middle' dominant-baseline='middle'%3EPrAI%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans:wght@400;700&family=Exo+2:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- GLASSMORPHISM THEME V11 --- */
        :root {
            /* Default: Light Theme */
            --bg-color: #f8fafc; /* slate-50 */
            --bg-blob-1: #0ea5e9; /* sky-500 */
            --bg-blob-2: #14b8a6; /* teal-500 */
            --glass-bg: rgba(248, 250, 252, 0.6); /* slate-50 @ 60% */
            --glass-border: rgba(255, 255, 255, 0.7); /* Brighter border for glass edge effect */
            --text-primary: #0f172a; /* slate-900 */
            --text-secondary: #475569; /* slate-600 */
            --accent-primary: #007CF0;
            --accent-danger: #ef4444; /* red-500 */
            --accent-success: #22c55e; /* green-500 */
            --accent-warning: #f59e0b; /* amber-500 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0056b3;
            --btn-secondary-bg: rgba(241, 245, 249, 0.7); /* slate-100 @ 70% */
            --btn-secondary-hover-bg: rgba(226, 232, 240, 0.9); /* slate-200 @ 90% */
            --input-bg: rgba(255, 255, 255, 0.4);
            --input-focus-bg: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(100, 116, 139, 0.2); /* slate-400 */
            --highlight-correct: rgba(34, 197, 94, 0.1);
            --highlight-approximate: rgba(245, 158, 11, 0.1);
            --highlight-incorrect: rgba(239, 68, 68, 0.1);
            --radius-sm: 0.75rem;
            --radius-md: 1rem;
            --radius-lg: 1.5rem;
        }

        [data-theme="dark"] {
            --bg-color: #020617; /* slate-950 */
            --bg-blob-1: #0369a1; /* cyan-700 */
            --bg-blob-2: #0d9488; /* teal-600 */
            --glass-bg: rgba(30, 41, 59, 0.5); /* slate-800 @ 50% */
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #f1f5f9; /* slate-100 */
            --text-secondary: #94a3b8; /* slate-400 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0095ff;
            --btn-secondary-bg: rgba(51, 65, 85, 0.5); /* slate-700 @ 50% */
            --btn-secondary-hover-bg: rgba(51, 65, 85, 0.8);
            --input-bg: rgba(15, 23, 42, 0.5); /* slate-900 @ 50% */
            --input-focus-bg: rgba(15, 23, 42, 0.7);
            --shadow-color: rgba(0, 0, 0, 0.35);
            --highlight-correct: rgba(74, 222, 128, 0.15);
            --highlight-approximate: rgba(250, 204, 21, 0.15);
            --highlight-incorrect: rgba(248, 113, 113, 0.15);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
        }
        
        .background-container {
            width: 100%; height: 100%; position: fixed;
            top: 0; left: 0; z-index: -1; overflow: hidden;
        }
        .blob { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.4; }
        .blob-1 { width: 450px; height: 450px; background: var(--bg-blob-1); animation: move 20s infinite alternate; }
        .blob-2 { width: 350px; height: 350px; background: var(--bg-blob-2); animation: move 25s infinite alternate-reverse; animation-delay: -5s; }

        @keyframes move {
            from { transform: translate(-15vw, -15vh) scale(1) rotate(0deg); }
            to { transform: translate(65vw, 75vh) scale(1.2) rotate(180deg); }
        }

        .font-logo { font-family: 'Exo 2', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text, .phoneme, .ipa-text { font-family: 'Noto Sans', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text { word-break: break-word; }

        .glass-card {
            background-color: var(--glass-bg);
            backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
            box-shadow: 0 8px 32px 0 var(--shadow-color), inset 0 1px 0 0 var(--glass-border);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease-in-out;
        }

        .main-card { padding: clamp(1rem, 5vw, 2.5rem); }
        .card-layer { padding: 1.5rem; border-radius: var(--radius-md); }
        .card-layer-inset {
            background-color: var(--input-bg); padding: 1rem; border-radius: var(--radius-md);
            border: 1px solid var(--glass-border); box-shadow: inset 0 2px 4px var(--shadow-color);
        }

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: var(--radius-sm); font-weight: 600;
            border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px var(--shadow-color);
        }
        .btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px var(--shadow-color); }
        .btn:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 10px var(--shadow-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--btn-primary-bg); color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .btn-primary:hover:not(:disabled) { background-color: var(--btn-primary-hover-bg); }

        .btn-secondary {
            background-color: var(--btn-secondary-bg); color: var(--text-secondary);
            border: 1px solid var(--glass-border); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        .btn-secondary:hover:not(:disabled) { background-color: var(--btn-secondary-hover-bg); color: var(--text-primary); }

        .btn-icon {
            width: 2.75rem; height: 2.75rem; border-radius: 50%;
            padding: 0; flex-shrink: 0; position: relative;
            display: inline-flex; align-items: center; justify-content: center;
        }
        .btn-icon > .icon { margin: auto; }
        
        .btn-record {
            width: 7rem; height: 7rem; border-radius: 50%;
            background: radial-gradient(circle, #ff5f5f 0%, #ef4444 100%);
            color: #ffffff; font-weight: 600; cursor: pointer;
            box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
            border: 3px solid rgba(255, 255, 255, 0.4);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .btn-record:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 15px 30px color-mix(in srgb, var(--accent-danger) 40%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2); }
        .btn-record.is-recording { animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 70%, transparent); }
            70% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 15px color-mix(in srgb, var(--accent-danger) 0%, transparent); }
            100% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 0%, transparent); }
        }
        
        .input-field {
            width: 100%; background-color: var(--input-bg); border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm); padding: 0.75rem 1rem; color: var(--text-primary);
            transition: all 0.2s ease-in-out; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .input-field:focus {
            outline: none; border-color: var(--accent-primary); background-color: var(--input-focus-bg);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }
        textarea.input-field { resize: vertical; min-height: 80px; }

        .phoneme {
            padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 1.125rem;
            position: relative; transition: all 0.2s ease-in-out; color: var(--text-secondary);
        }
        .phoneme.status-correct { background-color: var(--highlight-correct); color: var(--accent-success); }
        .phoneme.status-approximate { background-color: var(--highlight-approximate); color: var(--accent-warning); }
        .phoneme.status-incorrect { background-color: var(--highlight-incorrect); color: var(--accent-danger); }

        .tooltip {
            visibility: hidden; opacity: 0; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translate(-50%, 10px); background-color: var(--bg-color); color: var(--text-primary);
            border: 1px solid var(--glass-border); z-index: 20;
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 0.5rem;
            width: 256px;
            border-radius: 0.75rem;
            padding: 0.75rem;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .has-tooltip:hover .tooltip { 
             visibility: visible; 
             opacity: 1; 
        }
        
        .score-container {
            width: 140px; height: 140px; margin: 1rem auto; display: flex; align-items: center; justify-content: center;
            transition: all 0.5s ease-out; border-radius: 50%; border: 4px solid transparent;
            background: radial-gradient(circle, color-mix(in srgb, var(--accent-primary) 10%, transparent) 0%, rgba(74, 128, 240, 0) 70%);
        }
        .score-container.score-high { border-color: var(--accent-success); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-success) 50%, transparent); }
        .score-container.score-medium { border-color: var(--accent-warning); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-warning) 50%, transparent); }
        .score-container.score-low { border-color: var(--accent-danger); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-danger) 50%, transparent); }
        
        #overall-score { font-size: 3.5rem; font-weight: 700; color: var(--text-primary); transition: color 0.5s ease-out; }
        .score-high #overall-score { color: var(--accent-success); }
        .score-medium #overall-score { color: var(--accent-warning); }
        .score-low #overall-score { color: var(--accent-danger); }

        #detailed-ipa-text { color: var(--accent-primary); }
        
        .thought-group {
            padding: 0.25rem 0.75rem; border-radius: 0.5rem; margin: 0.1rem;
            display: inline-block; transition: background-color 0.3s;
        }
        [data-theme="dark"] .thought-group-0 { background-color: rgba(96, 165, 250, 0.2); color: #bfdbfe; } /* blue */
        [data-theme="dark"] .thought-group-1 { background-color: rgba(52, 211, 153, 0.2); color: #a7f3d0; } /* emerald */
        [data-theme="dark"] .thought-group-2 { background-color: rgba(250, 204, 21, 0.2); color: #fef08a; } /* yellow */
        [data-theme="dark"] .thought-group-3 { background-color: rgba(192, 132, 252, 0.2); color: #e9d5ff; } /* purple */
        [data-theme="light"] .thought-group-0 { background-color: rgba(59, 130, 246, 0.15); color: #1e40af; }
        [data-theme="light"] .thought-group-1 { background-color: rgba(16, 185, 129, 0.15); color: #065f46; }
        [data-theme="light"] .thought-group-2 { background-color: rgba(245, 158, 11, 0.15); color: #92400e; }
        [data-theme="light"] .thought-group-3 { background-color: rgba(168, 85, 247, 0.15); color: #6b21a8; }
        
        .btn-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .fade-in { animation: fadeIn 0.6s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.is-visible {
            opacity: 1; visibility: visible;
        }
        .modal-container {
            width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .modal-overlay.is-visible .modal-container {
            transform: scale(1);
        }
        .history-item { cursor: pointer; transition: background-color 0.2s; }
        .history-item:hover { background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); }
        .history-item-text { color: var(--text-primary); }

        /* --- NEW ANALYSIS UI STYLES --- */
        .analysis-box-detailed {
            background-color: color-mix(in srgb, var(--input-bg) 60%, transparent);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1.25rem;
            box-shadow: inset 0 2px 4px color-mix(in srgb, var(--shadow-color) 50%, transparent);
        }

        .analysis-title {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .intonation-chart-container {
            width: 100%;
            height: 180px; /* Increased height for stressed words */
            background-color: var(--input-bg);
            border-radius: var(--radius-sm);
            padding: 0.5rem;
            border: 1px solid var(--glass-border);
            margin-bottom: 1rem;
        }

        /* NEW: Syllable Chart Styles */
        .syllable-chart-container {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            padding: 1rem 0;
        }
        .syllable {
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius-sm);
            font-size: 1.125rem;
            font-weight: 500;
            border: 2px solid var(--glass-border);
            background-color: var(--input-bg);
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }
        .syllable.stressed {
            font-weight: 700;
            border-color: var(--accent-primary);
            background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            color: var(--accent-primary);
            transform: scale(1.1);
            box-shadow: 0 0 15px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }


        .connected-speech-item {
            padding: 1rem;
            border-radius: var(--radius-sm);
            border-left: 4px solid;
            position: relative;
            margin-bottom: 0.75rem;
            background-color: var(--input-bg);
            transition: all 0.2s ease-in-out;
        }
        
        /* FIXED: Connected Speech Type Classes */
        .connected-speech-item.type-linking { border-left-color: var(--accent-primary); }
        .connected-speech-item.type-assimilation { border-left-color: var(--accent-success); }
        .connected-speech-item.type-elision { border-left-color: var(--accent-warning); }
        .connected-speech-item.type-intrusion { border-left-color: var(--accent-danger); }
        .connected-speech-item.type-weak-forms { border-left-color: #8b5cf6; }
        .connected-speech-item.type-contraction { border-left-color: #06b6d4; }
        
        .cs-title { font-weight: 600; color: var(--text-primary); }
        .cs-details { color: var(--text-secondary); font-size: 0.875rem; }
        .cs-location { font-weight: 500; color: var(--accent-primary); }
        .cs-feedback { color: var(--text-secondary); margin-top: 0.5rem; }
    </style>
</head>
<body>
    <div class="background-container">
        <div class="blob blob-1"></div>
        <div class="blob blob-2"></div>
    </div>

    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="text-center mb-8">
            <div class="flex items-center justify-center gap-4 mb-4">
                <div class="w-16 h-16 bg-gradient-to-br from-blue-500 to-teal-400 rounded-2xl flex items-center justify-center shadow-lg">
                    <span class="text-white font-logo text-2xl font-bold">PrAI</span>
                </div>
                <div class="text-left">
                    <h1 class="text-4xl font-bold text-text-primary">PrAI</h1>
                    <p class="text-text-secondary">Luyện phát âm với AI</p>
                </div>
                <button id="theme-toggle" class="btn btn-icon btn-secondary ml-auto">
                    <svg id="theme-icon-light" class="w-5 h-5 icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
                    </svg>
                    <svg id="theme-icon-dark" class="w-5 h-5 icon hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>
                    </svg>
                </button>
            </div>
        </header>

        <main class="glass-card main-card">
            <div class="space-y-6">
                <!-- Input Section -->
                <div class="card-layer glass-card">
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <h2 class="text-xl font-semibold text-text-primary">Nhập văn bản</h2>
                            <div class="flex gap-2">
                                <button id="history-btn" class="btn btn-icon btn-secondary" title="Lịch sử">
                                    <svg class="w-5 h-5 icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                </button>
                                <button id="random-practice-btn" class="btn btn-secondary">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                    <span class="text">Câu ngẫu nhiên</span>
                                </button>
                            </div>
                        </div>
                        
                        <div class="space-y-3">
                            <textarea id="text-input" class="input-field" placeholder="Nhập từ hoặc câu tiếng Anh bạn muốn luyện phát âm..." maxlength="150"></textarea>
                            <div class="flex justify-between items-center text-sm text-text-secondary">
                                <span id="char-counter">0 / 150</span>
                                <select id="accent-select" class="input-field w-auto">
                                    <option value="American English">Giọng Mỹ</option>
                                    <option value="British English">Giọng Anh</option>
                                </select>
                            </div>
                        </div>
                        
                        <button id="transcribe-btn" class="btn btn-primary w-full">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span class="text">Phiên âm</span>
                            <svg class="w-4 h-4 btn-spinner hidden" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- IPA Display Section -->
                <div class="card-layer glass-card">
                    <div class="space-y-4">
                        <h3 class="text-lg font-semibold text-text-primary">Phiên âm IPA</h3>
                        
                        <div class="card-layer-inset">
                            <div class="text-center">
                                <div class="text-2xl font-medium text-text-primary mb-2" id="simple-ipa-text">/ ... /</div>
                                <div id="detailed-ipa-container" class="flex flex-col items-center space-y-2" style="display: none;">
                                    <div class="text-lg" id="detailed-ipa-text">[ ... ]</div>
                                    <div id="thought-group-display" class="text-sm">...</div>
                                </div>
                            </div>
                        </div>
                        
                        <div id="thought-group-info" class="text-sm text-text-secondary text-center hidden">
                            <div id="thought-group-tooltip"></div>
                        </div>
                    </div>
                </div>

                <!-- Controls Section -->
                <div id="controls-section" class="card-layer glass-card hidden">
                    <div class="space-y-4">
                        <h3 class="text-lg font-semibold text-text-primary">Nghe & Ghi âm</h3>
                        
                        <div class="flex flex-wrap gap-3 justify-center">
                            <div class="relative">
                                <button id="listen-natural-btn" class="btn btn-secondary">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142M6.343 6.343L4.93 4.93A1 1 0 003.515 6.343L6.343 9.17 9.17 6.343a1 1 0 00-1.414-1.414L6.343 6.343z"></path>
                                    </svg>
                                    <span class="text">Nghe tự nhiên</span>
                                </button>
                                <div id="listen-natural-loader" class="absolute inset-0 btn btn-secondary hidden">
                                    <svg class="w-4 h-4 btn-spinner" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                </div>
                            </div>
                            
                            <div class="relative">
                                <button id="listen-clear-btn" class="btn btn-secondary">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 14.142"></path>
                                    </svg>
                                    <span class="text">Nghe rõ ràng</span>
                                </button>
                                <div id="listen-clear-loader" class="absolute inset-0 btn btn-secondary hidden">
                                    <svg class="w-4 h-4 btn-spinner" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div id="record-controls" class="text-center space-y-4">
                            <button id="record-btn" class="btn-record">
                                <svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24">
                                    <circle cx="12" cy="12" r="8"></circle>
                                </svg>
                            </button>
                            <div class="flex gap-2 justify-center">
                                <button id="upload-btn" class="btn btn-secondary">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                                    </svg>
                                    <span class="text">Tải file</span>
                                </button>
                                <button id="listen-again-btn" class="btn btn-secondary" disabled>
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                    <span class="text">Nghe lại</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Loading Section -->
                <div id="loader" class="card-layer glass-card text-center hidden">
                    <div class="space-y-4">
                        <div class="w-16 h-16 mx-auto">
                            <svg class="w-full h-full btn-spinner text-accent-primary" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                        </div>
                        <div>
                            <p id="progress-text" class="text-lg font-medium text-text-primary mb-2">Đang xử lý...</p>
                            <div class="w-full bg-input-bg rounded-full h-2 mb-4">
                                <div id="progress-bar-inner" class="bg-accent-primary h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                            <p id="fun-fact" class="text-sm text-text-secondary italic hidden"></p>
                        </div>
                    </div>
                </div>

                <!-- Analysis Results -->
                <div id="analysis-results" class="space-y-6 hidden">
                    <!-- Score Display -->
                    <div class="card-layer glass-card text-center">
                        <h3 class="text-xl font-semibold text-text-primary mb-4">Kết quả phân tích</h3>
                        <div class="score-container">
                            <div id="overall-score" class="text-6xl font-bold">0</div>
                        </div>
                        <p class="text-text-secondary">Điểm tổng thể</p>
                    </div>

                    <!-- Phoneme Analysis -->
                    <div class="card-layer glass-card">
                        <h4 class="text-lg font-semibold text-text-primary mb-4">Phân tích từng âm</h4>
                        <div id="phoneme-analysis" class="flex flex-wrap gap-2 justify-center"></div>
                    </div>

                    <!-- NEW: Prosody Analysis Section -->
                    <div id="prosody-analysis-container" class="card-layer glass-card" style="display: none;">
                        <h4 id="prosody-analysis-title" class="analysis-title">Phân tích Ngữ điệu</h4>
                        
                        <!-- Intonation Analysis (for sentences) -->
                        <div id="intonation-analysis-content" style="display: none;">
                            <div class="intonation-chart-container">
                                <svg id="intonation-chart" width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
                            </div>
                            <p id="intonation-analysis-feedback" class="text-sm text-text-secondary"></p>
                        </div>
                        
                        <!-- Syllable Analysis (for single words) -->
                        <div id="syllable-analysis-content" style="display: none;">
                            <div id="syllable-chart-container" class="syllable-chart-container"></div>
                            <p id="syllable-analysis-feedback" class="text-sm text-text-secondary"></p>
                        </div>
                    </div>

                    <!-- Connected Speech Analysis -->
                    <div id="connected-speech-container" class="card-layer glass-card" style="display: none;">
                        <h4 class="text-lg font-semibold text-text-primary mb-4">Phân tích nối âm</h4>
                        <div id="connected-speech-analysis"></div>
                    </div>

                    <!-- Practice Suggestions -->
                    <div id="practice-suggestions" class="card-layer glass-card hidden">
                        <h4 class="text-lg font-semibold text-text-primary mb-4">Gợi ý luyện tập</h4>
                        <div id="suggestion-links" class="flex gap-3"></div>
                    </div>
                </div>
            </div>
        </main>

        <!-- History Modal -->
        <div id="history-modal" class="modal-overlay">
            <div class="modal-container">
                <div class="glass-card p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-semibold text-text-primary">Lịch sử luyện tập</h3>
                        <button id="close-history-btn" class="btn btn-icon btn-secondary">
                            <svg class="w-5 h-5 icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="history-list" class="space-y-2 max-h-60 overflow-y-auto"></div>
                    <button id="clear-history-btn" class="btn btn-secondary w-full mt-4">Xóa tất cả lịch sử</button>
                </div>
            </div>
        </div>

        <div id="message-box" class="fixed bottom-5 right-5 hidden p-4 rounded-xl text-sm z-50 shadow-lg glass-card"></div>
        <audio id="replay-audio" class="hidden"></audio>
        <input type="file" id="audio-upload-input" class="hidden" accept="audio/*">

        <footer class="text-center mt-8 text-text-secondary text-sm">
            <p>© 2025 PrAI. Được tạo ra với niềm đam mê ngôn ngữ bởi Mr Bảo.</p>
        </footer>
    </div>

    <script type="module">
        // --- THEME SWITCHER LOGIC ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const docElement = document.documentElement;

        function applyTheme(theme) {
            docElement.setAttribute('data-theme', theme);
            if (theme === 'light') {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
            localStorage.setItem('prai-theme', theme);
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = docElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        });

        const savedTheme = localStorage.getItem('prai-theme') || 'light';
        applyTheme(savedTheme);


        // --- APP LOGIC ---
        const textInput = document.getElementById('text-input');
        const accentSelect = document.getElementById('accent-select');
        const transcribeBtn = document.getElementById('transcribe-btn');
        const listenNaturalBtn = document.getElementById('listen-natural-btn');
        const listenClearBtn = document.getElementById('listen-clear-btn');
        const listenClearLoader = document.getElementById('listen-clear-loader');
        const listenNaturalLoader = document.getElementById('listen-natural-loader');
        const recordControls = document.getElementById('record-controls');
        const uploadBtn = document.getElementById('upload-btn');
        const recordBtn = document.getElementById('record-btn');
        const listenAgainBtn = document.getElementById('listen-again-btn');
        const randomPracticeBtn = document.getElementById('random-practice-btn');
        const controlsSection = document.getElementById('controls-section');
        const loader = document.getElementById('loader');
        const simpleIpaText = document.getElementById('simple-ipa-text');
        const detailedIpaText = document.getElementById('detailed-ipa-text');
        const analysisResults = document.getElementById('analysis-results');
        const overallScore = document.getElementById('overall-score');
        const phonemeAnalysis = document.getElementById('phoneme-analysis');
        const practiceSuggestions = document.getElementById('practice-suggestions');
        const suggestionLinks = document.getElementById('suggestion-links');
        const messageBox = document.getElementById('message-box');
        const waveformContainer = document.getElementById('waveform-container');
        const waveformEl = document.getElementById('waveform');
        const replayAudio = document.getElementById('replay-audio');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const funFactEl = document.getElementById('fun-fact');
        const connectedSpeechAnalysis = document.getElementById('connected-speech-analysis');
        const progressText = document.getElementById('progress-text');
        const progressBarInner = document.getElementById('progress-bar-inner');
        const charCounter = document.getElementById('char-counter');
        const thoughtGroupDisplay = document.getElementById('thought-group-display');
        const thoughtGroupInfo = document.getElementById('thought-group-info');
        const thoughtGroupTooltip = document.getElementById('thought-group-tooltip');
        const detailedIpaContainer = document.getElementById('detailed-ipa-container');
        
        // NEW ANALYSIS SECTION ELEMENTS
        const prosodyAnalysisContainer = document.getElementById('prosody-analysis-container');
        const prosodyAnalysisTitle = document.getElementById('prosody-analysis-title');
        const intonationAnalysisContent = document.getElementById('intonation-analysis-content');
        const syllableAnalysisContent = document.getElementById('syllable-analysis-content');
        const syllableChartContainer = document.getElementById('syllable-chart-container');
        const syllableAnalysisFeedback = document.getElementById('syllable-analysis-feedback');
        const intonationAnalysisFeedback = document.getElementById('intonation-analysis-feedback');
        const intonationChart = document.getElementById('intonation-chart');
        const connectedSpeechContainer = document.getElementById('connected-speech-container');

        const historyBtn = document.getElementById('history-btn');
        const historyModal = document.getElementById('history-modal');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const historyList = document.getElementById('history-list');
        const clearHistoryBtn = document.getElementById('clear-history-btn');

        // --- STATE MANAGEMENT ---
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let standardIPA = '';
        let audioContext;
        let analyser;
        let waveformAnimationId;
        let lastRecordingBlob = null;
        let soundDetected = false;
        let ipaLoadingInterval;
        let fetchIpaRequestID = 0;
        let analysisRequestID = 0;
        let progressInterval;
        let progressTextTimeoutIds = [];
        let currentIpaData = {};
        
        // NEW: State to differentiate analysis modes
        let isSingleWordMode = false;

        // --- ENHANCED CACHING SYSTEM ---
        const ipaCache = {
            get(key) { try { const i = localStorage.getItem(key); return i ? JSON.parse(i) : null; } catch (e) { return null; } },
            set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error("Cache write error:", e); } }
        };
        
        // FIXED: Robust model pronunciation data caching
        let modelPronunciationCache = new Map();
        let clearPronunciationCache = new Map();

        const funFacts = [
            "'Ough' có thể được phát âm theo 10 cách khác nhau.",
            "Âm câm (silent letters) là di tích lịch sử từ các ngôn ngữ khác.",
            "'Pronunciation' (phát âm) trớ trêu lại là từ bị phát âm sai nhiều nhất.",
            "Tiếng Anh có tới 20 âm nguyên âm theo hệ thống IPA, nhiều hơn hầu hết các ngôn ngữ khác.",
            "'Strengths' là từ dài nhất chỉ có một nguyên âm.",
        ];

        const practiceSentences = [
            "What are you doing?", "It's a piece of cake.", "I'll call you back later.",
            "How's it going?", "Can I have a bottle of water, please?", "It's a beautiful day, isn't it?",
            "I'm looking forward to it.", "Could you please repeat that?", "Where is the nearest station?",
        ];

        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        // API URLS POINT TO THE PROXY FUNCTION
        const TEXT_API_URL = `/api/proxy`;
        const TTS_API_URL = `/api/proxy`;

        function showMessage(message, type = 'info') {
            const typeClasses = {
                'info': 'text-blue-300 border-accent-primary/30',
                'success': 'text-green-300 border-accent-success/30',
                'warning': 'text-yellow-300 border-accent-warning/30',
                'error': 'text-red-300 border-accent-danger/30'
            };
            messageBox.className = `fixed bottom-5 right-5 p-4 rounded-xl text-sm z-50 shadow-lg glass-card fade-in ${typeClasses[type]}`;
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('hidden'), 5000);
        }

        function handleApiError(error) {
            console.error("API Error:", error);
            if (error.message && (error.message.includes('429') || error.message.toLowerCase().includes('quota'))) {
                showMessage('Hệ thống đang bận. Bạn vui lòng thử lại sau nhé.', 'error');
            } else {
                showMessage(`Đã xảy ra lỗi kết nối: ${error.message}`, 'error');
            }
        }

        function setButtonLoading(button, loader, isLoading) {
            button.disabled = isLoading;
            if (loader) { // Logic for icon buttons with separate loaders
                if(isLoading) {
                    button.classList.add('hidden');
                    loader.classList.remove('hidden');
                    loader.classList.add('flex');
                } else {
                    button.classList.remove('hidden');
                    loader.classList.add('hidden');
                    loader.classList.remove('flex');
                }
            } else { // Logic for buttons with internal spinners
                const textEl = button.querySelector('.text');
                const iconEl = button.querySelector('.icon');
                const spinnerEl = button.querySelector('.btn-spinner');
                if (isLoading) {
                    if (textEl) textEl.style.visibility = 'hidden';
                    if (iconEl) iconEl.style.visibility = 'hidden';
                    if (spinnerEl) spinnerEl.classList.remove('hidden');
                } else {
                    if (textEl) textEl.style.visibility = 'visible';
                    if (iconEl) iconEl.style.visibility = 'visible';
                    if (spinnerEl) spinnerEl.classList.add('hidden');
                }
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1, bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithBackoff(url, options, maxRetries = 4) {
             let delay = 1000;
             for (let i = 0; i < maxRetries; i++) {
                 try {
                     const response = await fetch(url, options);
                     if (response.status === 429 || response.status >= 500) {
                         if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after multiple retries.`);
                         await new Promise(resolve => setTimeout(resolve, delay));
                         delay *= 2; 
                         continue; 
                     }
                     if (!response.ok) {
                         const errorBody = await response.json().catch(() => ({}));
                         throw new Error(`API Error: ${response.status}. ${errorBody.error?.message || 'An unknown error occurred.'}`);
                     }
                     return await response.json();
                 } catch (error) {
                     if (i === maxRetries - 1) throw error;
                     await new Promise(resolve => setTimeout(resolve, delay));
                     delay *= 2;
                 }
             }
         }

        function startIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
            const symbols = ['ə', 'ʃ', 't', 'k', 'æ', 'iː', 'θ', 'ð', 'ŋ'];
            let i = 0;
            ipaLoadingInterval = setInterval(() => {
                const seq = Array(5).fill(0).map((_, j) => symbols[(i + j) % symbols.length]).join(' ');
                simpleIpaText.textContent = `/ ${seq} /`;
                if (!isSingleWordMode) {
                    detailedIpaText.textContent = `[ ${seq} ]`;
                    thoughtGroupDisplay.textContent = `...`;
                }
                i = (i + 1) % symbols.length;
            }, 100);
        }

        function stopIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
        }

        function displayIpaData(data) {
            currentIpaData = data;
            standardIPA = data.detailed;
            simpleIpaText.textContent = data.simple;

            // Toggle UI based on single word mode
            detailedIpaContainer.style.display = isSingleWordMode ? 'none' : 'flex';
            
            if (!isSingleWordMode) {
                detailedIpaText.textContent = data.detailed;
                displayThoughtGroups(data.thought_groups?.groups, data.thought_groups?.explanation);
            }
            controlsSection.classList.remove('hidden');
        }
        
        // FIXED: Detect single word mode more accurately
        function detectAnalysisMode(text) {
            const trimmed = text.trim();
            const wordCount = trimmed.split(/\s+/).length;
            const hasMultipleWords = wordCount > 1;
            const hasPunctuation = /[.!?,:;]/.test(trimmed);
            return !hasMultipleWords && !hasPunctuation;
        }
        
        // FIXED: Enhanced prefetching with proper caching
        async function prefetchModelPronunciation(text, accent) {
            const cacheKey = `${text}_${accent}`;
            if (modelPronunciationCache.has(cacheKey)) {
                return modelPronunciationCache.get(cacheKey);
            }
        
            try {
                const textWithPauses = currentIpaData.thought_groups?.groups.join(" | ") || text;
                const promptTTS = `Read ONLY the following text in ${accent}. The pipe symbol "|" indicates a slight, natural hesitation. Text: ${textWithPauses}`;
                
                const [ttsData, analysisData] = await Promise.all([
                    // Fetch TTS Audio
                    fetchWithBackoff(TTS_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: promptTTS }] }],
                            generationConfig: { responseModalities: ["AUDIO"] },
                            model: TTS_MODEL
                        })
                    }),
                    // Fetch Pitch Contour and Stressed Words
                    fetchWithBackoff(TEXT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: `Analyze the sentence "${text}". Provide a JSON object with 'pitch_contour' (an array of 40-50 normalized pitch points) and 'stressed_words' (an array of objects with 'word' and 'time_stamp_normalized' from 0.0 to 1.0).` }] }],
                            generationConfig: { responseMimeType: "application/json" }
                        })
                    })
                ]);

                const audioData = ttsData.candidates[0].content.parts[0].inlineData;
                const audio = await createAudioFromBase64(audioData.data, audioData.mimeType);
                const prosodyData = JSON.parse(analysisData.candidates[0].content.parts[0].text);
                
                const result = {
                    audio: audio,
                    pitchContour: prosodyData.pitch_contour || [],
                    stressedWords: prosodyData.stressed_words || []
                };
                
                modelPronunciationCache.set(cacheKey, result);
                return result;
            } catch (error) {
                console.error("Prefetch error:", error);
                return { audio: null, pitchContour: [], stressedWords: [] };
            }
        }

        // FIXED: Enhanced clear pronunciation caching
        async function prefetchClearPronunciation(text, accent) {
            const cacheKey = `clear_${text}_${accent}`;
            if (clearPronunciationCache.has(cacheKey)) {
                return clearPronunciationCache.get(cacheKey);
            }

            try {
                const promptTTS = `Read the following text very clearly and slowly in ${accent}, emphasizing each phoneme distinctly. Text: ${text}`;
                const ttsData = await fetchWithBackoff(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: promptTTS }] }],
                        generationConfig: { responseModalities: ["AUDIO"] },
                        model: TTS_MODEL
                    })
                });

                const audioData = ttsData.candidates[0].content.parts[0].inlineData;
                const audio = await createAudioFromBase64(audioData.data, audioData.mimeType);
                
                clearPronunciationCache.set(cacheKey, audio);
                return audio;
            } catch (error) {
                console.error("Clear pronunciation fetch error:", error);
                return null;
            }
        }

        async function fetchAndDisplayIPA() {
            const text = textInput.value.trim();
            if (!text) return;

            fetchIpaRequestID++;
            const currentRequestID = fetchIpaRequestID;

            // FIXED: Detect analysis mode early
            isSingleWordMode = detectAnalysisMode(text);

            const cacheKey = `ipa_${text}_${accentSelect.value}`;
            const cached = ipaCache.get(cacheKey);
            if (cached) {
                displayIpaData(cached);
                // FIXED: Prefetch model data for sentences immediately after IPA display
                if (!isSingleWordMode) {
                    prefetchModelPronunciation(text, accentSelect.value);
                }
                return;
            }

            setButtonLoading(transcribeBtn, null, true);
            startIpaLoadingAnimation();

            try {
                const prompt = isSingleWordMode 
                    ? `Provide IPA transcription for the single word "${text}" in ${accentSelect.value}. Return JSON with: simple (broad transcription), detailed (narrow transcription), syllable_structure (object with syllables array and stressed_syllable_index).`
                    : `Provide IPA transcription for "${text}" in ${accentSelect.value}. Return JSON with: simple (broad), detailed (narrow), thought_groups (object with groups array and explanation string).`;

                const data = await fetchWithBackoff(TEXT_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { responseMimeType: "application/json" }
                    })
                });

                if (currentRequestID !== fetchIpaRequestID) return;

                const ipaData = JSON.parse(data.candidates[0].content.parts[0].text);
                ipaCache.set(cacheKey, ipaData);
                displayIpaData(ipaData);
                
                // FIXED: Prefetch model data for sentences
                if (!isSingleWordMode) {
                    prefetchModelPronunciation(text, accentSelect.value);
                }
            } catch (error) {
                if (currentRequestID === fetchIpaRequestID) handleApiError(error);
            } finally {
                if (currentRequestID === fetchIpaRequestID) {
                    setButtonLoading(transcribeBtn, null, false);
                    stopIpaLoadingAnimation();
                }
            }
        }

        function displayThoughtGroups(groups, explanation) {
            if (!groups?.length) return;
            
            thoughtGroupDisplay.innerHTML = groups.map((group, i) => 
                `<span class="thought-group thought-group-${i % 4}">${group}</span>`
            ).join(' ');
            
            if (explanation) {
                thoughtGroupTooltip.textContent = explanation;
                thoughtGroupInfo.classList.remove('hidden');
            }
        }

        async function handleListen(type) {
            const text = textInput.value.trim();
            if (!text) return;

            const button = type === 'natural' ? listenNaturalBtn : listenClearBtn;
            const loader = type === 'natural' ? listenNaturalLoader : listenClearLoader;

            setButtonLoading(button, loader, true);

            try {
                if (type === 'natural' && !isSingleWordMode) {
                    // FIXED: Use cached model pronunciation for natural listening
                    const modelData = await prefetchModelPronunciation(text, accentSelect.value);
                    if (modelData.audio) {
                        modelData.audio.currentTime = 0;
                        modelData.audio.play();
                    } else {
                        throw new Error("Không thể tạo giọng đọc tự nhiên.");
                    }
                } else {
                    // FIXED: Use cached clear pronunciation
                    const clearAudio = await prefetchClearPronunciation(text, accentSelect.value);
                    if (clearAudio) {
                        clearAudio.currentTime = 0;
                        clearAudio.play();
                    } else {
                        throw new Error("Không thể tạo giọng đọc rõ ràng.");
                    }
                }
            } catch (error) {
                handleApiError(error);
            } finally {
                setButtonLoading(button, loader, false);
            }
        }
        
        async function createAudioFromBase64(base64Data, mimeType) {
            const sampleRate = mimeType.match(/rate=(\d+)/) ? parseInt(mimeType.match(/rate=(\d+)/)[1], 10) : 24000;
            const pcmData = base64ToArrayBuffer(base64Data);
            const pcm16 = new Int16Array(pcmData);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            return new Audio(audioUrl);
        }

        function startProgressSimulation() {
            let width = 0;
            progressBarInner.style.width = '0%';
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                width = Math.min(width + Math.random() * 2, 95);
                progressBarInner.style.width = width + '%';
            }, 100);
        }

        function stopProgressSimulation() {
            clearInterval(progressInterval);
            progressBarInner.style.width = '100%';
        }

        function startProgressTextAnimation() {
            const steps = [
                { text: "Okie, PrAI đã nhận được bản ghi âm của bạn...", duration: 1500 },
                { text: "Đang phiên âm giọng nói của bạn!", duration: 2500 },
                { text: "So sánh từng âm một với giọng chuẩn...", duration: 3000 },
                { text: "Xong rồi! Cùng xem kết quả tuyệt vời của bạn nhé!", duration: 1000 }
            ];
            let cumulativeDelay = 0;
            stopProgressTextAnimation();
            steps.forEach(step => {
                const id = setTimeout(() => { progressText.textContent = step.text; }, cumulativeDelay);
                progressTextTimeoutIds.push(id);
                cumulativeDelay += step.duration;
            });
        }
        
        function stopProgressTextAnimation() {
            progressTextTimeoutIds.forEach(clearTimeout);
            progressTextTimeoutIds = [];
        }

        async function analyzeAudio(audioBlob) {
            analysisRequestID++;
            const currentAnalysisID = analysisRequestID;

            if (!audioBlob) return;
            lastRecordingBlob = audioBlob;
            listenAgainBtn.disabled = false;

            if (!standardIPA) {
                showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                return;
            }
            
            // FIXED: Ensure model data is available for sentences
            if (!isSingleWordMode) {
                const modelData = await prefetchModelPronunciation(textInput.value.trim(), accentSelect.value);
                if (!modelData.pitchContour?.length) {
                   showMessage('Chưa có dữ liệu ngữ điệu mẫu, vui lòng thử lại.', 'error');
                   return;
                }
            }

            loader.classList.remove('hidden');
            startProgressTextAnimation();
            startProgressSimulation();
            funFactEl.textContent = `💡 ${funFacts[Math.floor(Math.random() * funFacts.length)]}`;
            funFactEl.classList.remove('hidden');
            
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = async () => {
                if (currentAnalysisID !== analysisRequestID) return;

                const base64Audio = reader.result.split(',')[1];
                
                // FIXED: SPECIALIZED PROMPTS FOR DIFFERENT MODES
                let prompt;
                if (isSingleWordMode) {
                    prompt = {
                        "role": "Bạn là chuyên gia ngữ âm AI. Nhiệm vụ của bạn là phân tích một từ đơn.",
                        "task_instructions": {
                            "step_1_verification": "Đầu tiên, phiên âm audio của người dùng. Nếu từ được phát âm khác với 'text_to_pronounce', hãy trả về JSON với 'word_match': false và 'transcribed_word'. KHÔNG phân tích thêm.",
                            "step_2_analysis": "Nếu từ khớp, thực hiện phân tích âm vị cực kỳ nghiêm ngặt và chính xác. So sánh từng âm vị của người dùng với âm vị chuẩn.",
                            "step_3_scoring": "Chấm điểm khắt khe dựa trên độ chính xác của từng âm vị. Lỗi âm cuối hoặc nguyên âm chính là lỗi nghiêm trọng."
                        },
                        "context": {
                            "text_to_pronounce": textInput.value.trim(),
                            "target_accent": accentSelect.value === 'American English' ? 'AmE' : 'BrE',
                            "standard_ipa": standardIPA,
                            "standard_syllable_structure": currentIpaData.syllable_structure
                        },
                        "output_format_instruction": {
                            "format": "JSON",
                            "schema": {
                                "word_match": "boolean",
                                "transcribed_word": "string | null",
                                "overall_score": "number | null",
                                "user_ipa": "string | null",
                                "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string\" } ] | null",
                                "syllable_analysis": "{ \"feedback\": \"string\" } | null"
                            }
                        }
                    };
                } else { // Sentence mode
                    const modelData = modelPronunciationCache.get(`${textInput.value.trim()}_${accentSelect.value}`);
                    prompt = {
                        "role": "Bạn là PrAI, một chuyên gia ngữ âm AI thấu hiểu người học tiếng Anh là người Việt.",
                        "context": {
                            "learner_profile": "Người Việt, thường bỏ âm cuối, nhầm lẫn nguyên âm, và nói ngắt nghỉ.",
                            "text_to_pronounce": textInput.value.trim(),
                            "target_accent": accentSelect.value === 'American English' ? 'AmE' : 'BrE',
                            "standard_ipa": standardIPA,
                            "model_pitch_contour": modelData?.pitchContour || [],
                        },
                        "leniency_rules": [{ 
                            "phoneme": "ʔ (glottal stop)", 
                            "condition": "Khi thay thế cho âm /t/ cuối không bật hơi.", 
                            "adjustment": "Phân loại là 'Gần đúng' và trừ tối đa 1-2 điểm."
                        }],
                        "output_format_instruction": {
                            "format": "JSON",
                            "schema": {
                                "sentence_match": "boolean",
                                "overall_score": "number | null",
                                "user_ipa": "string | null",
                                "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string\" } ]",
                                "intonation_analysis": {
                                    "feedback": "string // Nhận xét về ngữ điệu, tốc độ và nhịp điệu. So sánh với mẫu.",
                                    "user_pitch_contour": "[number]"
                                },
                                "connected_speech_analysis": "[{ \"type\": \"string\", \"rule\": \"string\", \"location\": \"string\", \"expected_pronunciation\": \"string\", \"user_pronunciation\": \"string\", \"feedback\": \"string\" }] | null",
                                "practice_suggestions": "{ \"youglish_us\": \"string\", \"youglish_uk\": \"string\" } | null"
                            }
                        }
                    };
                }

                const payload = {
                    contents: [ { role: "user", parts: [ { text: JSON.stringify(prompt) }, { inlineData: { mimeType: "audio/webm", data: base64Audio } } ] } ],
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const data = await fetchWithBackoff(TEXT_API_URL, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, 
                        body: JSON.stringify(payload) 
                    });
                    
                    if (currentAnalysisID !== analysisRequestID) return;
                    const resultJson = JSON.parse(data.candidates[0].content.parts[0].text);
                    displayResults(resultJson);
                } catch (error) {
                    if (currentAnalysisID === analysisRequestID) handleApiError(error);
                } finally {
                    if (currentAnalysisID === analysisRequestID) {
                        stopProgressSimulation();
                        stopProgressTextAnimation();
                        setTimeout(() => {
                            loader.classList.add('hidden');
                            funFactEl.classList.add('hidden');
                        }, 500);
                    }
                }
            };
        }
        
        // FIXED: displayResults handles both modes properly
        function displayResults(data) {
            // Check for mismatch first
            if (data.word_match === false) {
                showMessage(`Bạn dường như đã phát âm từ "${data.transcribed_word}" thay vì từ mẫu. Vui lòng thử lại.`, 'warning');
                return;
            }
            if (data.sentence_match === false) {
                showMessage("Câu bạn nói không khớp với câu mẫu. Vui lòng thử lại.", 'warning');
                return;
            }
            if (data.overall_score === null) {
                showMessage("PrAI không nhận diện được giọng nói. Vui lòng thử lại và nói to, rõ hơn.", 'warning');
                return;
            }
        
            saveToHistory(textInput.value.trim(), data.overall_score);
            analysisResults.classList.remove('hidden');
        
            // Score
            const scoreContainer = document.querySelector('.score-container');
            animateValue(overallScore, 0, data.overall_score, 1000);
            scoreContainer.className = 'score-container';
            if (data.overall_score > 85) scoreContainer.classList.add('score-high');
            else if (data.overall_score > 70) scoreContainer.classList.add('score-medium');
            else scoreContainer.classList.add('score-low');
        
            // Phoneme Analysis
            phonemeAnalysis.innerHTML = '';
            data.phoneme_analysis?.forEach(p => {
                const phonemeEl = document.createElement('div');
                phonemeEl.textContent = p.phoneme;
                phonemeEl.className = `phoneme has-tooltip status-${p.status}`;
                if (p.feedback) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = p.feedback;
                    phonemeEl.appendChild(tooltip);
                }
                phonemeAnalysis.appendChild(phonemeEl);
            });
        
            // Toggle analysis sections based on mode
            prosodyAnalysisContainer.style.display = 'block';
            connectedSpeechContainer.style.display = isSingleWordMode ? 'none' : 'block';

            if (isSingleWordMode) {
                intonationAnalysisContent.style.display = 'none';
                syllableAnalysisContent.style.display = 'block';
                prosodyAnalysisTitle.textContent = 'Phân tích Âm tiết & Trọng âm';
                renderSyllableChart(currentIpaData.syllable_structure);
                syllableAnalysisFeedback.textContent = data.syllable_analysis?.feedback || '';
            } else { // Sentence Mode
                intonationAnalysisContent.style.display = 'block';
                syllableAnalysisContent.style.display = 'none';
                prosodyAnalysisTitle.textContent = 'Phân tích Ngữ điệu';
                intonationAnalysisFeedback.textContent = data.intonation_analysis?.feedback || '';
                
                const modelData = modelPronunciationCache.get(`${textInput.value.trim()}_${accentSelect.value}`);
                renderIntonationChart(
                    intonationChart,
                    modelData?.pitchContour || [],
                    data.intonation_analysis?.user_pitch_contour || [],
                    modelData?.stressedWords || []
                );
                
                // FIXED: Connected Speech with proper type classes
                connectedSpeechAnalysis.innerHTML = '';
                if (data.connected_speech_analysis?.length > 0) {
                    data.connected_speech_analysis.forEach(item => {
                        const itemEl = document.createElement('div');
                        const typeClass = `type-${item.type.toLowerCase().replace(/\s+/g, '-')}`;
                        itemEl.className = `connected-speech-item ${typeClass}`;
                        itemEl.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div><p class="cs-title">${item.rule}</p><p class="cs-details mt-1">Vị trí: <span class="cs-location">${item.location}</span></p></div>
                                <span class="text-xs font-semibold uppercase px-2 py-1 rounded-full ${typeClass} opacity-70">${item.type}</span>
                            </div>
                            <div class="cs-details mt-2">
                                <p>Phát âm mong đợi: <span class="ipa-text text-accent-success">${item.expected_pronunciation}</span></p>
                                <p>Phát âm của bạn: <span class="ipa-text text-accent-warning">${item.user_pronunciation}</span></p>
                            </div>
                            <p class="cs-feedback text-sm">${item.feedback}</p>`;
                        connectedSpeechAnalysis.appendChild(itemEl);
                    });
                } else {
                    connectedSpeechAnalysis.innerHTML = '<p class="text-text-secondary text-sm italic">Không có nhận xét nổi bật về nối âm. Lời nói của bạn khá rõ ràng nhưng có thể chưa thể hiện sự liên kết tự nhiên.</p>';
                }
            }
        
            // Practice Suggestions
            if (data.practice_suggestions) {
                suggestionLinks.innerHTML = `<a href="${data.practice_suggestions.youglish_us}" target="_blank" class="btn btn-primary flex-1">Giọng Mỹ (YouGlish)</a><a href="${data.practice_suggestions.youglish_uk}" target="_blank" class="btn btn-primary flex-1">Giọng Anh (YouGlish)</a>`;
                practiceSuggestions.classList.remove('hidden');
            } else {
                practiceSuggestions.classList.add('hidden');
            }
        }
        
        // NEW: Render Syllable Chart
        function renderSyllableChart(structure) {
            syllableChartContainer.innerHTML = '';
            if (!structure || !structure.syllables) return;
            
            structure.syllables.forEach((syllable, index) => {
                const syllableEl = document.createElement('div');
                syllableEl.className = 'syllable';
                syllableEl.textContent = syllable;
                if (index === structure.stressed_syllable_index) {
                    syllableEl.classList.add('stressed');
                }
                syllableChartContainer.appendChild(syllableEl);
            });
        }

        function resetAnalysisOnly() {
            analysisResults.classList.add('hidden');
            practiceSuggestions.classList.add('hidden');
        }

        function resetAll() {
            resetAnalysisOnly();
            controlsSection.classList.add('hidden');
            simpleIpaText.textContent = '/ ... /';
            detailedIpaText.textContent = '[ ... ]';
            thoughtGroupDisplay.textContent = '...';
            thoughtGroupInfo.classList.add('hidden');
            standardIPA = '';
            currentIpaData = {};
            listenAgainBtn.disabled = true;
        }

        async function handleRecord() {
            if (!isRecording) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    soundDetected = false;

                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    mediaRecorder.onstop = () => {
                        stream.getTracks().forEach(track => track.stop());
                        if (soundDetected) {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            resetAnalysisOnly();
                            analyzeAudio(audioBlob);
                        } else {
                            showMessage('Không phát hiện âm thanh. Vui lòng thử lại.', 'warning');
                        }
                    };

                    audioContext = new AudioContext();
                    const source = audioContext.createMediaStreamSource(stream);
                    analyser = audioContext.createAnalyser();
                    source.connect(analyser);
                    analyser.fftSize = 256;

                    const checkSound = () => {
                        const dataArray = new Uint8Array(analyser.frequencyBinCount);
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
                        if (average > 10) soundDetected = true;
                        if (isRecording) requestAnimationFrame(checkSound);
                    };
                    checkSound();

                    mediaRecorder.start();
                    isRecording = true;
                    recordBtn.classList.add('is-recording');
                    recordBtn.innerHTML = '<svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><rect x="6" y="6" width="12" height="12" rx="2"></rect></svg>';
                } catch (error) {
                    showMessage('Không thể truy cập microphone. Vui lòng kiểm tra quyền truy cập.', 'error');
                }
            } else {
                mediaRecorder.stop();
                isRecording = false;
                recordBtn.classList.remove('is-recording');
                recordBtn.innerHTML = '<svg class="w-8 h-8" fill="currentColor" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8"></circle></svg>';
            }
        }

        function handleListenAgain() {
            if (lastRecordingBlob) {
                const audioUrl = URL.createObjectURL(lastRecordingBlob);
                replayAudio.src = audioUrl;
                replayAudio.play();
            }
        }

        // History functions
        function saveToHistory(text, score) {
            try {
                const history = JSON.parse(localStorage.getItem('prai-history') || '[]');
                const existingIndex = history.findIndex(item => item.text === text);
                const newItem = { text, score, date: new Date().toISOString() };
                
                if (existingIndex >= 0) {
                    history[existingIndex] = newItem;
                } else {
                    history.unshift(newItem);
                }
                
                localStorage.setItem('prai-history', JSON.stringify(history.slice(0, 50)));
            } catch (e) {
                console.error('History save error:', e);
            }
        }

        function loadHistory() {
            try {
                const history = JSON.parse(localStorage.getItem('prai-history') || '[]');
                historyList.innerHTML = history.length ? history.map(item => `
                    <div class="history-item p-3 rounded-lg border border-glass-border" data-text="${item.text}">
                        <div class="flex justify-between items-start">
                            <div class="flex-1 mr-3">
                                <p class="history-item-text font-medium">${item.text}</p>
                                <p class="text-sm text-text-secondary">Điểm: ${item.score} • ${new Date(item.date).toLocaleDateString('vi-VN')}</p>
                            </div>
                            <div class="flex gap-2">
                                <button class="btn btn-secondary text-xs" data-action="select">Chọn</button>
                                <button class="btn btn-secondary text-xs" data-action="delete">Xóa</button>
                            </div>
                        </div>
                    </div>
                `).join('') : '<p class="text-text-secondary text-center py-4">Chưa có lịch sử luyện tập</p>';
            } catch (e) {
                console.error('History load error:', e);
                historyList.innerHTML = '<p class="text-text-secondary text-center py-4">Lỗi tải lịch sử</p>';
            }
        }

        function clearHistory() {
            localStorage.removeItem('prai-history');
            loadHistory();
            showMessage('Đã xóa tất cả lịch sử', 'success');
        }

        function deleteHistoryItem(text) {
            try {
                const history = JSON.parse(localStorage.getItem('prai-history') || '[]');
                const filtered = history.filter(item => item.text !== text);
                localStorage.setItem('prai-history', JSON.stringify(filtered));
                loadHistory();
                showMessage('Đã xóa mục khỏi lịch sử', 'success');
            } catch (e) {
                console.error('History delete error:', e);
            }
        }

        function handleHistoryClick(event) {
            const target = event.target;
            const action = target.dataset.action;
            if (!action) return;
            
            const text = target.closest('.history-item').dataset.text;
            if (action === 'select') {
                textInput.value = text;
                charCounter.textContent = `${text.length} / 150`;
                historyModal.classList.remove('is-visible');
                resetAll();
                fetchAndDisplayIPA();
            } else if (action === 'delete') {
                deleteHistoryItem(text);
            }
        }
        
        function animateValue(obj, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerHTML = Math.floor(progress * (end - start) + start);
                if (progress < 1) window.requestAnimationFrame(step);
            };
            window.requestAnimationFrame(step);
        }
        
        // FIXED: renderIntonationChart positions stressed words dynamically
        function renderIntonationChart(svgElement, modelData, userData, stressedWords = []) {
            svgElement.innerHTML = ''; 
            if (!modelData?.length || !userData?.length) return;
        
            const padding = { top: 30, right: 10, bottom: 20, left: 10 };
            const width = svgElement.clientWidth;
            const height = svgElement.clientHeight;
            const innerWidth = width - padding.left - padding.right;
            const innerHeight = height - padding.top - padding.bottom;
        
            const allData = [...modelData, ...userData];
            const yMin = Math.min(...allData);
            const yMax = Math.max(...allData) > yMin ? Math.max(...allData) : yMin + 1;
            
            const scaleX = (index, len) => padding.left + (index / (len - 1)) * innerWidth;
            const scaleY = (val) => padding.top + innerHeight - ((val - yMin) / (yMax - yMin)) * innerHeight;
        
            const createPolyline = (points, color, dash) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                line.setAttribute('points', points);
                line.setAttribute('fill', 'none');
                line.setAttribute('stroke', `var(--${color})`);
                line.setAttribute('stroke-width', dash ? '2.5' : '2');
                if (dash) line.setAttribute('stroke-dasharray', '4 4');
                return line;
            };

            const modelPoints = modelData.map((d, i) => `${scaleX(i, modelData.length)},${scaleY(d)}`).join(' ');
            const userPoints = userData.map((d, i) => `${scaleX(i, userData.length)},${scaleY(d)}`).join(' ');
            svgElement.appendChild(createPolyline(modelPoints, 'accent-primary'));
            svgElement.appendChild(createPolyline(userPoints, 'accent-warning', true));

            // FIXED: Dynamically position stressed words above pitch peaks
            stressedWords.forEach(item => {
                const modelIndex = Math.round(item.time_stamp_normalized * (modelData.length - 1));
                const searchRadius = 2;
                let peakValue = -Infinity;
                for (let i = -searchRadius; i <= searchRadius; i++) {
                    const idx = Math.max(0, Math.min(modelData.length - 1, modelIndex + i));
                    if (modelData[idx] > peakValue) peakValue = modelData[idx];
                }
                
                const x = padding.left + (item.time_stamp_normalized * innerWidth);
                const y = scaleY(peakValue) - 8; // Position 8px above the peak

                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', x);
                textEl.setAttribute('y', y);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('font-size', '12');
                textEl.setAttribute('font-weight', '600');
                textEl.setAttribute('fill', 'var(--text-primary)');
                textEl.textContent = item.word;
                svgElement.appendChild(textEl);
            });
            
            // Legend
            const legend = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            legend.innerHTML = `
                <rect x="${innerWidth - 180}" y="${height - 15}" width="12" height="2" fill="var(--accent-primary)" />
                <text x="${innerWidth - 165}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng mẫu</text>
                <rect x="${innerWidth - 90}" y="${height - 15}" width="12" height="2" fill="var(--accent-warning)" stroke-dasharray="2 2" stroke="var(--accent-warning)" />
                <text x="${innerWidth - 75}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng của bạn</text>`;
            svgElement.appendChild(legend);
        }

        function initApp() {
            textInput.addEventListener('input', () => {
                charCounter.textContent = `${textInput.value.length} / 150`;
                resetAll();
            });
            accentSelect.addEventListener('change', () => {
                if (textInput.value.trim()) {
                    resetAll();
                    fetchAndDisplayIPA();
                }
            });
            transcribeBtn.addEventListener('click', fetchAndDisplayIPA);
            listenNaturalBtn.addEventListener('click', () => handleListen('natural'));
            listenClearBtn.addEventListener('click', () => handleListen('clear'));
            recordBtn.addEventListener('click', handleRecord);
            listenAgainBtn.addEventListener('click', handleListenAgain);
            randomPracticeBtn.addEventListener('click', () => {
                const sentence = practiceSentences[Math.floor(Math.random() * practiceSentences.length)];
                textInput.value = sentence;
                charCounter.textContent = `${sentence.length} / 150`;
                resetAll();
                fetchAndDisplayIPA();
            });
            uploadBtn.addEventListener('click', () => audioUploadInput.click());
            historyBtn.addEventListener('click', () => { loadHistory(); historyModal.classList.add('is-visible'); });
            closeHistoryBtn.addEventListener('click', () => historyModal.classList.remove('is-visible'));
            historyModal.addEventListener('click', e => { if (e.target === historyModal) historyModal.classList.remove('is-visible'); });
            clearHistoryBtn.addEventListener('click', clearHistory);
            historyList.addEventListener('click', handleHistoryClick);

            audioUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file?.type.startsWith('audio/')) {
                    const checkAndAnalyze = async () => {
                        if (!textInput.value.trim()) {
                            showMessage('Vui lòng nhập văn bản tương ứng với file âm thanh.', 'warning');
                            return;
                        }
                        resetAnalysisOnly(); 
                        if (!standardIPA) await fetchAndDisplayIPA();
                        if (!standardIPA) {
                            showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                            return;
                        }
                        analyzeAudio(file);
                    };
                    checkAndAnalyze();
                } else if (file) {
                    showMessage('Vui lòng chọn một tệp âm thanh hợp lệ.', 'warning');
                }
                event.target.value = null;
            });

            textInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); fetchAndDisplayIPA(); } });
        }

        initApp();
    </script>
</body>
</html>

