<!DOCTYPE html>
<html lang="vi" data-theme="light"> <!-- Default to light theme -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrAI - Luyện Phát Âm với AI</title>
    <!-- NEW FAVICON -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23007CF0;'/%3E%3Cstop offset='100%25' style='stop-color:%2300DFD8;'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3Ctext x='50' y='55' font-family='Exo 2, sans-serif' font-size='40' font-weight='700' fill='white' text-anchor='middle' dominant-baseline='middle'%3EPrAI%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans:wght@400;700&family=Exo+2:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- GLASSMORPHISM THEME V11 --- */
        :root {
            /* Default: Light Theme */
            --bg-color: #f8fafc; /* slate-50 */
            --bg-blob-1: #0ea5e9; /* sky-500 */
            --bg-blob-2: #14b8a6; /* teal-500 */
            --glass-bg: rgba(248, 250, 252, 0.6); /* slate-50 @ 60% */
            --glass-border: rgba(255, 255, 255, 0.7);
            --text-primary: #0f172a; /* slate-900 */
            --text-secondary: #475569; /* slate-600 */
            --accent-primary: #007CF0;
            --accent-danger: #ef4444; /* red-500 */
            --accent-success: #22c55e; /* green-500 */
            --accent-warning: #f59e0b; /* amber-500 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0056b3;
            --btn-secondary-bg: rgba(241, 245, 249, 0.7); /* slate-100 @ 70% */
            --btn-secondary-hover-bg: rgba(226, 232, 240, 0.9); /* slate-200 @ 90% */
            --input-bg: rgba(255, 255, 255, 0.4);
            --input-focus-bg: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(100, 116, 139, 0.2); /* slate-400 */
            --highlight-correct: rgba(34, 197, 94, 0.1);
            --highlight-approximate: rgba(245, 158, 11, 0.1);
            --highlight-incorrect: rgba(239, 68, 68, 0.1);
            --radius-sm: 0.75rem;
            --radius-md: 1rem;
            --radius-lg: 1.5rem;
        }

        [data-theme="dark"] {
            --bg-color: #020617; /* slate-950 */
            --bg-blob-1: #0369a1; /* cyan-700 */
            --bg-blob-2: #0d9488; /* teal-600 */
            --glass-bg: rgba(30, 41, 59, 0.5); /* slate-800 @ 50% */
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #f1f5f9; /* slate-100 */
            --text-secondary: #94a3b8; /* slate-400 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0095ff;
            --btn-secondary-bg: rgba(51, 65, 85, 0.5); /* slate-700 @ 50% */
            --btn-secondary-hover-bg: rgba(51, 65, 85, 0.8);
            --input-bg: rgba(15, 23, 42, 0.5); /* slate-900 @ 50% */
            --input-focus-bg: rgba(15, 23, 42, 0.7);
            --shadow-color: rgba(0, 0, 0, 0.35);
            --highlight-correct: rgba(74, 222, 128, 0.15);
            --highlight-approximate: rgba(250, 204, 21, 0.15);
            --highlight-incorrect: rgba(248, 113, 113, 0.15);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
        }
        
        .background-container { width: 100%; height: 100%; position: fixed; top: 0; left: 0; z-index: -1; overflow: hidden; }
        .blob { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.4; }
        .blob-1 { width: 450px; height: 450px; background: var(--bg-blob-1); animation: move 20s infinite alternate; }
        .blob-2 { width: 350px; height: 350px; background: var(--bg-blob-2); animation: move 25s infinite alternate-reverse; animation-delay: -5s; }

        @keyframes move {
            from { transform: translate(-15vw, -15vh) scale(1) rotate(0deg); }
            to { transform: translate(65vw, 75vh) scale(1.2) rotate(180deg); }
        }

        .font-logo { font-family: 'Exo 2', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text, .phoneme, .ipa-text { font-family: 'Noto Sans', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text { word-break: break-word; }

        .glass-card {
            background-color: var(--glass-bg);
            backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
            box-shadow: 0 8px 32px 0 var(--shadow-color), inset 0 1px 0 0 var(--glass-border);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease-in-out;
        }

        .main-card { padding: clamp(1rem, 5vw, 2.5rem); }
        .card-layer { padding: 1.5rem; border-radius: var(--radius-md); }
        .card-layer-inset { background-color: var(--input-bg); padding: 1rem; border-radius: var(--radius-md); border: 1px solid var(--glass-border); box-shadow: inset 0 2px 4px var(--shadow-color); }

        .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; padding: 0.75rem 1.5rem; border-radius: var(--radius-sm); font-weight: 600; border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-in-out; box-shadow: 0 4px 10px var(--shadow-color); }
        .btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px var(--shadow-color); }
        .btn:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 10px var(--shadow-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--btn-primary-bg); color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .btn-primary:hover:not(:disabled) { background-color: var(--btn-primary-hover-bg); }

        .btn-secondary { background-color: var(--btn-secondary-bg); color: var(--text-secondary); border: 1px solid var(--glass-border); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
        .btn-secondary:hover:not(:disabled) { background-color: var(--btn-secondary-hover-bg); color: var(--text-primary); }

        .btn-icon { width: 2.75rem; height: 2.75rem; border-radius: 50%; padding: 0; flex-shrink: 0; position: relative; display: inline-flex; align-items: center; justify-content: center; }
        .btn-icon > .icon { margin: auto; }
        
        .btn-record { width: 7rem; height: 7rem; border-radius: 50%; background: radial-gradient(circle, #ff5f5f 0%, #ef4444 100%); color: #ffffff; font-weight: 600; cursor: pointer; box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2); transition: all 0.2s ease-in-out; border: 3px solid rgba(255, 255, 255, 0.4); text-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .btn-record:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 15px 30px color-mix(in srgb, var(--accent-danger) 40%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2); }
        .btn-record.is-recording { animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 70%, transparent); }
            70% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 15px color-mix(in srgb, var(--accent-danger) 0%, transparent); }
            100% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 0%, transparent); }
        }
        
        .input-field { width: 100%; background-color: var(--input-bg); border: 1px solid var(--glass-border); border-radius: var(--radius-sm); padding: 0.75rem 1rem; color: var(--text-primary); transition: all 0.2s ease-in-out; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        .input-field:focus { outline: none; border-color: var(--accent-primary); background-color: var(--input-focus-bg); box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent); }
        textarea.input-field { resize: vertical; min-height: 80px; }

        .phoneme { padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 1.125rem; position: relative; transition: all 0.2s ease-in-out; color: var(--text-secondary); }
        .phoneme.status-correct { background-color: var(--highlight-correct); color: var(--accent-success); }
        .phoneme.status-approximate { background-color: var(--highlight-approximate); color: var(--accent-warning); }
        .phoneme.status-incorrect { background-color: var(--highlight-incorrect); color: var(--accent-danger); }

        .tooltip { visibility: hidden; opacity: 0; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); transform: translate(-50%, 10px); background-color: var(--bg-color); color: var(--text-primary); border: 1px solid var(--glass-border); z-index: 20; position: absolute; bottom: 100%; left: 50%; margin-bottom: 0.5rem; width: 256px; border-radius: 0.75rem; padding: 0.75rem; font-size: 0.875rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .has-tooltip:hover .tooltip { visibility: visible; opacity: 1; }
        
        .score-container { width: 140px; height: 140px; margin: 1rem auto; display: flex; align-items: center; justify-content: center; transition: all 0.5s ease-out; border-radius: 50%; border: 4px solid transparent; background: radial-gradient(circle, color-mix(in srgb, var(--accent-primary) 10%, transparent) 0%, rgba(74, 128, 240, 0) 70%); }
        .score-container.score-high { border-color: var(--accent-success); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-success) 50%, transparent); }
        .score-container.score-medium { border-color: var(--accent-warning); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-warning) 50%, transparent); }
        .score-container.score-low { border-color: var(--accent-danger); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-danger) 50%, transparent); }
        
        #overall-score { font-size: 3.5rem; font-weight: 700; color: var(--text-primary); transition: color 0.5s ease-out; }
        .score-high #overall-score { color: var(--accent-success); }
        .score-medium #overall-score { color: var(--accent-warning); }
        .score-low #overall-score { color: var(--accent-danger); }

        #detailed-ipa-text { color: var(--accent-primary); }
        
        .thought-group { padding: 0.25rem 0.75rem; border-radius: 0.5rem; margin: 0.1rem; display: inline-block; transition: background-color 0.3s; }
        [data-theme="dark"] .thought-group-0 { background-color: rgba(96, 165, 250, 0.2); color: #bfdbfe; }
        [data-theme="dark"] .thought-group-1 { background-color: rgba(52, 211, 153, 0.2); color: #a7f3d0; }
        [data-theme="dark"] .thought-group-2 { background-color: rgba(250, 204, 21, 0.2); color: #fef08a; }
        [data-theme="dark"] .thought-group-3 { background-color: rgba(192, 132, 252, 0.2); color: #e9d5ff; }
        [data-theme="light"] .thought-group-0 { background-color: rgba(59, 130, 246, 0.15); color: #1e40af; }
        [data-theme="light"] .thought-group-1 { background-color: rgba(16, 185, 129, 0.15); color: #065f46; }
        [data-theme="light"] .thought-group-2 { background-color: rgba(245, 158, 11, 0.15); color: #92400e; }
        [data-theme="light"] .thought-group-3 { background-color: rgba(168, 85, 247, 0.15); color: #6b21a8; }
        
        .btn-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .fade-in { animation: fadeIn 0.6s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); display: flex; align-items: center; justify-content: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-overlay.is-visible { opacity: 1; visibility: visible; }
        .modal-container { width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.is-visible .modal-container { transform: scale(1); }
        .history-item { cursor: pointer; transition: background-color 0.2s; }
        .history-item:hover { background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); }
        .history-item-text { color: var(--text-primary); }

        .analysis-box-detailed { background-color: color-mix(in srgb, var(--input-bg) 60%, transparent); border: 1px solid var(--glass-border); border-radius: var(--radius-md); padding: 1.25rem; box-shadow: inset 0 2px 4px color-mix(in srgb, var(--shadow-color) 50%, transparent); }
        .analysis-title { font-size: 1.125rem; font-weight: 600; color: var(--text-primary); margin-bottom: 1rem; }
        .chart-container { width: 100%; height: 180px; background-color: var(--input-bg); border-radius: var(--radius-sm); padding: 0.5rem; border: 1px solid var(--glass-border); margin-bottom: 1rem; }
        .connected-speech-item { padding: 1rem; border-radius: var(--radius-sm); border-left: 4px solid; position: relative; overflow: hidden; }
        .connected-speech-item.type-catenation { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.1); }
        .connected-speech-item.type-assimilation { border-color: #a855f7; background-color: rgba(168, 85, 247, 0.1); }
        .connected-speech-item.type-elision { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.1); }
        .connected-speech-item.type-intrusion { border-color: #14b8a6; background-color: rgba(20, 184, 166, 0.1); }
        .connected-speech-item.type-weak-form { border-color: #f59e0b; background-color: rgba(245, 158, 11, 0.1); }
        .cs-title { font-weight: 600; color: var(--text-primary); }
        .cs-location { font-family: 'Noto Sans', sans-serif; background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.9em; }
        .cs-details { font-size: 0.875rem; color: var(--text-secondary); }
        .cs-feedback { margin-top: 0.5rem; font-style: italic; }
    </style>
</head>
<body class="antialiased">
    <div class="background-container">
        <div class="blob blob-1"></div>
        <div class="blob blob-2"></div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-container glass-card p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h3 class="font-bold text-text-primary text-xl">Lịch sử Luyện tập</h3>
                <button id="close-history-btn" class="btn btn-secondary btn-icon !w-8 !h-8">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="history-list" class="space-y-2"></div>
            <button id="clear-history-btn" class="btn btn-secondary w-full">Xóa tất cả lịch sử</button>
        </div>
    </div>

    <div class="w-full max-w-3xl mx-auto p-4 relative z-10">
        <header class="text-center mb-8 fade-in relative flex justify-between items-center">
            <button id="history-btn" class="btn btn-secondary btn-icon" aria-label="Xem lịch sử">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            <div class="absolute left-1/2 -translate-x-1/2">
                <h1 class="text-5xl md:text-6xl font-bold font-logo" style="color: var(--accent-primary);">PrAI</h1>
                <p class="text-text-secondary text-sm md:text-base">Trợ lý luyện phát âm AI của bạn</p>
            </div>
            <button id="theme-toggle" class="btn btn-secondary btn-icon" aria-label="Toggle theme">
                <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
            </button>
        </header>

        <main class="main-card glass-card space-y-8">
            <section class="input-section card-layer glass-card space-y-4">
                <div>
                    <label for="text-input" class="block text-lg font-semibold text-text-primary mb-3">Nhập văn bản cần luyện tập:</label>
                    <textarea id="text-input" rows="3" maxlength="150" class="input-field" placeholder="Ví dụ: What are you doing?"></textarea>
                    <div id="char-counter" class="text-right text-sm text-text-secondary mt-1">0 / 150</div>
                    <div class="mt-4 flex flex-col sm:flex-row items-center gap-4">
                        <div class="flex-grow w-full">
                            <label for="accent-select" class="block text-sm font-medium text-text-secondary mb-1">Chọn giọng:</label>
                            <select id="accent-select" class="input-field">
                                <option value="British English" selected>Anh - Anh (BrE)</option>
                                <option value="American English">Anh - Mỹ (AmE)</option>
                            </select>
                        </div>
                        <div class="flex-shrink-0 flex gap-3 self-end">
                            <button id="random-practice-btn" class="btn btn-secondary">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 8"/><path d="M21 22v-6h-6"/><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"/></svg>
                                <span class="text hidden sm:inline">Ngẫu nhiên</span>
                            </button>
                             <button id="transcribe-btn" class="btn btn-primary relative">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                                 <span class="text">Phiên âm</span>
                                 <div class="btn-spinner hidden absolute inset-0 m-auto h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                             </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <section id="controls-section" class="hidden space-y-6">
                 <div class="card-layer glass-card space-y-4">
                     <!-- Basic IPA -->
                     <div class="flex items-center justify-between">
                         <div class="min-w-0">
                             <h3 class="font-semibold text-text-secondary text-md">Phiên âm cơ bản</h3>
                             <p id="simple-ipa-text" class="text-lg text-text-primary tracking-wider"></p>
                         </div>
                         <div class="relative w-11 h-11">
                             <button id="listen-clear-btn" class="btn-icon btn-secondary absolute inset-0">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>
                             </button>
                             <div id="listen-clear-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                 <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                             </div>
                         </div>
                     </div>
                     <!-- Detailed IPA & Thought Groups (for sentences) -->
                     <div id="detailed-analysis-container" class="flex items-center justify-between transition-opacity duration-300">
                         <div class="min-w-0">
                             <div class="flex items-center gap-2 mb-1">
                                 <h3 class="font-semibold text-text-secondary text-md">Phiên âm Tự nhiên & Cụm tư duy</h3>
                                 <div id="thought-group-info" class="has-tooltip relative hidden">
                                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-text-secondary cursor-pointer"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                                     <div id="thought-group-tooltip" class="tooltip absolute bottom-full left-1/2 mb-2 w-72 rounded-lg p-3 text-xs shadow-lg"></div>
                                 </div>
                             </div>
                             <div class="space-y-2">
                                 <p id="detailed-ipa-text" class="text-xl text-accent-primary tracking-wider"></p>
                                 <div id="thought-group-display" class="text-lg tracking-wide leading-relaxed font-medium"></div>
                             </div>
                         </div>
                         <div class="relative w-11 h-11">
                             <button id="listen-natural-btn" class="btn-icon btn-secondary absolute inset-0">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                             </button>
                             <div id="listen-natural-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                 <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                             </div>
                         </div>
                     </div>
                 </div>

                <div class="flex flex-col items-center justify-center gap-4 pt-4">
                    <div id="record-controls" class="flex items-center justify-center gap-6 w-full h-28">
                        <button id="upload-btn" class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        </button>
                        <div class="flex flex-col items-center justify-center">
                            <button id="record-btn" class="btn-record flex items-center justify-center">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                                <span class="text hidden text-lg font-semibold">Dừng</span>
                            </button>
                        </div>
                        <button id="listen-again-btn" disabled class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
                        </button>
                    </div>
                    <div id="waveform-container" class="hidden h-20 w-full card-layer-inset flex items-center justify-center p-2">
                        <canvas id="waveform" class="w-full h-full"></canvas>
                    </div>
                </div>
            </section>

            <div id="loader" class="text-center hidden py-4 flex flex-col items-center justify-center">
                <div class="w-full max-w-xs h-2 rounded-full overflow-hidden bg-[color:var(--input-bg)]">
                    <div id="progress-bar-inner" class="h-full rounded-full bg-gradient-to-r from-sky-400 to-teal-400 transition-all duration-500"></div>
                </div>
                <p id="progress-text" class="text-text-secondary mt-4">PrAI đang lắng nghe và phân tích...</p>
                <p id="fun-fact" class="text-sm text-text-secondary/70 mt-6 italic hidden"></p>
            </div>

            <!-- UPDATED ANALYSIS RESULTS SECTION -->
            <section id="analysis-results" class="hidden space-y-6">
                <div class="card-layer glass-card space-y-6 p-6">
                    <h3 class="font-bold text-text-primary text-2xl text-center">Kết quả Phân tích</h3>
            
                    <!-- Overall Score -->
                    <div class="score-container">
                        <p><span id="overall-score"></span><span class="text-xl text-text-secondary">/100</span></p>
                    </div>
            
                    <!-- Phoneme Analysis -->
                    <div class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Âm vị</h4>
                        <div id="phoneme-analysis" class="flex flex-wrap gap-2"></div>
                        <p class="text-xs text-text-secondary mt-3">Chạm hoặc di chuột qua các âm vị để xem hướng dẫn.</p>
                    </div>
            
                    <!-- Intonation / Syllable Analysis -->
                    <div id="prosody-analysis-container" class="analysis-box-detailed">
                        <h4 id="prosody-analysis-title" class="analysis-title">Phân tích Ngữ điệu</h4>
                        <div class="chart-container">
                            <svg id="prosody-chart" width="100%" height="100%"></svg>
                        </div>
                        <div id="prosody-analysis-feedback" class="text-sm text-text-secondary"></div>
                    </div>
            
                    <!-- Connected Speech Analysis -->
                    <div id="connected-speech-container" class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Nối âm & Cụm tư duy</h4>
                        <div id="connected-speech-analysis" class="space-y-3"></div>
                    </div>
                </div>
            
                <!-- Practice Suggestions Section -->
                <div id="practice-suggestions" class="hidden card-layer glass-card">
                     <h3 class="font-bold text-text-primary text-xl mb-4">Xem ví dụ thực tế</h3>
                     <div id="suggestion-links" class="flex flex-col sm:flex-row gap-3 mt-2"></div>
                </div>
            </section>
        </main>

        <div id="message-box" class="fixed bottom-5 right-5 hidden p-4 rounded-xl text-sm z-50 shadow-lg glass-card"></div>
        <audio id="replay-audio" class="hidden"></audio>
        <input type="file" id="audio-upload-input" class="hidden" accept="audio/*">

        <footer class="text-center mt-8 text-text-secondary text-sm">
            <p>© 2025 PrAI. Được tạo ra với niềm đam mê ngôn ngữ bởi Mr Bảo.</p>
        </footer>
    </div>

    <script type="module">
        // --- THEME SWITCHER LOGIC ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const docElement = document.documentElement;

        function applyTheme(theme) {
            docElement.setAttribute('data-theme', theme);
            if (theme === 'light') {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
            localStorage.setItem('prai-theme', theme);
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = docElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        });

        const savedTheme = localStorage.getItem('prai-theme') || 'light';
        applyTheme(savedTheme);


        // --- APP LOGIC ---
        const textInput = document.getElementById('text-input');
        const accentSelect = document.getElementById('accent-select');
        const transcribeBtn = document.getElementById('transcribe-btn');
        const listenNaturalBtn = document.getElementById('listen-natural-btn');
        const listenClearBtn = document.getElementById('listen-clear-btn');
        const listenClearLoader = document.getElementById('listen-clear-loader');
        const listenNaturalLoader = document.getElementById('listen-natural-loader');
        const recordControls = document.getElementById('record-controls');
        const uploadBtn = document.getElementById('upload-btn');
        const recordBtn = document.getElementById('record-btn');
        const listenAgainBtn = document.getElementById('listen-again-btn');
        const randomPracticeBtn = document.getElementById('random-practice-btn');
        const controlsSection = document.getElementById('controls-section');
        const loader = document.getElementById('loader');
        const simpleIpaText = document.getElementById('simple-ipa-text');
        const detailedIpaText = document.getElementById('detailed-ipa-text');
        const analysisResults = document.getElementById('analysis-results');
        const overallScore = document.getElementById('overall-score');
        const phonemeAnalysis = document.getElementById('phoneme-analysis');
        const practiceSuggestions = document.getElementById('practice-suggestions');
        const suggestionLinks = document.getElementById('suggestion-links');
        const messageBox = document.getElementById('message-box');
        const waveformContainer = document.getElementById('waveform-container');
        const waveformEl = document.getElementById('waveform');
        const replayAudio = document.getElementById('replay-audio');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const funFactEl = document.getElementById('fun-fact');
        const connectedSpeechAnalysis = document.getElementById('connected-speech-analysis');
        const connectedSpeechContainer = document.getElementById('connected-speech-container');
        const progressText = document.getElementById('progress-text');
        const progressBarInner = document.getElementById('progress-bar-inner');
        const charCounter = document.getElementById('char-counter');
        const thoughtGroupDisplay = document.getElementById('thought-group-display');
        const thoughtGroupInfo = document.getElementById('thought-group-info');
        const detailedAnalysisContainer = document.getElementById('detailed-analysis-container');
        const prosodyAnalysisContainer = document.getElementById('prosody-analysis-container');
        const prosodyAnalysisTitle = document.getElementById('prosody-analysis-title');
        const prosodyChart = document.getElementById('prosody-chart');
        const prosodyAnalysisFeedback = document.getElementById('prosody-analysis-feedback');
        
        const historyBtn = document.getElementById('history-btn');
        const historyModal = document.getElementById('history-modal');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const historyList = document.getElementById('history-list');
        const clearHistoryBtn = document.getElementById('clear-history-btn');

        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let standardIPA = '';
        let audioContext;
        let analyser;
        let waveformAnimationId;
        let lastRecordingBlob = null;
        let soundDetected = false;
        let ipaLoadingInterval;
        let fetchIpaRequestID = 0;
        let analysisRequestID = 0;
        let progressInterval;
        let progressTextTimeoutIds = [];
        let currentThoughtGroups = [];
        
        let modelPronunciationData = {
            text: '',
            accent: '',
            audio: null,
            pitchContour: [],
            stressedWords: []
        };
        
        const singleWordAudioCache = new Map();

        const ipaCache = {
            get(key) { try { const item = localStorage.getItem(key); return item ? JSON.parse(item) : null; } catch (e) { console.error("Error reading from cache", e); return null; } },
            set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error("Error writing to cache", e); } }
        };

        const funFacts = ["'Ough' có thể được phát âm theo 10 cách khác nhau.", "'Pronunciation' (phát âm) trớ trêu lại là từ bị phát âm sai nhiều nhất.", "Tiếng Anh có tới 20 âm nguyên âm theo hệ thống IPA.", "'Strengths' là từ dài nhất chỉ có một nguyên âm."];
        const practiceSentences = ["What are you doing?", "It's a piece of cake.", "I'll call you back later.", "How's it going?", "Could you please repeat that?", "Where is the nearest station?"];

        // API configuration
        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        const TEXT_API_URL = `/api/proxy`;
        const TTS_API_URL = `/api/proxy`;

        function showMessage(message, type = 'info') {
            const typeClasses = { 'info': 'text-blue-300 border-accent-primary/30', 'success': 'text-green-300 border-accent-success/30', 'warning': 'text-yellow-300 border-accent-warning/30', 'error': 'text-red-300 border-accent-danger/30' };
            messageBox.className = `fixed bottom-5 right-5 p-4 rounded-xl text-sm z-50 shadow-lg glass-card fade-in ${typeClasses[type]}`;
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('hidden'), 5000);
        }

        function handleApiError(error) {
            console.error("API Error:", error);
            if (error.message && (error.message.includes('429') || error.message.toLowerCase().includes('quota'))) {
                showMessage('Hệ thống đang bận. Bạn vui lòng thử lại sau nhé.', 'error');
            } else {
                showMessage(`Đã xảy ra lỗi kết nối: ${error.message}`, 'error');
            }
        }

        function setButtonLoading(button, loader, isLoading) {
            button.disabled = isLoading;
            if (loader) {
                if(isLoading) { button.classList.add('hidden'); loader.classList.remove('hidden'); loader.classList.add('flex'); } 
                else { button.classList.remove('hidden'); loader.classList.add('hidden'); loader.classList.remove('flex'); }
            } else {
                const textEl = button.querySelector('.text');
                const iconEl = button.querySelector('.icon');
                const spinnerEl = button.querySelector('.btn-spinner');
                if (isLoading) {
                    if (textEl) textEl.style.visibility = 'hidden';
                    if (iconEl) iconEl.style.visibility = 'hidden';
                    if (spinnerEl) spinnerEl.classList.remove('hidden');
                } else {
                    if (textEl) textEl.style.visibility = 'visible';
                    if (iconEl) iconEl.style.visibility = 'visible';
                    if (spinnerEl) spinnerEl.classList.add('hidden');
                }
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1, bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } };
            writeString(view, 0, 'RIFF'); view.setUint32(4, 36 + dataSize, true); writeString(view, 8, 'WAVE'); writeString(view, 12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, numChannels, true); view.setUint32(24, sampleRate, true); view.setUint32(28, byteRate, true); view.setUint16(32, blockAlign, true); view.setUint16(34, bitsPerSample, true); writeString(view, 36, 'data'); view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithBackoff(url, options, maxRetries = 4) {
             let delay = 1000;
             for (let i = 0; i < maxRetries; i++) {
                 try {
                     const response = await fetch(url, options);
                     if (response.status === 429 || response.status >= 500) {
                         if (i === maxRetries - 1) throw new Error(`API Error: ${response.status}. Server error after multiple retries.`);
                         await new Promise(resolve => setTimeout(resolve, delay));
                         delay *= 2; continue;
                     }
                     if (!response.ok) {
                         const errorBody = await response.json().catch(() => ({}));
                         throw new Error(`API Error: ${response.status}. ${errorBody.error?.message || 'An unknown error occurred.'}`);
                     }
                     return await response.json();
                 } catch (error) {
                     if (i === maxRetries - 1) throw error;
                     await new Promise(resolve => setTimeout(resolve, delay));
                     delay *= 2;
                 }
             }
         }

        function startIpaLoadingAnimation() {
            clearInterval(ipaLoadingInterval);
            const ipaSymbols = ['ə', 'ʃ', 't', 'd', 'k', 'æ', 'iː', 'θ', 'ð', 'ŋ'];
            let i = 0;
            ipaLoadingInterval = setInterval(() => {
                const symbolSequence = Array(5).fill(0).map((_, j) => ipaSymbols[(i + j) % ipaSymbols.length]).join(' ');
                simpleIpaText.textContent = `/ ${symbolSequence} /`;
                detailedIpaText.textContent = `[ ${symbolSequence} ]`;
                thoughtGroupDisplay.textContent = `...`;
                i = (i + 1) % ipaSymbols.length;
            }, 100);
        }

        function stopIpaLoadingAnimation() { clearInterval(ipaLoadingInterval); }

        function displayIpaData(data, isSingleWord) {
            standardIPA = data.detailed;
            simpleIpaText.textContent = data.simple;
            detailedIpaText.textContent = data.detailed;

            if (!isSingleWord && data.thought_groups) {
                currentThoughtGroups = data.thought_groups.groups;
                displayThoughtGroups(data.thought_groups.groups, data.thought_groups.explanation);
            } else {
                currentThoughtGroups = [];
                displayThoughtGroups([], '');
            }
            controlsSection.classList.remove('hidden');
        }
        
        async function prefetchModelPronunciation(text, accent) {
            if (modelPronunciationData.text === text && modelPronunciationData.accent === accent && modelPronunciationData.audio) return;
            modelPronunciationData = { text, accent, audio: null, pitchContour: [], stressedWords: [] };
            try {
                const textWithPauses = currentThoughtGroups.length > 1 ? currentThoughtGroups.join(" | ") : text;
                const promptTTS = `Read ONLY the following text in ${accent}. The pipe symbol "|" indicates a slight, natural hesitation. Text: ${textWithPauses}`;
                const payloadTTS = { contents: [{ parts: [{ text: promptTTS }] }], generationConfig: { responseModalities: ["AUDIO"] }, model: TTS_MODEL };
                const dataTTS = await fetchWithBackoff(TTS_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' }, body: JSON.stringify(payloadTTS) });
                const audioPart = dataTTS?.candidates?.[0]?.content?.parts?.[0];
                if (!audioPart || !audioPart.inlineData) throw new Error("TTS audio data not received.");
                modelPronunciationData.audio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
                
                const promptAnalysis = `Analyze the audio of "${text}". Output a single JSON object with a 'pitch_contour' (an array of 40-50 normalized pitch points) and 'stressed_words' (an array of objects with 'word' and 'time_stamp_normalized' from 0.0 to 1.0).`;
                const wavBlob = await (await fetch(modelPronunciationData.audio.src)).blob();
                const payloadAnalysis = {
                    contents: [{ role: "user", parts: [ { text: promptAnalysis }, { inlineData: { mimeType: "audio/wav", data: await blobToBase64(wavBlob) } } ] }],
                    generationConfig: { responseMimeType: "application/json", responseSchema: { type: "OBJECT", properties: { "pitch_contour": { type: "ARRAY", items: { type: "NUMBER" } }, "stressed_words": { type: "ARRAY", items: { type: "OBJECT", properties: { "word": { type: "STRING" }, "time_stamp_normalized": { type: "NUMBER" } } } } } } }
                };
                const dataAnalysis = await fetchWithBackoff(TEXT_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, body: JSON.stringify(payloadAnalysis) });
                const resultJson = JSON.parse(dataAnalysis.candidates[0].content.parts[0].text);
                modelPronunciationData.pitchContour = resultJson.pitch_contour || [];
                modelPronunciationData.stressedWords = resultJson.stressed_words || [];
                console.log("Model pronunciation data prefetched.", modelPronunciationData);
            } catch (error) {
                console.error("Model pronunciation prefetch failed:", error);
                modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
            }
        }
        
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(',')[1]);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        async function fetchAndDisplayIPA() {
            fetchIpaRequestID++;
            const currentRequestID = fetchIpaRequestID;
            const text = textInput.value.trim();
            if (!text) { resetAll(); return false; }
            
            const isSingleWord = !text.includes(' ');
            updateUIMode(isSingleWord);

            const accent = accentSelect.value;
            const cacheKey = `ipa_${text}_${accent}`;
            const cachedData = ipaCache.get(cacheKey);

            if (cachedData) {
                displayIpaData(cachedData, isSingleWord);
                if (isSingleWord) fetchSingleWordAudio(text, accent); else prefetchModelPronunciation(text, accent);
                return true;
            }
            
            const prompt = isSingleWord
                ? `Provide a single JSON object for the word "${text}" in ${accent}. The JSON must have one key: 'simple', containing the standard IPA transcription. Do not include any other analysis.`
                : `For the phrase "${text}" in ${accent}, provide a single JSON object with 'simple' (standard IPA), 'detailed' (natural speech IPA with correct liaison ‿ symbols within thought groups), and 'thought_groups' (an object with 'groups' array and a Vietnamese 'explanation'). Respond with ONLY the JSON object.`;
            
            setButtonLoading(transcribeBtn, null, true);
            controlsSection.classList.remove('hidden');
            startIpaLoadingAnimation();
            
            try {
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseMimeType: "application/json" } };
                const response = await fetchWithBackoff(TEXT_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, body: JSON.stringify(payload) });
                if (currentRequestID !== fetchIpaRequestID) return false;

                let resultJson = JSON.parse(response.candidates[0].content.parts[0].text);
                if (isSingleWord) resultJson.detailed = resultJson.simple;

                ipaCache.set(cacheKey, resultJson);
                displayIpaData(resultJson, isSingleWord);
                if (isSingleWord) fetchSingleWordAudio(text, accent); else prefetchModelPronunciation(text, accent);
                return true;
            } catch (error) {
                if (currentRequestID === fetchIpaRequestID) { handleApiError(error); resetAll(); }
                return false;
            } finally {
                if (currentRequestID === fetchIpaRequestID) { stopIpaLoadingAnimation(); setButtonLoading(transcribeBtn, null, false); }
            }
        }

        function displayThoughtGroups(groups, explanation) {
            thoughtGroupDisplay.innerHTML = '';
            thoughtGroupTooltip.textContent = explanation || '';
            if (groups && groups.length > 0 && explanation) {
                thoughtGroupInfo.style.display = 'block';
                groups.forEach((group, index) => {
                    const groupSpan = document.createElement('span');
                    groupSpan.textContent = group;
                    groupSpan.className = `thought-group thought-group-${index % 4}`;
                    thoughtGroupDisplay.appendChild(groupSpan);
                });
            } else {
                thoughtGroupInfo.style.display = 'none';
            }
        }

        async function fetchSingleWordAudio(text, accent) {
            const cacheKey = `${text}_${accent}`;
            if (singleWordAudioCache.has(cacheKey)) return; // Already fetched
            try {
                const prompt = `Read ONLY the following word in ${accent}: ${text}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseModalities: ["AUDIO"] }, model: TTS_MODEL };
                const data = await fetchWithBackoff(TTS_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' }, body: JSON.stringify(payload) });
                const audioPart = data?.candidates?.[0]?.content?.parts?.[0];
                if (audioPart && audioPart.inlineData) {
                    const audio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
                    singleWordAudioCache.set(cacheKey, audio);
                }
            } catch (error) {
                console.error(`Failed to pre-fetch audio for ${text}:`, error);
            }
        }

        async function handleListen(type) {
            const text = textInput.value.trim();
            const accent = accentSelect.value;
            if (!text) { showMessage('Vui lòng nhập từ hoặc câu để nghe.', 'warning'); return; }
            
            const isSingleWord = !text.includes(' ');
            const button = type === 'natural' ? listenNaturalBtn : listenClearBtn;
            const loader = type === 'natural' ? listenNaturalLoader : listenClearLoader;

            setButtonLoading(button, loader, true);
            try {
                const cacheKey = `${text}_${accent}`;
                if (singleWordAudioCache.has(cacheKey)) {
                    singleWordAudioCache.get(cacheKey).play();
                } else if (!isSingleWord && modelPronunciationData.text === text && modelPronunciationData.accent === accent && modelPronunciationData.audio) {
                    modelPronunciationData.audio.currentTime = 0;
                    modelPronunciationData.audio.play();
                } else {
                    // Fallback: fetch on demand
                    const prompt = type === 'natural' 
                        ? `Read ONLY the following text in ${accent}. Text: ${text}`
                        : `Say very clearly, with a slight pause between each word, in ${accent}: ${text}`;
                    const payload = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { responseModalities: ["AUDIO"] }, model: TTS_MODEL };
                    const data = await fetchWithBackoff(TTS_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' }, body: JSON.stringify(payload) });
                    const audioPart = data?.candidates?.[0]?.content?.parts?.[0];
                    if (audioPart && audioPart.inlineData) {
                        const audio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
                        audio.play();
                        // Cache it for next time
                        if(isSingleWord) singleWordAudioCache.set(cacheKey, audio);
                    } else { throw new Error("Không nhận được dữ liệu âm thanh hợp lệ."); }
                }
            } catch (error) {
                handleApiError(error);
            } finally {
                setButtonLoading(button, loader, false);
            }
        }
        
        async function createAudioFromBase64(base64Data, mimeType) {
            const sampleRate = mimeType.match(/rate=(\d+)/) ? parseInt(mimeType.match(/rate=(\d+)/)[1], 10) : 24000;
            const pcmData = base64ToArrayBuffer(base64Data);
            const pcm16 = new Int16Array(pcmData);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            return new Audio(audioUrl);
        }

        function startProgressSimulation() {
            if (!progressBarInner) return;
            let width = 0;
            progressBarInner.style.width = '0%';
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                if (width < 95) width += Math.random() * 2; else clearInterval(progressInterval);
                progressBarInner.style.width = Math.min(width, 95) + '%';
            }, 100);
        }

        function stopProgressSimulation() {
            clearInterval(progressInterval);
            if (progressBarInner) progressBarInner.style.width = '100%';
        }

        function startProgressTextAnimation() {
            const steps = [ { text: "Okie, PrAI đã nhận được bản ghi âm của bạn...", duration: 1500 }, { text: "Đang phiên âm giọng nói của bạn!", duration: 2500 }, { text: "So sánh từng âm một với giọng chuẩn...", duration: 3000 }, { text: "Phân tích các yếu tố khác...", duration: 2000 }, { text: "Xong rồi! Cùng xem kết quả tuyệt vời của bạn nhé!", duration: 1000 } ];
            let cumulativeDelay = 0;
            stopProgressTextAnimation();
            steps.forEach((step) => {
                const timeoutId = setTimeout(() => { if (progressText) progressText.textContent = step.text; }, cumulativeDelay);
                progressTextTimeoutIds.push(timeoutId);
                cumulativeDelay += step.duration;
            });
        }
        
        function stopProgressTextAnimation() {
            progressTextTimeoutIds.forEach(clearTimeout);
            progressTextTimeoutIds = [];
        }

        async function analyzeAudio(audioBlob) {
            const currentAnalysisID = ++analysisRequestID;
            if (!audioBlob) return;
            lastRecordingBlob = audioBlob;
            listenAgainBtn.disabled = false;
            if (!standardIPA) { showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error'); return; }
            
            const text = textInput.value.trim();
            const isSingleWord = !text.includes(' ');

            if (!isSingleWord) {
                if (modelPronunciationData.text !== text || modelPronunciationData.accent !== accentSelect.value) await prefetchModelPronunciation(text, accentSelect.value);
                if (!modelPronunciationData.pitchContour || modelPronunciationData.pitchContour.length === 0) { showMessage('Chưa có dữ liệu ngữ điệu mẫu, vui lòng thử lại.', 'error'); return; }
            }

            loader.classList.remove('hidden');
            startProgressTextAnimation();
            startProgressSimulation();
            funFactEl.textContent = `💡 ${funFacts[Math.floor(Math.random() * funFacts.length)]}`;
            funFactEl.classList.remove('hidden');
            
            const base64Audio = await blobToBase64(lastRecordingBlob);
            if (currentAnalysisID !== analysisRequestID) { /* Abort if new request started */ return; }

            const prompt = isSingleWord 
                ? `You are PrAI, an expert AI phonetics coach. Analyze the user's pronunciation of the English word "${text}" (${accentSelect.value}) against the standard IPA "${standardIPA}".
                  **CRITICAL RULES:**
                  1.  **Word Mismatch:** If the audio contains a completely different word, respond ONLY with: \`{"word_mismatch": true, "detected_word": "[the word you heard]"}\`. DO NOT analyze further.
                  2.  **Strict Analysis:** Be extremely precise. Your analysis must be scientific and rigorous.
                  3.  **Output Format:** Respond with a single JSON object.
                  **JSON SCHEMA:**
                  {
                    "word_mismatch": false,
                    "overall_score": "number (0-100, calculated based on phoneme accuracy)",
                    "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string (in Vietnamese, be specific, e.g., 'Âm /t/ cuối bị nuốt. Hãy bật hơi rõ hơn.')\" } ]",
                    "syllable_analysis": "{ \"standard_syllables\": [\"string\"], \"standard_stress_index\": number, \"user_syllables\": [\"string\"], \"user_stress_index\": number, \"feedback\": \"string (in Vietnamese)\" }"
                  }`
                : `You are PrAI, an expert AI phonetics coach for Vietnamese learners. Analyze the user's pronunciation of the sentence "${text}" (${accentSelect.value}) against the standard IPA "${standardIPA}".
                  **CRITICAL RULES:**
                  1.  **Sentence Mismatch:** If the user says a completely different sentence, respond ONLY with: \`{"sentence_mismatch": true}\`. DO NOT analyze.
                  2.  **Leniency:** Be understanding of common Vietnamese learner errors. For example, if a final /t/ is pronounced as a glottal stop [ʔ] or unreleased, be lenient in scoring.
                  3.  **Focus:** Do not score rhythm. Focus on overall intonation, pacing, and flow in your feedback.
                  4.  **Output Format:** Respond with a single JSON object.
                  **JSON SCHEMA:**
                  {
                    "sentence_mismatch": false,
                    "overall_score": "number (0-100)",
                    "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string (in Vietnamese)\" } ]",
                    "intonation_analysis": "{ \"feedback\": \"string (in Vietnamese, comment on intonation, speed, and rhythm)\", \"user_pitch_contour\": [number] }",
                    "connected_speech_analysis": "[{ \"type\": \"string ('Catenation', etc.)\", \"rule\": \"string\", \"location\": \"string\", \"expected_pronunciation\": \"string\", \"user_pronunciation\": \"string\", \"feedback\": \"string (in Vietnamese)\" }] | null",
                    "practice_suggestions": "{ \"youglish_us\": \"string\", \"youglish_uk\": \"string\" } | null"
                  }`;

            const payload = {
                contents: [ { role: "user", parts: [ { text: prompt }, { inlineData: { mimeType: "audio/webm", data: base64Audio } } ] } ],
                generationConfig: { responseMimeType: "application/json" }
            };

            try {
                const data = await fetchWithBackoff(TEXT_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, body: JSON.stringify(payload) });
                if (currentAnalysisID !== analysisRequestID) return;
                const resultJson = JSON.parse(data.candidates[0].content.parts[0].text);
                displayResults(resultJson, isSingleWord);
            } catch (error) {
                if (currentAnalysisID === analysisRequestID) handleApiError(error);
            } finally {
                if (currentAnalysisID === analysisRequestID) {
                    stopProgressSimulation(); stopProgressTextAnimation();
                    setTimeout(() => { loader.classList.add('hidden'); funFactEl.classList.add('hidden'); }, 500);
                }
            }
        }
        
        function displayResults(data, isSingleWord) {
            if (data.word_mismatch) {
                showMessage(`Bạn đã phát âm một từ khác: "${data.detected_word}". Vui lòng thử lại với từ "${textInput.value.trim()}".`, 'error');
                return;
            }
            if (data.sentence_mismatch) {
                showMessage(`Bạn dường như đã đọc một câu khác. Vui lòng thử lại với câu đã nhập.`, 'error');
                return;
            }
            if (data.overall_score === null || data.overall_score === undefined) {
                showMessage("PrAI không nhận diện được giọng nói. Vui lòng thử lại và nói to, rõ hơn.", 'warning');
                return;
            }
        
            saveToHistory(textInput.value.trim(), data.overall_score);
            analysisResults.classList.remove('hidden');
        
            const scoreContainer = document.querySelector('.score-container');
            animateValue(overallScore, 0, data.overall_score, 1000);
            scoreContainer.className = 'score-container';
            if (data.overall_score > 85) scoreContainer.classList.add('score-high');
            else if (data.overall_score > 70) scoreContainer.classList.add('score-medium');
            else scoreContainer.classList.add('score-low');
        
            phonemeAnalysis.innerHTML = '';
            data.phoneme_analysis?.forEach(p => {
                const phonemeEl = document.createElement('div');
                phonemeEl.textContent = p.phoneme;
                phonemeEl.className = `phoneme has-tooltip status-${p.status}`;
                if (p.feedback) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = p.feedback;
                    phonemeEl.appendChild(tooltip);
                }
                phonemeAnalysis.appendChild(phonemeEl);
            });
            
            // --- DYNAMIC ANALYSIS SECTION ---
            prosodyAnalysisContainer.style.display = 'block';
            connectedSpeechContainer.style.display = isSingleWord ? 'none' : 'block';

            if (isSingleWord) {
                prosodyAnalysisTitle.textContent = 'Phân tích Âm tiết';
                prosodyAnalysisFeedback.textContent = data.syllable_analysis.feedback;
                renderSyllableChart(prosodyChart, data.syllable_analysis);
            } else {
                prosodyAnalysisTitle.textContent = 'Phân tích Ngữ điệu';
                prosodyAnalysisFeedback.textContent = data.intonation_analysis.feedback;
                renderIntonationChart(prosodyChart, modelPronunciationData.pitchContour, data.intonation_analysis.user_pitch_contour, modelPronunciationData.stressedWords);
                
                connectedSpeechAnalysis.innerHTML = '';
                if (data.connected_speech_analysis && data.connected_speech_analysis.length > 0) {
                    data.connected_speech_analysis.forEach(item => {
                        const itemEl = document.createElement('div');
                        const typeClass = `type-${item.type.split(' ')[0].toLowerCase()}`;
                        itemEl.className = `connected-speech-item ${typeClass}`;
                        itemEl.innerHTML = `<div class="flex justify-between items-start"><div><p class="cs-title">${item.rule}</p><p class="cs-details mt-1">Vị trí: <span class="cs-location">${item.location}</span></p></div><span class="text-xs font-semibold uppercase px-2 py-1 rounded-full ${typeClass} opacity-70">${item.type}</span></div><div class="cs-details mt-2"><p>Phát âm mong đợi: <span class="ipa-text text-accent-success">${item.expected_pronunciation}</span></p><p>Phát âm của bạn: <span class="ipa-text text-accent-warning">${item.user_pronunciation}</span></p></div><p class="cs-feedback text-sm">${item.feedback}</p>`;
                        connectedSpeechAnalysis.appendChild(itemEl);
                    });
                } else {
                    connectedSpeechAnalysis.innerHTML = '<p class="text-text-secondary text-sm italic">Không có nhận xét nổi bật về nối âm. Lời nói của bạn khá rõ ràng nhưng có thể chưa thể hiện được sự liên kết tự nhiên.</p>';
                }
            }
        
            if (data.practice_suggestions) {
                suggestionLinks.innerHTML = `<a href="${data.practice_suggestions.youglish_us}" target="_blank" class="btn btn-primary flex-1">Giọng Mỹ (YouGlish)</a><a href="${data.practice_suggestions.youglish_uk}" target="_blank" class="btn btn-primary flex-1">Giọng Anh (YouGlish)</a>`;
                practiceSuggestions.classList.remove('hidden');
            } else {
                practiceSuggestions.classList.add('hidden');
            }
        }

        function resetAnalysisOnly() { analysisResults.classList.add('hidden'); practiceSuggestions.classList.add('hidden'); }
        function resetAll() {
            standardIPA = '';
            controlsSection.classList.add('hidden');
            resetAnalysisOnly();
            const text = textInput.value.trim();
            const accent = accentSelect.value;
            if (modelPronunciationData.text !== text || modelPronunciationData.accent !== accent) {
                 modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
            }
            currentThoughtGroups = [];
            displayThoughtGroups([], '');
        }

        async function handleRecord() {
            if (isRecording) { mediaRecorder.stop(); return; }
            if (!textInput.value.trim()) { showMessage('Vui lòng nhập từ để ghi âm và phân tích.', 'warning'); return; }
            
            resetAnalysisOnly(); 
            listenAgainBtn.disabled = true;
            lastRecordingBlob = null;
            
            try {
                if (!standardIPA) {
                    const ipaReady = await fetchAndDisplayIPA();
                    if (!ipaReady) { showMessage('Chưa có phiên âm chuẩn, không thể bắt đầu ghi âm.', 'warning'); return; }
                }
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true; soundDetected = false; audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = () => {
                    isRecording = false; stopWaveform(); stream.getTracks().forEach(track => track.stop());
                    recordBtn.querySelector('.text').classList.add('hidden');
                    recordBtn.querySelector('.icon').classList.remove('hidden');
                    recordBtn.classList.remove('is-recording');
                    if (soundDetected) analyzeAudio(new Blob(audioChunks, { type: 'audio/webm' }));
                    else showMessage("PrAI không phát hiện thấy âm thanh. Vui lòng thử ghi âm lại nhé.", "error");
                };
                mediaRecorder.start();
                startWaveform(stream);
                const recordBtnText = recordBtn.querySelector('.text');
                recordBtnText.textContent = 'Dừng';
                recordBtnText.classList.remove('hidden');
                recordBtn.querySelector('.icon').classList.add('hidden');
                recordBtn.classList.add('is-recording');
            } catch (error) {
                console.error("Error accessing microphone:", error);
                showMessage('Không thể truy cập micro. Vui lòng cấp quyền và thử lại.', 'error');
            }
        }

        function handleListenAgain() {
            if (lastRecordingBlob) {
                const audioUrl = URL.createObjectURL(lastRecordingBlob);
                replayAudio.src = audioUrl;
                replayAudio.play();
            }
        }

        function startWaveform(stream) {
            uploadBtn.style.display = 'none'; listenAgainBtn.style.display = 'none'; waveformContainer.classList.remove('hidden');
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const accentPrimaryColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim();
            const accentSuccessColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-success').trim();
            const canvas = waveformEl, canvasCtx = canvas.getContext('2d');
            function draw() {
                waveformAnimationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);
                if (dataArray.reduce((s, v) => s + v, 0) / bufferLength > 15) soundDetected = true;
                canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                const barWidth = (canvas.width / bufferLength) * 1.5; let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2.5;
                    const gradient = canvasCtx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                    gradient.addColorStop(0, accentPrimaryColor); gradient.addColorStop(1, accentSuccessColor);
                    canvasCtx.fillStyle = gradient; canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function stopWaveform() {
            if (waveformAnimationId) cancelAnimationFrame(waveformAnimationId);
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            uploadBtn.style.display = 'inline-flex'; listenAgainBtn.style.display = 'inline-flex'; waveformContainer.classList.add('hidden');
        }

        function getHistory() { return JSON.parse(localStorage.getItem('prai-history') || '[]'); }
        function saveToHistory(text, score) {
            if (!text) return; let history = getHistory();
            const newEntry = { text, score, date: new Date().toISOString() };
            history = history.filter(item => item.text !== text);
            history.unshift(newEntry);
            if (history.length > 20) history = history.slice(0, 20);
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }
        function loadHistory() {
            const history = getHistory(); historyList.innerHTML = '';
            if (history.length === 0) { historyList.innerHTML = `<p class="text-text-secondary text-center italic">Chưa có lịch sử luyện tập.</p>`; clearHistoryBtn.classList.add('hidden'); return; }
            clearHistoryBtn.classList.remove('hidden');
            history.forEach(item => {
                const scoreColor = item.score > 85 ? 'bg-green-500/20 text-green-600 dark:text-green-400' : item.score > 70 ? 'bg-yellow-500/20 text-yellow-600 dark:text-yellow-400' : 'bg-red-500/20 text-red-600 dark:text-red-400';
                const itemEl = document.createElement('div');
                itemEl.className = 'history-item flex justify-between items-center p-2 rounded-md';
                itemEl.innerHTML = `<div class="flex-grow truncate pr-4" data-action="select"><p class="truncate history-item-text">${item.text}</p></div><div class="flex items-center gap-3 flex-shrink-0"><div class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-xl ${scoreColor}">${item.score}</div><button class="btn btn-secondary btn-icon !w-8 !h-8 text-accent-danger/70 hover:!bg-accent-danger/20" data-action="delete"><svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button></div>`;
                itemEl.dataset.text = item.text; historyList.appendChild(itemEl);
            });
        }
        function deleteHistoryItem(textToDelete) { let history = getHistory(); history = history.filter(item => item.text !== textToDelete); localStorage.setItem('prai-history', JSON.stringify(history)); loadHistory(); }
        function clearHistory() { localStorage.removeItem('prai-history'); loadHistory(); }
        function handleHistoryClick(event) {
            const target = event.target.closest('[data-action]'); if (!target) return;
            const action = target.dataset.action; const parentItem = target.closest('.history-item'); const text = parentItem.dataset.text;
            if (action === 'select') { textInput.value = text; charCounter.textContent = `${text.length} / 150`; historyModal.classList.remove('is-visible'); resetAll(); fetchAndDisplayIPA(); } 
            else if (action === 'delete') { deleteHistoryItem(text); }
        }
        
        function animateValue(obj, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerHTML = Math.floor(progress * (end - start) + start);
                if (progress < 1) window.requestAnimationFrame(step);
            };
            window.requestAnimationFrame(step);
        }
        
        function renderIntonationChart(svgElement, modelData, userData, stressedWords = []) {
            svgElement.innerHTML = ''; 
            if (!modelData || !userData || modelData.length === 0 || userData.length === 0) return;
            const padding = { top: 30, right: 10, bottom: 20, left: 10 };
            const width = svgElement.clientWidth, height = svgElement.clientHeight;
            const innerWidth = width - padding.left - padding.right, innerHeight = height - padding.top - padding.bottom;
            const allData = [...modelData, ...userData];
            const yMin = Math.min(...allData), yMax = Math.max(...allData) > yMin ? Math.max(...allData) : yMin + 1;
            const scaleX = (index, dataLength) => padding.left + (index / (dataLength - 1)) * innerWidth;
            const scaleY = (value) => padding.top + innerHeight - ((value - yMin) / (yMax - yMin)) * innerHeight;
            const modelPoints = modelData.map((d, i) => `${scaleX(i, modelData.length)},${scaleY(d)}`).join(' ');
            const userPoints = userData.map((d, i) => `${scaleX(i, userData.length)},${scaleY(d)}`).join(' ');
            
            svgElement.innerHTML = `
                <polyline points="${modelPoints}" fill="none" stroke="var(--accent-primary)" stroke-width="2"/>
                <polyline points="${userPoints}" fill="none" stroke="var(--accent-warning)" stroke-width="2.5" stroke-dasharray="4 4"/>
                <g>
                    <rect x="${innerWidth - 180}" y="${height - 15}" width="12" height="2" fill="var(--accent-primary)" />
                    <text x="${innerWidth - 165}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng mẫu</text>
                    <rect x="${innerWidth - 90}" y="${height - 15}" width="12" height="2" fill="var(--accent-warning)" stroke-dasharray="2 2" stroke="var(--accent-warning)" />
                    <text x="${innerWidth - 75}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng của bạn</text>
                </g>
            `;
            
            stressedWords.forEach(item => {
                const x = padding.left + (item.time_stamp_normalized * innerWidth);
                const closestModelPointIndex = Math.round(item.time_stamp_normalized * (modelData.length - 1));
                const y = scaleY(modelData[closestModelPointIndex]) - 8; // Position above the model line
                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', x); textEl.setAttribute('y', y); textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('font-size', '12'); textEl.setAttribute('font-weight', '600'); textEl.setAttribute('fill', 'var(--text-primary)');
                textEl.textContent = item.word;
                svgElement.appendChild(textEl);
            });
        }

        function renderSyllableChart(svgElement, data) {
            svgElement.innerHTML = '';
            if (!data || !data.standard_syllables) return;
            const { standard_syllables, standard_stress_index, user_syllables, user_stress_index } = data;
            const padding = { top: 20, right: 10, bottom: 40, left: 10 };
            const width = svgElement.clientWidth, height = svgElement.clientHeight;
            const innerWidth = width - padding.left - padding.right;
            
            const barWidth = Math.min(60, innerWidth / standard_syllables.length * 0.7);
            const barSpacing = (innerWidth - (barWidth * standard_syllables.length)) / (standard_syllables.length + 1);
            
            const drawSyllables = (syllables, stressIndex, yOffset, label) => {
                syllables.forEach((syllable, i) => {
                    const isStressed = (i === stressIndex);
                    const x = padding.left + barSpacing * (i + 1) + barWidth * i;
                    const barHeight = isStressed ? 60 : 40;
                    const color = isStressed ? 'var(--accent-primary)' : 'var(--text-secondary)';
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', x); rect.setAttribute('y', yOffset - barHeight);
                    rect.setAttribute('width', barWidth); rect.setAttribute('height', barHeight);
                    rect.setAttribute('rx', 4); rect.setAttribute('fill', color);
                    svgElement.appendChild(rect);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x + barWidth / 2); text.setAttribute('y', yOffset + 15);
                    text.setAttribute('text-anchor', 'middle'); text.setAttribute('font-size', '14'); text.setAttribute('fill', 'var(--text-primary)');
                    text.textContent = syllable;
                    svgElement.appendChild(text);
                });
                const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', padding.left + innerWidth / 2); labelText.setAttribute('y', yOffset + 35);
                labelText.setAttribute('text-anchor', 'middle'); labelText.setAttribute('font-size', '12'); labelText.setAttribute('font-style', 'italic');
                labelText.setAttribute('fill', 'var(--text-secondary)'); labelText.textContent = label;
                svgElement.appendChild(labelText);
            };

            drawSyllables(standard_syllables, standard_stress_index, 70, 'Âm tiết chuẩn');
        }

        function updateUIMode(isSingleWord) {
            if (isSingleWord) {
                detailedAnalysisContainer.classList.add('opacity-50', 'pointer-events-none');
            } else {
                detailedAnalysisContainer.classList.remove('opacity-50', 'pointer-events-none');
            }
        }

        function initApp() {
            accentSelect.value = 'British English';
            textInput.addEventListener('input', () => {
                const text = textInput.value;
                charCounter.textContent = `${text.length} / 150`;
                updateUIMode(!text.includes(' '));
                resetAll();
            });
            accentSelect.addEventListener('change', () => { if (textInput.value.trim()) { resetAll(); fetchAndDisplayIPA(); } });
            transcribeBtn.addEventListener('click', () => fetchAndDisplayIPA());
            listenNaturalBtn.addEventListener('click', () => handleListen('natural'));
            listenClearBtn.addEventListener('click', () => handleListen('clear'));
            recordBtn.addEventListener('click', handleRecord);
            listenAgainBtn.addEventListener('click', handleListenAgain);
            randomPracticeBtn.addEventListener('click', () => {
                const randomSentence = practiceSentences[Math.floor(Math.random() * practiceSentences.length)];
                textInput.value = randomSentence;
                charCounter.textContent = `${randomSentence.length} / 150`;
                updateUIMode(false);
                resetAll();
                fetchAndDisplayIPA();
            });
            uploadBtn.addEventListener('click', () => audioUploadInput.click());
            historyBtn.addEventListener('click', () => { loadHistory(); historyModal.classList.add('is-visible'); });
            closeHistoryBtn.addEventListener('click', () => historyModal.classList.remove('is-visible'));
            historyModal.addEventListener('click', (e) => { if (e.target === historyModal) historyModal.classList.remove('is-visible'); });
            clearHistoryBtn.addEventListener('click', clearHistory);
            historyList.addEventListener('click', handleHistoryClick);
            audioUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('audio/')) {
                    (async () => {
                        if (!textInput.value.trim()) { showMessage('Vui lòng nhập văn bản tương ứng với file âm thanh trước.', 'warning'); return; }
                        resetAnalysisOnly(); 
                        if (!standardIPA) { if (!(await fetchAndDisplayIPA())) { showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error'); return; } }
                        analyzeAudio(file);
                    })();
                } else if (file) { showMessage('Vui lòng chọn một tệp âm thanh hợp lệ.', 'warning'); }
                event.target.value = null;
            });
            textInput.addEventListener('keydown', (event) => { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); fetchAndDisplayIPA(); } });
            updateUIMode(!textInput.value.includes(' '));
        }

        initApp();
    </script>
</body>
</html>
