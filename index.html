<!DOCTYPE html>
<html lang="vi" data-theme="light"> <!-- Default to light theme -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PrAI - Luyện Phát Âm với AI</title>
    <!-- NEW FAVICON -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23007CF0;'/%3E%3Cstop offset='100%25' style='stop-color:%2300DFD8;'/%3E%3C/linearGradient%E3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='url(%23g)'/%3E%3Ctext x='50' y='55' font-family='Exo 2, sans-serif' font-size='40' font-weight='700' fill='white' text-anchor='middle' dominant-baseline='middle'%3EPrAI%3C/text%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans:wght@400;700&family=Exo+2:wght@700&display=swap" rel="stylesheet">
    <style>
        /* --- GLASSMORPHISM THEME V12 --- */
        :root {
            /* Default: Light Theme */
            --bg-color: #f8fafc; /* slate-50 */
            --bg-blob-1: #0ea5e9; /* sky-500 */
            --bg-blob-2: #14b8a6; /* teal-500 */
            --glass-bg: rgba(248, 250, 252, 0.6); /* slate-50 @ 60% */
            --glass-border: rgba(255, 255, 255, 0.7); /* Brighter border for glass edge effect */
            --text-primary: #0f172a; /* slate-900 */
            --text-secondary: #475569; /* slate-600 */
            --accent-primary: #007CF0;
            --accent-danger: #ef4444; /* red-500 */
            --accent-success: #22c55e; /* green-500 */
            --accent-warning: #f59e0b; /* amber-500 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0056b3;
            --btn-secondary-bg: rgba(241, 245, 249, 0.7); /* slate-100 @ 70% */
            --btn-secondary-hover-bg: rgba(226, 232, 240, 0.9); /* slate-200 @ 90% */
            --input-bg: rgba(255, 255, 255, 0.4);
            --input-focus-bg: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(100, 116, 139, 0.2); /* slate-400 */
            --highlight-correct: rgba(34, 197, 94, 0.1);
            --highlight-approximate: rgba(245, 158, 11, 0.1);
            --highlight-incorrect: rgba(239, 68, 68, 0.1);
            --radius-sm: 0.75rem;
            --radius-md: 1rem;
            --radius-lg: 1.5rem;
        }

        [data-theme="dark"] {
            --bg-color: #020617; /* slate-950 */
            --bg-blob-1: #0369a1; /* cyan-700 */
            --bg-blob-2: #0d9488; /* teal-600 */
            --glass-bg: rgba(30, 41, 59, 0.5); /* slate-800 @ 50% */
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-primary: #f1f5f9; /* slate-100 */
            --text-secondary: #94a3b8; /* slate-400 */
            --btn-primary-bg: #007CF0;
            --btn-primary-hover-bg: #0095ff;
            --btn-secondary-bg: rgba(51, 65, 85, 0.5); /* slate-700 @ 50% */
            --btn-secondary-hover-bg: rgba(51, 65, 85, 0.8);
            --input-bg: rgba(15, 23, 42, 0.5); /* slate-900 @ 50% */
            --input-focus-bg: rgba(15, 23, 42, 0.7);
            --shadow-color: rgba(0, 0, 0, 0.35);
            --highlight-correct: rgba(74, 222, 128, 0.15);
            --highlight-approximate: rgba(250, 204, 21, 0.15);
            --highlight-incorrect: rgba(248, 113, 113, 0.15);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            position: relative;
        }
        
        .background-container {
            width: 100%; height: 100%; position: fixed;
            top: 0; left: 0; z-index: -1; overflow: hidden;
        }
        .blob { position: absolute; border-radius: 50%; filter: blur(120px); opacity: 0.4; }
        .blob-1 { width: 450px; height: 450px; background: var(--bg-blob-1); animation: move 20s infinite alternate; }
        .blob-2 { width: 350px; height: 350px; background: var(--bg-blob-2); animation: move 25s infinite alternate-reverse; animation-delay: -5s; }

        @keyframes move {
            from { transform: translate(-15vw, -15vh) scale(1) rotate(0deg); }
            to { transform: translate(65vw, 75vh) scale(1.2) rotate(180deg); }
        }

        .font-logo { font-family: 'Exo 2', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text, .phoneme, .ipa-text { font-family: 'Noto Sans', sans-serif; }
        #simple-ipa-text, #detailed-ipa-text { word-break: break-word; }

        .glass-card {
            background-color: var(--glass-bg);
            backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px);
            box-shadow: 0 8px 32px 0 var(--shadow-color), inset 0 1px 0 0 var(--glass-border);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            transition: all 0.3s ease-in-out;
        }

        .main-card { padding: clamp(1rem, 5vw, 2.5rem); }
        .card-layer { padding: 1.5rem; border-radius: var(--radius-md); }
        .card-layer-inset {
            background-color: var(--input-bg); padding: 1rem; border-radius: var(--radius-md);
            border: 1px solid var(--glass-border); box-shadow: inset 0 2px 4px var(--shadow-color);
        }

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem;
            padding: 0.75rem 1.5rem; border-radius: var(--radius-sm); font-weight: 600;
            border: 1px solid transparent; cursor: pointer; transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 10px var(--shadow-color);
        }
        .btn:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 8px 20px var(--shadow-color); }
        .btn:active:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 10px var(--shadow-color); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-primary { background-color: var(--btn-primary-bg); color: #ffffff; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        .btn-primary:hover:not(:disabled) { background-color: var(--btn-primary-hover-bg); }

        .btn-secondary {
            background-color: var(--btn-secondary-bg); color: var(--text-secondary);
            border: 1px solid var(--glass-border); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
        }
        .btn-secondary:hover:not(:disabled) { background-color: var(--btn-secondary-hover-bg); color: var(--text-primary); }

        .btn-icon {
            width: 2.75rem; height: 2.75rem; border-radius: 50%;
            padding: 0; flex-shrink: 0; position: relative;
            display: inline-flex; align-items: center; justify-content: center;
        }
        .btn-icon > .icon { margin: auto; }
        
        .btn-record {
            width: 7rem; height: 7rem; border-radius: 50%;
            background: radial-gradient(circle, #ff5f5f 0%, #ef4444 100%);
            color: #ffffff; font-weight: 600; cursor: pointer;
            box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2);
            transition: all 0.2s ease-in-out;
            border: 3px solid rgba(255, 255, 255, 0.4);
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .btn-record:hover:not(:disabled) { transform: scale(1.05); box-shadow: 0 15px 30px color-mix(in srgb, var(--accent-danger) 40%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2); }
        .btn-record.is-recording { animation: pulse 1.5s infinite; }

        @keyframes pulse {
            0% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 70%, transparent); }
            70% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 15px color-mix(in srgb, var(--accent-danger) 0%, transparent); }
            100% { box-shadow: 0 10px 25px color-mix(in srgb, var(--accent-danger) 30%, transparent), inset 0 -4px 8px rgba(0,0,0,0.2), 0 0 0 0 color-mix(in srgb, var(--accent-danger) 0%, transparent); }
        }
        
        .input-field {
            width: 100%; background-color: var(--input-bg); border: 1px solid var(--glass-border);
            border-radius: var(--radius-sm); padding: 0.75rem 1rem; color: var(--text-primary);
            transition: all 0.2s ease-in-out; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
        }
        .input-field:focus {
            outline: none; border-color: var(--accent-primary); background-color: var(--input-focus-bg);
            box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }
        textarea.input-field { resize: vertical; min-height: 80px; }

        .phoneme {
            padding: 0.5rem 0.75rem; border-radius: 0.5rem; font-size: 1.125rem;
            position: relative; transition: all 0.2s ease-in-out; color: var(--text-secondary);
        }
        .phoneme.status-correct { background-color: var(--highlight-correct); color: var(--accent-success); }
        .phoneme.status-approximate { background-color: var(--highlight-approximate); color: var(--accent-warning); }
        .phoneme.status-incorrect { background-color: var(--highlight-incorrect); color: var(--accent-danger); }

        .tooltip {
            visibility: hidden; opacity: 0; transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translate(-50%, 10px); background-color: var(--bg-color); color: var(--text-primary);
            border: 1px solid var(--glass-border); z-index: 20;
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-bottom: 0.5rem;
            width: 256px;
            border-radius: 0.75rem;
            padding: 0.75rem;
            font-size: 0.875rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .has-tooltip:hover .tooltip { 
             visibility: visible; 
             opacity: 1; 
        }
        
        .score-container {
            width: 140px; height: 140px; margin: 1rem auto; display: flex; align-items: center; justify-content: center;
            transition: all 0.5s ease-out; border-radius: 50%; border: 4px solid transparent;
            background: radial-gradient(circle, color-mix(in srgb, var(--accent-primary) 10%, transparent) 0%, rgba(74, 128, 240, 0) 70%);
        }
        .score-container.score-high { border-color: var(--accent-success); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-success) 50%, transparent); }
        .score-container.score-medium { border-color: var(--accent-warning); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-warning) 50%, transparent); }
        .score-container.score-low { border-color: var(--accent-danger); box-shadow: 0 0 25px color-mix(in srgb, var(--accent-danger) 50%, transparent); }
        
        #overall-score { font-size: 3.5rem; font-weight: 700; color: var(--text-primary); transition: color 0.5s ease-out; }
        .score-high #overall-score { color: var(--accent-success); }
        .score-medium #overall-score { color: var(--accent-warning); }
        .score-low #overall-score { color: var(--accent-danger); }

        #detailed-ipa-text { color: var(--accent-primary); }
        
        .thought-group {
            padding: 0.25rem 0.75rem; border-radius: 0.5rem; margin: 0.1rem;
            display: inline-block; transition: background-color 0.3s;
        }
        [data-theme="dark"] .thought-group-0 { background-color: rgba(96, 165, 250, 0.2); color: #bfdbfe; } /* blue */
        [data-theme="dark"] .thought-group-1 { background-color: rgba(52, 211, 153, 0.2); color: #a7f3d0; } /* emerald */
        [data-theme="dark"] .thought-group-2 { background-color: rgba(250, 204, 21, 0.2); color: #fef08a; } /* yellow */
        [data-theme="dark"] .thought-group-3 { background-color: rgba(192, 132, 252, 0.2); color: #e9d5ff; } /* purple */
        [data-theme="light"] .thought-group-0 { background-color: rgba(59, 130, 246, 0.15); color: #1e40af; }
        [data-theme="light"] .thought-group-1 { background-color: rgba(16, 185, 129, 0.15); color: #065f46; }
        [data-theme="light"] .thought-group-2 { background-color: rgba(245, 158, 11, 0.15); color: #92400e; }
        [data-theme="light"] .thought-group-3 { background-color: rgba(168, 85, 247, 0.15); color: #6b21a8; }
        
        .btn-spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .fade-in { animation: fadeIn 0.6s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Modal Styles --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            z-index: 50; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.is-visible {
            opacity: 1; visibility: visible;
        }
        .modal-container {
            width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .modal-overlay.is-visible .modal-container {
            transform: scale(1);
        }
        .history-item { cursor: pointer; transition: background-color 0.2s; }
        .history-item:hover { background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); }
        .history-item-text { color: var(--text-primary); }

        /* --- NEW ANALYSIS UI STYLES --- */
        .analysis-box-detailed {
            background-color: color-mix(in srgb, var(--input-bg) 60%, transparent);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-md);
            padding: 1.25rem;
            box-shadow: inset 0 2px 4px color-mix(in srgb, var(--shadow-color) 50%, transparent);
        }

        .analysis-title {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: var(--text-primary);
            margin-bottom: 1rem;
        }

        .intonation-chart-container {
            width: 100%;
            height: 180px; /* Increased height for stressed words */
            background-color: var(--input-bg);
            border-radius: var(--radius-sm);
            padding: 0.5rem;
            border: 1px solid var(--glass-border);
            margin-bottom: 1rem;
        }

        /* NEW: Syllable Chart Styles */
        .syllable-chart-container {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            padding: 1rem 0;
        }
        .syllable {
            padding: 0.75rem 1.25rem;
            border-radius: var(--radius-sm);
            font-size: 1.125rem;
            font-weight: 500;
            border: 2px solid var(--glass-border);
            background-color: var(--input-bg);
            color: var(--text-secondary);
            transition: all 0.3s ease;
        }
        .syllable.stressed {
            font-weight: 700;
            border-color: var(--accent-primary);
            background-color: color-mix(in srgb, var(--accent-primary) 15%, transparent);
            color: var(--accent-primary);
            transform: scale(1.1);
            box-shadow: 0 0 15px color-mix(in srgb, var(--accent-primary) 30%, transparent);
        }


        .connected-speech-item {
            padding: 1rem;
            border-radius: var(--radius-sm);
            border-left: 4px solid;
            position: relative;
            overflow: hidden;
        }

        .connected-speech-item.type-catenation { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.1); }
        .connected-speech-item.type-assimilation { border-color: #a855f7; background-color: rgba(168, 85, 247, 0.1); }
        .connected-speech-item.type-elision { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.1); }
        .connected-speech-item.type-intrusion { border-color: #14b8a6; background-color: rgba(20, 184, 166, 0.1); }
        .connected-speech-item.type-weak-form { border-color: #f59e0b; background-color: rgba(245, 158, 11, 0.1); }

        .cs-title { font-weight: 600; color: var(--text-primary); }
        .cs-location { font-family: 'Noto Sans', sans-serif; background-color: color-mix(in srgb, var(--glass-border) 50%, transparent); padding: 0.1rem 0.4rem; border-radius: 0.25rem; font-size: 0.9em; }
        .cs-details { font-size: 0.875rem; color: var(--text-secondary); }
        .cs-feedback { margin-top: 0.5rem; font-style: italic; }

        /* NEW: IPA Loader Animation */
        .ipa-loader-animation {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            height: 60px;
            transition: opacity 0.3s ease-in-out;
        }
        .pixel-bar {
            width: 8px;
            height: 8px;
            background-color: var(--accent-primary);
            border-radius: 2px;
            animation: pixel-dance 1.2s infinite ease-in-out;
        }
        @keyframes pixel-dance {
            0%, 100% { transform: scaleY(1); }
            50% { transform: scaleY(5); }
        }
        .pixel-bar:nth-child(2) { animation-delay: 0.1s; }
        .pixel-bar:nth-child(3) { animation-delay: 0.2s; }
        .pixel-bar:nth-child(4) { animation-delay: 0.3s; }
        .pixel-bar:nth-child(5) { animation-delay: 0.4s; }
        .pixel-bar:nth-child(6) { animation-delay: 0.5s; }
    </style>
</head>
<body class="antialiased">
    <div class="background-container">
        <div class="blob blob-1"></div>
        <div class="blob blob-2"></div>
    </div>

    <!-- History Modal -->
    <div id="history-modal" class="modal-overlay">
        <div class="modal-container glass-card p-6 space-y-4">
            <div class="flex justify-between items-center">
                <h3 class="font-bold text-text-primary text-xl">Lịch sử Luyện tập</h3>
                <button id="close-history-btn" class="btn btn-secondary btn-icon !w-8 !h-8">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="history-list" class="space-y-2"></div>
            <button id="clear-history-btn" class="btn btn-secondary w-full">Xóa tất cả lịch sử</button>
        </div>
    </div>

    <div class="w-full max-w-3xl mx-auto p-4 relative z-10">
        <header class="text-center mb-8 fade-in relative flex justify-between items-center">
            <button id="history-btn" class="btn btn-secondary btn-icon" aria-label="Xem lịch sử">
                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
            </button>
            <div class="absolute left-1/2 -translate-x-1/2">
                <h1 class="text-5xl md:text-6xl font-bold font-logo" style="color: var(--accent-primary);">PrAI</h1>
                <p class="text-text-secondary text-sm md:text-base">Trợ lý luyện phát âm AI của bạn</p>
            </div>
            <button id="theme-toggle" class="btn btn-secondary btn-icon" aria-label="Toggle theme">
                <svg id="theme-icon-light" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                <svg id="theme-icon-dark" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
            </button>
        </header>

        <main class="main-card glass-card space-y-8">
            <section class="input-section card-layer glass-card space-y-4">
                <div>
                    <label for="text-input" class="block text-lg font-semibold text-text-primary mb-3">Nhập văn bản cần luyện tập:</label>
                    <textarea id="text-input" rows="3" maxlength="150" class="input-field" placeholder="Ví dụ: What are you doing?"></textarea>
                    <div id="char-counter" class="text-right text-sm text-text-secondary mt-1">0 / 150</div>
                    <div class="mt-4 flex flex-col sm:flex-row items-center gap-4">
                        <div class="flex-grow w-full">
                            <label for="accent-select" class="block text-sm font-medium text-text-secondary mb-1">Chọn giọng:</label>
                            <select id="accent-select" class="input-field">
                                <option value="British English" selected>Anh - Anh (BrE)</option>
                                <option value="American English">Anh - Mỹ (AmE)</option>
                            </select>
                        </div>
                        <div class="flex-shrink-0 flex gap-3 self-end">
                            <button id="random-practice-btn" class="btn btn-secondary">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 2v6h6"/><path d="M21 12A9 9 0 0 0 6 5.3L3 8"/><path d="M21 22v-6h-6"/><path d="M3 12a9 9 0 0 0 15 6.7l3-2.7"/></svg>
                                <span class="text hidden sm:inline">Ngẫu nhiên</span>
                            </button>
                             <button id="transcribe-btn" class="btn btn-primary relative">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                                 <span class="text">Phiên âm</span>
                                 <div class="btn-spinner hidden absolute inset-0 m-auto h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                             </button>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- NEW: IPA Loader Animation Container -->
            <div id="ipa-loader-animation" class="ipa-loader-animation hidden">
                <div class="pixel-bar"></div>
                <div class="pixel-bar"></div>
                <div class="pixel-bar"></div>
                <div class="pixel-bar"></div>
                <div class="pixel-bar"></div>
                <div class="pixel-bar"></div>
            </div>

            <section id="controls-section" class="hidden space-y-6">
                 <div class="card-layer glass-card space-y-4">
                     <div id="simple-ipa-container" class="flex items-center justify-between">
                         <div class="min-w-0">
                             <h3 class="font-semibold text-text-secondary text-md">Phiên âm cơ bản</h3>
                             <p id="simple-ipa-text" class="text-lg text-text-primary tracking-wider"></p>
                         </div>
                         <div class="relative w-11 h-11">
                             <button id="listen-clear-btn" class="btn-icon btn-secondary absolute inset-0">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>
                             </button>
                             <div id="listen-clear-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                 <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                             </div>
                         </div>
                     </div>
                     <div id="detailed-ipa-container" class="flex items-center justify-between">
                         <div class="min-w-0">
                             <div class="flex items-center gap-2 mb-1">
                                 <h3 class="font-semibold text-text-secondary text-md">Phiên âm & Cụm tư duy</h3>
                                 <div id="thought-group-info" class="has-tooltip relative hidden">
                                     <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="text-text-secondary cursor-pointer"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
                                     <div id="thought-group-tooltip" class="tooltip absolute bottom-full left-1/2 mb-2 w-72 rounded-lg p-3 text-xs shadow-lg"></div>
                                 </div>
                             </div>
                             <div class="space-y-2">
                                 <p id="detailed-ipa-text" class="text-xl text-accent-primary tracking-wider"></p>
                                 <div id="thought-group-display" class="text-lg tracking-wide leading-relaxed font-medium"></div>
                             </div>
                         </div>
                         <div class="relative w-11 h-11">
                             <button id="listen-natural-btn" class="btn-icon btn-secondary absolute inset-0">
                                 <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                             </button>
                             <div id="listen-natural-loader" class="btn-icon btn-secondary absolute inset-0 hidden items-center justify-center">
                                 <div class="btn-spinner h-5 w-5 border-2 border-slate-400 border-t-transparent rounded-full"></div>
                             </div>
                         </div>
                     </div>
                 </div>

                <div class="flex flex-col items-center justify-center gap-4 pt-4">
                    <div id="record-controls" class="flex items-center justify-center gap-6 w-full h-28">
                        <button id="upload-btn" class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        </button>
                        <div class="flex flex-col items-center justify-center">
                            <button id="record-btn" class="btn-record flex items-center justify-center">
                                <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                                <span class="text hidden text-lg font-semibold">Dừng</span>
                            </button>
                        </div>
                        <button id="listen-again-btn" disabled class="btn-icon btn-secondary">
                            <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
                        </button>
                    </div>
                    <div id="waveform-container" class="hidden h-20 w-full card-layer-inset flex items-center justify-center p-2">
                        <canvas id="waveform" class="w-full h-full"></canvas>
                    </div>
                </div>
            </section>

            <div id="loader" class="text-center hidden py-4 flex flex-col items-center justify-center">
                <div class="w-full max-w-xs h-2 rounded-full overflow-hidden bg-[color:var(--input-bg)]">
                    <div id="progress-bar-inner" class="h-full rounded-full bg-gradient-to-r from-sky-400 to-teal-400 transition-all duration-500"></div>
                </div>
                <p id="progress-text" class="text-text-secondary mt-4">PrAI đang lắng nghe và phân tích...</p>
                <p id="fun-fact" class="text-sm text-text-secondary/70 mt-6 italic hidden"></p>
            </div>

            <!-- UPDATED ANALYSIS RESULTS SECTION -->
            <section id="analysis-results" class="hidden space-y-6">
                <div class="card-layer glass-card space-y-6 p-6">
                    <h3 class="font-bold text-text-primary text-2xl text-center">Kết quả Phân tích</h3>
            
                    <!-- Overall Score -->
                    <div class="score-container">
                        <p><span id="overall-score"></span><span class="text-xl text-text-secondary">/100</span></p>
                    </div>
            
                    <!-- Phoneme Analysis -->
                    <div class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Âm vị</h4>
                        <div id="phoneme-analysis" class="flex flex-wrap gap-2 justify-center"></div>
                        <p class="text-xs text-text-secondary mt-3 text-center">Chạm hoặc di chuột qua các âm vị để xem hướng dẫn.</p>
                    </div>
            
                    <!-- Intonation / Syllable Analysis -->
                    <div id="prosody-analysis-container" class="analysis-box-detailed">
                        <!-- Title will be set dynamically -->
                        <h4 id="prosody-analysis-title" class="analysis-title"></h4>
                        <!-- Container for Sentence Intonation Chart -->
                        <div id="intonation-analysis-content">
                            <div class="intonation-chart-container">
                                <svg id="intonation-chart" width="100%" height="100%"></svg>
                            </div>
                            <div id="intonation-analysis-feedback" class="text-sm text-text-secondary"></div>
                        </div>
                        <!-- Container for Single Word Syllable Chart -->
                        <div id="syllable-analysis-content">
                            <div id="syllable-chart-container" class="syllable-chart-container"></div>
                            <div id="syllable-analysis-feedback" class="text-sm text-text-secondary text-center"></div>
                        </div>
                    </div>
            
                    <!-- Connected Speech Analysis -->
                    <div id="connected-speech-container" class="analysis-box-detailed">
                        <h4 class="analysis-title">Phân tích Nối âm & Cụm tư duy</h4>
                        <div id="connected-speech-analysis" class="space-y-3"></div>
                    </div>
            
                </div>
            
                <!-- Practice Suggestions Section -->
                <div id="practice-suggestions" class="hidden card-layer glass-card">
                     <h3 class="font-bold text-text-primary text-xl mb-4">Xem ví dụ thực tế</h3>
                     <div id="suggestion-links" class="flex flex-col sm:flex-row gap-3 mt-2"></div>
                </div>
            </section>
        </main>

        <div id="message-box" class="fixed bottom-5 right-5 hidden p-4 rounded-xl text-sm z-50 shadow-lg glass-card"></div>
        <audio id="replay-audio" class="hidden"></audio>
        <input type="file" id="audio-upload-input" class="hidden" accept="audio/*">

        <footer class="text-center mt-8 text-text-secondary text-sm">
            <p>© 2025 PrAI. Được tạo ra với niềm đam mê ngôn ngữ bởi Mr Bảo.</p>
        </footer>
    </div>

    <script type="module">
        // --- THEME SWITCHER LOGIC ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const docElement = document.documentElement;

        function applyTheme(theme) {
            docElement.setAttribute('data-theme', theme);
            if (theme === 'light') {
                themeIconDark.classList.remove('hidden');
                themeIconLight.classList.add('hidden');
            } else {
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            }
            localStorage.setItem('prai-theme', theme);
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = docElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        });

        const savedTheme = localStorage.getItem('prai-theme') || 'light';
        applyTheme(savedTheme);


        // --- APP LOGIC ---
        const textInput = document.getElementById('text-input');
        const accentSelect = document.getElementById('accent-select');
        const transcribeBtn = document.getElementById('transcribe-btn');
        const listenNaturalBtn = document.getElementById('listen-natural-btn');
        const listenClearBtn = document.getElementById('listen-clear-btn');
        const listenClearLoader = document.getElementById('listen-clear-loader');
        const listenNaturalLoader = document.getElementById('listen-natural-loader');
        const recordControls = document.getElementById('record-controls');
        const uploadBtn = document.getElementById('upload-btn');
        const recordBtn = document.getElementById('record-btn');
        const listenAgainBtn = document.getElementById('listen-again-btn');
        const randomPracticeBtn = document.getElementById('random-practice-btn');
        const controlsSection = document.getElementById('controls-section');
        const loader = document.getElementById('loader');
        const simpleIpaText = document.getElementById('simple-ipa-text');
        const detailedIpaText = document.getElementById('detailed-ipa-text');
        const analysisResults = document.getElementById('analysis-results');
        const overallScore = document.getElementById('overall-score');
        const phonemeAnalysis = document.getElementById('phoneme-analysis');
        const practiceSuggestions = document.getElementById('practice-suggestions');
        const suggestionLinks = document.getElementById('suggestion-links');
        const messageBox = document.getElementById('message-box');
        const waveformContainer = document.getElementById('waveform-container');
        const waveformEl = document.getElementById('waveform');
        const replayAudio = document.getElementById('replay-audio');
        const audioUploadInput = document.getElementById('audio-upload-input');
        const funFactEl = document.getElementById('fun-fact');
        const connectedSpeechAnalysis = document.getElementById('connected-speech-analysis');
        const progressText = document.getElementById('progress-text');
        const progressBarInner = document.getElementById('progress-bar-inner');
        const charCounter = document.getElementById('char-counter');
        const thoughtGroupDisplay = document.getElementById('thought-group-display');
        const thoughtGroupInfo = document.getElementById('thought-group-info');
        const thoughtGroupTooltip = document.getElementById('thought-group-tooltip');
        const detailedIpaContainer = document.getElementById('detailed-ipa-container');
        const ipaLoaderAnimation = document.getElementById('ipa-loader-animation');
        
        // NEW ANALYSIS SECTION ELEMENTS
        const prosodyAnalysisContainer = document.getElementById('prosody-analysis-container');
        const prosodyAnalysisTitle = document.getElementById('prosody-analysis-title');
        const intonationAnalysisContent = document.getElementById('intonation-analysis-content');
        const syllableAnalysisContent = document.getElementById('syllable-analysis-content');
        const syllableChartContainer = document.getElementById('syllable-chart-container');
        const syllableAnalysisFeedback = document.getElementById('syllable-analysis-feedback');
        const intonationAnalysisFeedback = document.getElementById('intonation-analysis-feedback');
        const intonationChart = document.getElementById('intonation-chart');
        const connectedSpeechContainer = document.getElementById('connected-speech-container');

        const historyBtn = document.getElementById('history-btn');
        const historyModal = document.getElementById('history-modal');
        const closeHistoryBtn = document.getElementById('close-history-btn');
        const historyList = document.getElementById('history-list');
        const clearHistoryBtn = document.getElementById('clear-history-btn');

        // --- STATE MANAGEMENT ---
        let isRecording = false;
        let mediaRecorder;
        let audioChunks = [];
        let standardIPA = '';
        let audioContext;
        let analyser;
        let waveformAnimationId;
        let lastRecordingBlob = null;
        let soundDetected = false;
        let fetchIpaRequestID = 0;
        let analysisRequestID = 0;
        let progressInterval;
        let progressTextTimeoutIds = [];
        let currentIpaData = {};
        
        let isSingleWordMode = false;

        // --- CACHING ---
        const ipaCache = {
            get(key) { try { const i = localStorage.getItem(key); return i ? JSON.parse(i) : null; } catch (e) { return null; } },
            set(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch (e) { console.error("Cache write error:", e); } }
        };
        let modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
        let clearPronunciationAudio = null;


        const funFacts = [
            "'Ough' có thể được phát âm theo 10 cách khác nhau.",
            "Âm câm (silent letters) là di tích lịch sử từ các ngôn ngữ khác.",
            "'Pronunciation' (phát âm) trớ trêu lại là từ bị phát âm sai nhiều nhất.",
            "Tiếng Anh có tới 20 âm nguyên âm theo hệ thống IPA, nhiều hơn hầu hết các ngôn ngữ khác.",
            "'Strengths' là từ dài nhất chỉ có một nguyên âm.",
        ];

        const practiceSentences = [
            "What are you doing?", "It's a piece of cake.", "I'll call you back later.",
            "How's it going?", "Can I have a bottle of water, please?", "It's a beautiful day, isn't it?",
            "I'm looking forward to it.", "Could you please repeat that?", "Where is the nearest station?",
        ];

        const TEXT_MODEL = "gemini-2.5-flash-preview-05-20";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";
        const TEXT_API_URL = `/api/proxy`;
        const TTS_API_URL = `/api/proxy`;

        function showMessage(message, type = 'info') {
            const typeClasses = {
                'info': 'text-blue-300 border-accent-primary/30',
                'success': 'text-green-300 border-accent-success/30',
                'warning': 'text-yellow-300 border-accent-warning/30',
                'error': 'text-red-300 border-accent-danger/30'
            };
            messageBox.className = `fixed bottom-5 right-5 p-4 rounded-xl text-sm z-50 shadow-lg glass-card fade-in ${typeClasses[type]}`;
            messageBox.textContent = message;
            messageBox.classList.remove('hidden');
            setTimeout(() => messageBox.classList.add('hidden'), 5000);
        }

        function handleApiError(error) {
            console.error("API Error:", error);
            if (error.message && (error.message.includes('429') || error.message.toLowerCase().includes('quota'))) {
                showMessage('Hệ thống đang bận. Bạn vui lòng thử lại sau nhé.', 'error');
            } else {
                showMessage(`Đã xảy ra lỗi kết nối: ${error.message}`, 'error');
            }
        }

        function setButtonLoading(button, loader, isLoading) {
            button.disabled = isLoading;
            if (loader) {
                if(isLoading) {
                    button.classList.add('hidden');
                    loader.classList.remove('hidden');
                    loader.classList.add('flex');
                } else {
                    button.classList.remove('hidden');
                    loader.classList.add('hidden');
                    loader.classList.remove('flex');
                }
            } else {
                const textEl = button.querySelector('.text');
                const iconEl = button.querySelector('.icon');
                const spinnerEl = button.querySelector('.btn-spinner');
                if (isLoading) {
                    if (textEl) textEl.style.visibility = 'hidden';
                    if (iconEl) iconEl.style.visibility = 'hidden';
                    if (spinnerEl) spinnerEl.classList.remove('hidden');
                } else {
                    if (textEl) textEl.style.visibility = 'visible';
                    if (iconEl) iconEl.style.visibility = 'visible';
                    if (spinnerEl) spinnerEl.classList.add('hidden');
                }
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1, bitsPerSample = 16;
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            const dataSize = pcmData.length * 2;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            for (let i = 0; i < pcmData.length; i++) { view.setInt16(44 + i * 2, pcmData[i], true); }
            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithBackoff(url, options, maxRetries = 4) {
             let delay = 1000;
             for (let i = 0; i < maxRetries; i++) {
                 try {
                     const response = await fetch(url, options);
                     if (response.status === 429 || response.status >= 500) {
                         if (i === maxRetries - 1) throw new Error(`API Error: ${response.status} after multiple retries.`);
                         await new Promise(resolve => setTimeout(resolve, delay));
                         delay *= 2; 
                         continue; 
                     }
                     if (!response.ok) {
                         const errorBody = await response.json().catch(() => ({}));
                         throw new Error(`API Error: ${response.status}. ${errorBody.error?.message || 'An unknown error occurred.'}`);
                     }
                     return await response.json();
                 } catch (error) {
                     if (i === maxRetries - 1) throw error;
                     await new Promise(resolve => setTimeout(resolve, delay));
                     delay *= 2;
                 }
             }
         }

        function displayIpaData(data) {
            currentIpaData = data;
            standardIPA = data.detailed;
            simpleIpaText.textContent = data.simple;

            detailedIpaContainer.style.display = isSingleWordMode ? 'none' : 'flex';
            
            if (!isSingleWordMode) {
                detailedIpaText.textContent = data.detailed;
                displayThoughtGroups(data.thought_groups?.groups, data.thought_groups?.explanation);
            }
            controlsSection.classList.remove('hidden');
        }
        
        async function prefetchModelPronunciation(text, accent) {
            if (modelPronunciationData.text === text && modelPronunciationData.accent === accent) return;
            modelPronunciationData = { text, accent, audio: null, pitchContour: [], stressedWords: [] };
        
            try {
                const textWithPauses = currentIpaData.thought_groups?.groups.join(" | ") || text;
                const promptTTS = `Read ONLY the following text in ${accent}. The pipe symbol "|" indicates a slight, natural hesitation. Text: ${textWithPauses}`;
                
                const [ttsData, analysisData] = await Promise.all([
                    fetchWithBackoff(TTS_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: promptTTS }] }],
                            generationConfig: { responseModalities: ["AUDIO"] },
                            model: TTS_MODEL
                        })
                    }),
                    fetchWithBackoff(TEXT_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: `Analyze the sentence "${text}". Provide a JSON object with 'pitch_contour' (an array of 40-50 normalized pitch points) and 'stressed_words' (an array of objects with 'word' and 'time_stamp_normalized' from 0.0 to 1.0).` }] }],
                            generationConfig: { responseMimeType: "application/json" }
                        })
                    })
                ]);
        
                const audioPart = ttsData?.candidates?.[0]?.content?.parts?.[0];
                if (!audioPart?.inlineData) throw new Error("TTS audio data not received.");
                modelPronunciationData.audio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
        
                const analysisJson = JSON.parse(analysisData.candidates[0].content.parts[0].text);
                modelPronunciationData.pitchContour = analysisJson.pitch_contour || [];
                modelPronunciationData.stressedWords = analysisJson.stressed_words || [];
        
                console.log("Model pronunciation data prefetched successfully.");
        
            } catch (error) {
                console.error("Model pronunciation prefetch failed:", error);
                modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
            }
        }

        async function fetchAndDisplayIPA() {
            fetchIpaRequestID++;
            const currentRequestID = fetchIpaRequestID;

            const text = textInput.value.trim();
            if (!text) {
                resetAll();
                return false;
            }
            
            isSingleWordMode = !text.includes(' ');
            
            const accent = accentSelect.value;
            const cacheKey = `ipa_${text}_${accent}`;
            const cachedData = ipaCache.get(cacheKey);

            if (cachedData) {
                displayIpaData(cachedData);
                if (isSingleWordMode) {
                    prefetchClearPronunciation(text, accent);
                } else {
                    prefetchModelPronunciation(text, accent);
                }
                return true;
            }
            
            let prompt;
            if (isSingleWordMode) {
                prompt = `Provide a JSON object for the word "${text}" in ${accent}. The JSON must contain:
                1. 'simple': The standard IPA transcription.
                2. 'syllable_structure': An object with 'syllables' (an array of strings representing each syllable) and 'stressed_syllable_index' (the 0-based index of the stressed syllable).
                Respond with ONLY the JSON object.`;
            } else {
                prompt = `For the phrase "${text}" in ${accent}, provide a single JSON object with:
                1. 'simple': A standard, citation-form IPA transcription.
                2. 'detailed': A natural, connected speech transcription. Use the liaison symbol (‿) correctly ONLY where linking occurs within a thought group.
                3. 'thought_groups': An object with 'groups' (an array of strings for natural thought groups) and 'explanation' (a clear Vietnamese explanation for the grouping).
                Respond with ONLY the JSON object.`;
            }
            
            setButtonLoading(transcribeBtn, null, true);
            ipaLoaderAnimation.classList.remove('hidden');
            controlsSection.classList.add('hidden');
            
            try {
                const payload = { 
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" }
                };

                const response = await fetchWithBackoff(TEXT_API_URL, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, 
                    body: JSON.stringify(payload) 
                });

                if (currentRequestID !== fetchIpaRequestID) return false;

                let resultJson = JSON.parse(response.candidates[0].content.parts[0].text);

                if (isSingleWordMode) {
                    resultJson.detailed = resultJson.simple;
                }

                ipaCache.set(cacheKey, resultJson);
                displayIpaData(resultJson);
                
                if (isSingleWordMode) {
                    prefetchClearPronunciation(text, accent);
                } else {
                    prefetchModelPronunciation(text, accent);
                }
                
                return true;
            } catch (error) {
                if (currentRequestID === fetchIpaRequestID) {
                    handleApiError(error);
                    resetAll();
                }
                return false;
            } finally {
                if (currentRequestID === fetchIpaRequestID) {
                    setButtonLoading(transcribeBtn, null, false);
                    ipaLoaderAnimation.classList.add('hidden');
                }
            }
        }

        function displayThoughtGroups(groups, explanation) {
            thoughtGroupDisplay.innerHTML = '';
            thoughtGroupTooltip.textContent = explanation || '';
            
            if (groups && groups.length > 0 && explanation) {
                thoughtGroupInfo.style.display = 'block';
                groups.forEach((group, index) => {
                    const groupSpan = document.createElement('span');
                    groupSpan.textContent = group;
                    groupSpan.className = `thought-group thought-group-${index % 4}`;
                    thoughtGroupDisplay.appendChild(groupSpan);
                });
            } else {
                thoughtGroupInfo.style.display = 'none';
            }
        }

        async function prefetchClearPronunciation(text, accent) {
            clearPronunciationAudio = null;
            try {
                const prompt = `Say very clearly in ${accent}: ${text}`;
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseModalities: ["AUDIO"] },
                    model: TTS_MODEL
                };
                const data = await fetchWithBackoff(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'X-Target-API': 'tts' },
                    body: JSON.stringify(payload)
                });
                const audioPart = data?.candidates?.[0]?.content?.parts?.[0];
                if (audioPart?.inlineData) {
                    clearPronunciationAudio = await createAudioFromBase64(audioPart.inlineData.data, audioPart.inlineData.mimeType);
                    console.log("Clear pronunciation audio prefetched.");
                } else {
                    throw new Error("Invalid audio data for clear voice.");
                }
            } catch (error) {
                console.error("Failed to prefetch clear pronunciation:", error);
            }
        }

        async function handleListen(type) {
            const text = textInput.value.trim();
            if (!text) return;

            const button = type === 'natural' ? listenNaturalBtn : listenClearBtn;
            const loader = type === 'natural' ? listenNaturalLoader : listenClearLoader;
            
            setButtonLoading(button, loader, true);

            try {
                if (type === 'natural') {
                    if (modelPronunciationData.audio) {
                        modelPronunciationData.audio.currentTime = 0;
                        modelPronunciationData.audio.play();
                    } else {
                        await prefetchModelPronunciation(text, accentSelect.value);
                        if (modelPronunciationData.audio) {
                             modelPronunciationData.audio.currentTime = 0;
                             modelPronunciationData.audio.play();
                        } else {
                            throw new Error("Không thể tạo giọng đọc mẫu.");
                        }
                    }
                } else {
                    if (clearPronunciationAudio) {
                        clearPronunciationAudio.currentTime = 0;
                        clearPronunciationAudio.play();
                    } else {
                        await prefetchClearPronunciation(text, accentSelect.value);
                        if(clearPronunciationAudio) {
                            clearPronunciationAudio.currentTime = 0;
                            clearPronunciationAudio.play();
                        } else {
                            throw new Error("Không thể tạo giọng đọc mẫu.");
                        }
                    }
                }
            } catch (error) {
                handleApiError(error);
            } finally {
                setButtonLoading(button, loader, false);
            }
        }
        
        async function createAudioFromBase64(base64Data, mimeType) {
            const sampleRate = mimeType.match(/rate=(\d+)/) ? parseInt(mimeType.match(/rate=(\d+)/)[1], 10) : 24000;
            const pcmData = base64ToArrayBuffer(base64Data);
            const pcm16 = new Int16Array(pcmData);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            return new Audio(audioUrl);
        }

        function startProgressSimulation() {
            let width = 0;
            progressBarInner.style.width = '0%';
            clearInterval(progressInterval);
            progressInterval = setInterval(() => {
                width = Math.min(width + Math.random() * 2, 95);
                progressBarInner.style.width = width + '%';
            }, 100);
        }

        function stopProgressSimulation() {
            clearInterval(progressInterval);
            progressBarInner.style.width = '100%';
        }

        function startProgressTextAnimation() {
            const steps = [
                { text: "Okie, PrAI đã nhận được bản ghi âm của bạn...", duration: 1500 },
                { text: "Đang phiên âm giọng nói của bạn!", duration: 2500 },
                { text: "So sánh từng âm một với giọng chuẩn...", duration: 3000 },
                { text: "Xong rồi! Cùng xem kết quả tuyệt vời của bạn nhé!", duration: 1000 }
            ];
            let cumulativeDelay = 0;
            stopProgressTextAnimation();
            steps.forEach(step => {
                const id = setTimeout(() => { progressText.textContent = step.text; }, cumulativeDelay);
                progressTextTimeoutIds.push(id);
                cumulativeDelay += step.duration;
            });
        }
        
        function stopProgressTextAnimation() {
            progressTextTimeoutIds.forEach(clearTimeout);
            progressTextTimeoutIds = [];
        }

        // NEW: Helper function for client-side sentence comparison
        function calculateSentenceSimilarity(words1, words2) {
            if (!words1.length || !words2.length) return 0;
            const set1 = new Set(words1);
            let matchCount = 0;
            for (const word of words2) {
                if (set1.has(word)) {
                    matchCount++;
                }
            }
            return matchCount / Math.max(words1.length, words2.length);
        }

        async function analyzeAudio(audioBlob) {
            analysisRequestID++;
            const currentAnalysisID = analysisRequestID;

            if (!audioBlob) return;
            lastRecordingBlob = audioBlob;
            listenAgainBtn.disabled = false;

            if (!standardIPA) {
                showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                return;
            }
            
            if (!isSingleWordMode) {
                if (modelPronunciationData.text !== textInput.value.trim() || !modelPronunciationData.pitchContour?.length) {
                    await prefetchModelPronunciation(textInput.value.trim(), accentSelect.value);
                    if (!modelPronunciationData.pitchContour?.length) {
                       showMessage('Chưa có dữ liệu ngữ điệu mẫu, vui lòng thử lại.', 'error');
                       return;
                    }
                }
            }

            loader.classList.remove('hidden');
            startProgressTextAnimation();
            startProgressSimulation();
            funFactEl.textContent = `💡 ${funFacts[Math.floor(Math.random() * funFacts.length)]}`;
            funFactEl.classList.remove('hidden');
            
            const reader = new FileReader();
            reader.readAsDataURL(audioBlob);
            reader.onloadend = async () => {
                if (currentAnalysisID !== analysisRequestID) return;

                const base64Audio = reader.result.split(',')[1];
                
                let prompt;
                if (isSingleWordMode) {
                    prompt = {
                        "role": "Bạn là chuyên gia ngữ âm AI. Nhiệm vụ của bạn là phân tích một từ đơn.",
                        "task_instructions": {
                            "step_1_verification": "Đầu tiên, phiên âm audio của người dùng. Nếu từ được phát âm khác với 'text_to_pronounce', hãy trả về JSON với 'word_match': false và 'transcribed_word'. KHÔNG phân tích thêm.",
                            "step_2_analysis": "Nếu từ khớp, thực hiện phân tích âm vị cực kỳ nghiêm ngặt và chính xác. So sánh từng âm vị của người dùng với âm vị chuẩn.",
                            "step_3_scoring": "Chấm điểm khắt khe dựa trên độ chính xác của từng âm vị. Lỗi âm cuối hoặc nguyên âm chính là lỗi nghiêm trọng."
                        },
                        "context": {
                            "text_to_pronounce": textInput.value.trim(),
                            "target_accent": accentSelect.value,
                            "standard_ipa": standardIPA,
                            "standard_syllable_structure": currentIpaData.syllable_structure
                        },
                        "output_format_instruction": {
                            "format": "JSON",
                            "schema": {
                                "word_match": "boolean",
                                "transcribed_word": "string | null",
                                "overall_score": "number | null",
                                "user_ipa": "string | null",
                                "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string\" } ] | null",
                                "syllable_analysis": "{ \"feedback\": \"string\" } | null"
                            }
                        }
                    };
                } else { // Sentence mode
                    prompt = {
                        "role": "Bạn là PrAI, một chuyên gia ngữ âm AI thấu hiểu người học tiếng Anh là người Việt.",
                        "context": {
                            "learner_profile": "Người Việt, thường bỏ âm cuối, nhầm lẫn nguyên âm, và nói ngắt nghỉ.",
                            "text_to_pronounce": textInput.value.trim(),
                            "target_accent": accentSelect.value,
                            "standard_ipa": standardIPA,
                            "model_pitch_contour": modelPronunciationData.pitchContour,
                        },
                        "leniency_rules": [{ 
                            "phoneme": "ʔ (glottal stop)", 
                            "condition": "Khi thay thế cho âm /t/ cuối không bật hơi.", 
                            "adjustment": "Phân loại là 'Gần đúng' và trừ tối đa 1-2 điểm."
                        }],
                        "output_format_instruction": {
                            "format": "JSON",
                            "schema": {
                                "user_transcribed_text": "string // Phiên âm audio ra văn bản thông thường.",
                                "overall_score": "number | null",
                                "user_ipa": "string | null",
                                "phoneme_analysis": "[ { \"phoneme\": \"string\", \"status\": \"string ('correct', 'approximate', 'incorrect')\", \"feedback\": \"string\" } ]",
                                "intonation_analysis": {
                                    "feedback": "string // Nhận xét về ngữ điệu, tốc độ và nhịp điệu. So sánh với mẫu.",
                                    "user_pitch_contour": "[number]"
                                },
                                "connected_speech_analysis": "[{ \"type\": \"string\", \"rule\": \"string\", \"location\": \"string\", \"expected_pronunciation\": \"string\", \"user_pronunciation\": \"string\", \"feedback\": \"string\" }] | null",
                                "practice_suggestions": "{ \"youglish_us\": \"string\", \"youglish_uk\": \"string\" } | null"
                            }
                        }
                    };
                }

                const payload = {
                    contents: [ { role: "user", parts: [ { text: JSON.stringify(prompt) }, { inlineData: { mimeType: "audio/webm", data: base64Audio } } ] } ],
                    generationConfig: { responseMimeType: "application/json" }
                };

                try {
                    const data = await fetchWithBackoff(TEXT_API_URL, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json', 'X-Target-API': 'text' }, 
                        body: JSON.stringify(payload) 
                    });
                    
                    if (currentAnalysisID !== analysisRequestID) return;
                    const resultJson = JSON.parse(data.candidates[0].content.parts[0].text);
                    
                    // NEW: Client-side validation for sentences
                    if (!isSingleWordMode) {
                        const originalWords = textInput.value.trim().toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
                        const transcribedWords = (resultJson.user_transcribed_text || "").toLowerCase().replace(/[^a-z0-9\s]/g, '').split(/\s+/);
                        const similarity = calculateSentenceSimilarity(originalWords, transcribedWords);
                        
                        if (similarity < 0.7) {
                            showMessage("Câu bạn nói dường như không khớp với câu mẫu. Vui lòng thử lại.", 'warning');
                            return; // Stop further processing
                        }
                    }
                    
                    displayResults(resultJson);

                } catch (error) {
                    if (currentAnalysisID === analysisRequestID) handleApiError(error);
                } finally {
                    if (currentAnalysisID === analysisRequestID) {
                        stopProgressSimulation();
                        stopProgressTextAnimation();
                        setTimeout(() => {
                            loader.classList.add('hidden');
                            funFactEl.classList.add('hidden');
                        }, 500);
                    }
                }
            };
        }
        
        function displayResults(data) {
            if (data.word_match === false) {
                showMessage(`Bạn dường như đã phát âm từ "${data.transcribed_word}" thay vì từ mẫu. Vui lòng thử lại.`, 'warning');
                return;
            }
            
            if (data.overall_score === null) {
                showMessage("PrAI không nhận diện được giọng nói. Vui lòng thử lại và nói to, rõ hơn.", 'warning');
                return;
            }
        
            saveToHistory(textInput.value.trim(), data.overall_score);
            analysisResults.classList.remove('hidden');
        
            const scoreContainer = document.querySelector('.score-container');
            animateValue(overallScore, 0, data.overall_score, 1000);
            scoreContainer.className = 'score-container';
            if (data.overall_score > 85) scoreContainer.classList.add('score-high');
            else if (data.overall_score > 70) scoreContainer.classList.add('score-medium');
            else scoreContainer.classList.add('score-low');
        
            phonemeAnalysis.innerHTML = '';
            data.phoneme_analysis?.forEach(p => {
                const phonemeEl = document.createElement('div');
                phonemeEl.textContent = p.phoneme;
                phonemeEl.className = `phoneme has-tooltip status-${p.status}`;
                if (p.feedback) {
                    const tooltip = document.createElement('div');
                    tooltip.className = 'tooltip';
                    tooltip.textContent = p.feedback;
                    phonemeEl.appendChild(tooltip);
                }
                phonemeAnalysis.appendChild(phonemeEl);
            });
        
            prosodyAnalysisContainer.style.display = 'block';
            connectedSpeechContainer.style.display = isSingleWordMode ? 'none' : 'block';

            if (isSingleWordMode) {
                intonationAnalysisContent.style.display = 'none';
                syllableAnalysisContent.style.display = 'block';
                prosodyAnalysisTitle.textContent = 'Phân tích Âm tiết & Trọng âm';
                renderSyllableChart(currentIpaData.syllable_structure);
                syllableAnalysisFeedback.textContent = data.syllable_analysis?.feedback || '';
            } else {
                intonationAnalysisContent.style.display = 'block';
                syllableAnalysisContent.style.display = 'none';
                prosodyAnalysisTitle.textContent = 'Phân tích Ngữ điệu';
                intonationAnalysisFeedback.textContent = data.intonation_analysis?.feedback || '';
                renderIntonationChart(
                    intonationChart,
                    modelPronunciationData.pitchContour,
                    data.intonation_analysis?.user_pitch_contour,
                    modelPronunciationData.stressedWords
                );
                
                connectedSpeechAnalysis.innerHTML = '';
                if (data.connected_speech_analysis?.length > 0) {
                    data.connected_speech_analysis.forEach(item => {
                        const itemEl = document.createElement('div');
                        const typeClass = `type-${item.type.toLowerCase().replace(/\s/g, '-')}`;
                        itemEl.className = `connected-speech-item ${typeClass}`;
                        itemEl.innerHTML = `
                            <div class="flex justify-between items-start">
                                <div><p class="cs-title">${item.rule}</p><p class="cs-details mt-1">Vị trí: <span class="cs-location">${item.location}</span></p></div>
                                <span class="text-xs font-semibold uppercase px-2 py-1 rounded-full ${typeClass} opacity-70">${item.type}</span>
                            </div>
                            <div class="cs-details mt-2">
                                <p>Phát âm mong đợi: <span class="ipa-text text-accent-success">${item.expected_pronunciation}</span></p>
                                <p>Phát âm của bạn: <span class="ipa-text text-accent-warning">${item.user_pronunciation}</span></p>
                            </div>
                            <p class="cs-feedback text-sm">${item.feedback}</p>`;
                        connectedSpeechAnalysis.appendChild(itemEl);
                    });
                } else {
                    connectedSpeechAnalysis.innerHTML = '<p class="text-text-secondary text-sm italic">Không có nhận xét nổi bật về nối âm. Lời nói của bạn khá rõ ràng nhưng có thể chưa thể hiện sự liên kết tự nhiên.</p>';
                }
            }
        
            if (data.practice_suggestions) {
                suggestionLinks.innerHTML = `<a href="${data.practice_suggestions.youglish_us}" target="_blank" class="btn btn-primary flex-1">Giọng Mỹ (YouGlish)</a><a href="${data.practice_suggestions.youglish_uk}" target="_blank" class="btn btn-primary flex-1">Giọng Anh (YouGlish)</a>`;
                practiceSuggestions.classList.remove('hidden');
            } else {
                practiceSuggestions.classList.add('hidden');
            }
        }
        
        function renderSyllableChart(structure) {
            syllableChartContainer.innerHTML = '';
            if (!structure || !structure.syllables) return;
            
            structure.syllables.forEach((syllable, index) => {
                const syllableEl = document.createElement('div');
                syllableEl.className = 'syllable';
                syllableEl.textContent = syllable;
                if (index === structure.stressed_syllable_index) {
                    syllableEl.classList.add('stressed');
                }
                syllableChartContainer.appendChild(syllableEl);
            });
        }

        function resetAnalysisOnly() {
            analysisResults.classList.add('hidden');
            practiceSuggestions.classList.add('hidden');
        }

        function resetAll() {
            standardIPA = '';
            controlsSection.classList.add('hidden');
            resetAnalysisOnly();
            
            const text = textInput.value.trim();
            const accent = accentSelect.value;
            if (modelPronunciationData.text !== text || modelPronunciationData.accent !== accent) {
                 modelPronunciationData = { text: '', accent: '', audio: null, pitchContour: [], stressedWords: [] };
            }
            clearPronunciationAudio = null;
            currentIpaData = {};
            displayThoughtGroups([], '');
        }

        async function handleRecord() {
            if (isRecording) {
                mediaRecorder.stop();
                return;
            }
            
            analysisRequestID++;

            if (!textInput.value.trim()) {
                showMessage('Vui lòng nhập từ để ghi âm và phân tích.', 'warning');
                return;
            }
            
            resetAnalysisOnly(); 
            listenAgainBtn.disabled = true;
            lastRecordingBlob = null;
            
            try {
                if (!standardIPA) {
                    const ipaReady = await fetchAndDisplayIPA();
                    if (!ipaReady) {
                        showMessage('Chưa có phiên âm chuẩn, không thể bắt đầu ghi âm.', 'warning');
                        return;
                    }
                }

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                isRecording = true;
                soundDetected = false;
                audioChunks = [];
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                mediaRecorder.onstop = () => {
                    isRecording = false;
                    stopWaveform();
                    stream.getTracks().forEach(track => track.stop());
                    
                    const recordBtnText = recordBtn.querySelector('.text');
                    recordBtnText.textContent = '';
                    recordBtnText.classList.add('hidden');
                    recordBtn.querySelector('.icon').classList.remove('hidden');
                    recordBtn.classList.remove('is-recording');

                    if (soundDetected) {
                        analyzeAudio(new Blob(audioChunks, { type: 'audio/webm' }));
                    } else {
                        showMessage("PrAI không phát hiện thấy âm thanh. Vui lòng thử ghi âm lại nhé.", "error");
                    }
                };
                mediaRecorder.start();
                startWaveform(stream);
                const recordBtnText = recordBtn.querySelector('.text');
                recordBtnText.textContent = 'Dừng';
                recordBtnText.classList.remove('hidden');
                recordBtn.querySelector('.icon').classList.add('hidden');
                recordBtn.classList.add('is-recording');
            } catch (error) {
                console.error("Error accessing microphone:", error);
                showMessage('Không thể truy cập micro. Vui lòng cấp quyền và thử lại.', 'error');
            }
        }

        function handleListenAgain() {
            if (lastRecordingBlob) {
                const audioUrl = URL.createObjectURL(lastRecordingBlob);
                replayAudio.src = audioUrl;
                replayAudio.play();
            }
        }

        function startWaveform(stream) {
            uploadBtn.style.display = 'none';
            listenAgainBtn.style.display = 'none';
            waveformContainer.classList.remove('hidden');
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            const computedStyle = getComputedStyle(document.documentElement);
            const accentPrimaryColor = computedStyle.getPropertyValue('--accent-primary').trim();
            const accentSuccessColor = computedStyle.getPropertyValue('--accent-success').trim();

            const canvas = waveformEl;
            const canvasCtx = canvas.getContext('2d');

            function draw() {
                waveformAnimationId = requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                const averageVolume = dataArray.reduce((sum, value) => sum + value, 0) / bufferLength;
                if (averageVolume > 15) soundDetected = true;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 1.5;
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = dataArray[i] / 2.5;
                    const gradient = canvasCtx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                    gradient.addColorStop(0, accentPrimaryColor);
                    gradient.addColorStop(1, accentSuccessColor);
                    canvasCtx.fillStyle = gradient;
                    canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }

        function stopWaveform() {
            if (waveformAnimationId) cancelAnimationFrame(waveformAnimationId);
            if (audioContext && audioContext.state !== 'closed') audioContext.close();
            uploadBtn.style.display = 'inline-flex';
            listenAgainBtn.style.display = 'inline-flex';
            waveformContainer.classList.add('hidden');
        }

        function getHistory() { return JSON.parse(localStorage.getItem('prai-history') || '[]'); }

        function saveToHistory(text, score) {
            if (!text) return;
            let history = getHistory();
            const newEntry = { text, score, date: new Date().toISOString() };
            history = history.filter(item => item.text !== text);
            history.unshift(newEntry);
            if (history.length > 20) history = history.slice(0, 20);
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }

        function loadHistory() {
            const history = getHistory();
            historyList.innerHTML = '';
            if (history.length === 0) {
                historyList.innerHTML = `<p class="text-text-secondary text-center italic">Chưa có lịch sử luyện tập.</p>`;
                clearHistoryBtn.classList.add('hidden');
                return;
            }
            clearHistoryBtn.classList.remove('hidden');
            history.forEach(item => {
                const scoreColor = item.score > 85 ? 'bg-green-500/20 text-green-600 dark:text-green-400' : item.score > 70 ? 'bg-yellow-500/20 text-yellow-600 dark:text-yellow-400' : 'bg-red-500/20 text-red-600 dark:text-red-400';
                const itemEl = document.createElement('div');
                itemEl.className = 'history-item flex justify-between items-center p-2 rounded-md';
                itemEl.innerHTML = `
                    <div class="flex-grow truncate pr-4" data-action="select"><p class="truncate history-item-text">${item.text}</p></div>
                    <div class="flex items-center gap-3 flex-shrink-0">
                        <div class="w-12 h-12 rounded-full flex items-center justify-center font-bold text-xl ${scoreColor}">${item.score}</div>
                        <button class="btn btn-secondary btn-icon !w-8 !h-8 text-accent-danger/70 hover:!bg-accent-danger/20" data-action="delete"><svg class="icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                    </div>`;
                itemEl.dataset.text = item.text;
                historyList.appendChild(itemEl);
            });
        }
        
        function deleteHistoryItem(text) {
            let history = getHistory().filter(item => item.text !== text);
            localStorage.setItem('prai-history', JSON.stringify(history));
            loadHistory();
        }

        function clearHistory() {
            localStorage.removeItem('prai-history');
            loadHistory();
        }
        
        function handleHistoryClick(event) {
            const target = event.target.closest('[data-action]');
            if (!target) return;
            const action = target.dataset.action;
            const text = target.closest('.history-item').dataset.text;
            if (action === 'select') {
                textInput.value = text;
                charCounter.textContent = `${text.length} / 150`;
                historyModal.classList.remove('is-visible');
                resetAll();
                fetchAndDisplayIPA();
            } else if (action === 'delete') {
                deleteHistoryItem(text);
            }
        }
        
        function animateValue(obj, start, end, duration) {
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerHTML = Math.floor(progress * (end - start) + start);
                if (progress < 1) window.requestAnimationFrame(step);
            };
            window.requestAnimationFrame(step);
        }
        
        function renderIntonationChart(svgElement, modelData, userData, stressedWords = []) {
            svgElement.innerHTML = ''; 
            if (!modelData?.length || !userData?.length) return;
        
            const padding = { top: 30, right: 10, bottom: 20, left: 10 };
            const width = svgElement.clientWidth;
            const height = svgElement.clientHeight;
            const innerWidth = width - padding.left - padding.right;
            const innerHeight = height - padding.top - padding.bottom;
        
            const allData = [...modelData, ...userData];
            const yMin = Math.min(...allData);
            const yMax = Math.max(...allData) > yMin ? Math.max(...allData) : yMin + 1;
            
            const scaleX = (index, len) => padding.left + (index / (len - 1)) * innerWidth;
            const scaleY = (val) => padding.top + innerHeight - ((val - yMin) / (yMax - yMin)) * innerHeight;
        
            const createPolyline = (points, color, dash) => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                line.setAttribute('points', points);
                line.setAttribute('fill', 'none');
                line.setAttribute('stroke', `var(--${color})`);
                line.setAttribute('stroke-width', dash ? '2.5' : '2');
                if (dash) line.setAttribute('stroke-dasharray', '4 4');
                return line;
            };

            const modelPoints = modelData.map((d, i) => `${scaleX(i, modelData.length)},${scaleY(d)}`).join(' ');
            const userPoints = userData.map((d, i) => `${scaleX(i, userData.length)},${scaleY(d)}`).join(' ');
            svgElement.appendChild(createPolyline(modelPoints, 'accent-primary'));
            svgElement.appendChild(createPolyline(userPoints, 'accent-warning', true));

            stressedWords.forEach(item => {
                const modelIndex = Math.round(item.time_stamp_normalized * (modelData.length - 1));
                const searchRadius = 2;
                let peakValue = -Infinity;
                for (let i = -searchRadius; i <= searchRadius; i++) {
                    const idx = Math.max(0, Math.min(modelData.length - 1, modelIndex + i));
                    if (modelData[idx] > peakValue) peakValue = modelData[idx];
                }
                
                const x = padding.left + (item.time_stamp_normalized * innerWidth);
                const y = scaleY(peakValue) - 8;

                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textEl.setAttribute('x', x);
                textEl.setAttribute('y', y);
                textEl.setAttribute('text-anchor', 'middle');
                textEl.setAttribute('font-size', '12');
                textEl.setAttribute('font-weight', '600');
                textEl.setAttribute('fill', 'var(--text-primary)');
                textEl.textContent = item.word;
                svgElement.appendChild(textEl);
            });
            
            const legend = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            legend.innerHTML = `
                <rect x="${innerWidth - 180}" y="${height - 15}" width="12" height="2" fill="var(--accent-primary)" />
                <text x="${innerWidth - 165}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng mẫu</text>
                <rect x="${innerWidth - 90}" y="${height - 15}" width="12" height="2" fill="var(--accent-warning)" stroke-dasharray="2 2" stroke="var(--accent-warning)" />
                <text x="${innerWidth - 75}" y="${height - 12}" font-size="10" fill="var(--text-secondary)">Giọng của bạn</text>`;
            svgElement.appendChild(legend);
        }

        function initApp() {
            textInput.addEventListener('input', () => {
                charCounter.textContent = `${textInput.value.length} / 150`;
                resetAll();
            });
            accentSelect.addEventListener('change', () => {
                if (textInput.value.trim()) {
                    resetAll();
                    fetchAndDisplayIPA();
                }
            });
            transcribeBtn.addEventListener('click', fetchAndDisplayIPA);
            listenNaturalBtn.addEventListener('click', () => handleListen('natural'));
            listenClearBtn.addEventListener('click', () => handleListen('clear'));
            recordBtn.addEventListener('click', handleRecord);
            listenAgainBtn.addEventListener('click', handleListenAgain);
            randomPracticeBtn.addEventListener('click', () => {
                const sentence = practiceSentences[Math.floor(Math.random() * practiceSentences.length)];
                textInput.value = sentence;
                charCounter.textContent = `${sentence.length} / 150`;
                resetAll();
                fetchAndDisplayIPA();
            });
            uploadBtn.addEventListener('click', () => audioUploadInput.click());
            historyBtn.addEventListener('click', () => { loadHistory(); historyModal.classList.add('is-visible'); });
            closeHistoryBtn.addEventListener('click', () => historyModal.classList.remove('is-visible'));
            historyModal.addEventListener('click', e => { if (e.target === historyModal) historyModal.classList.remove('is-visible'); });
            clearHistoryBtn.addEventListener('click', clearHistory);
            historyList.addEventListener('click', handleHistoryClick);

            audioUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file?.type.startsWith('audio/')) {
                    const checkAndAnalyze = async () => {
                        if (!textInput.value.trim()) {
                            showMessage('Vui lòng nhập văn bản tương ứng với file âm thanh.', 'warning');
                            return;
                        }
                        resetAnalysisOnly(); 
                        if (!standardIPA) await fetchAndDisplayIPA();
                        if (!standardIPA) {
                            showMessage('Không thể phân tích vì không lấy được phiên âm chuẩn.', 'error');
                            return;
                        }
                        analyzeAudio(file);
                    };
                    checkAndAnalyze();
                } else if (file) {
                    showMessage('Vui lòng chọn một tệp âm thanh hợp lệ.', 'warning');
                }
                event.target.value = null;
            });

            textInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); fetchAndDisplayIPA(); } });
        }

        initApp();
    </script>
</body>
</html>
